package SRC.ALGORITHM;
import java.util.*;



public class BasicsAlgorithm {

    //RELATION
    /* #region Main */

    //SUBARRAY/SUBSTRING,SUBSEQUENCE,SUBSET,COMBINATION,PERMUTATION 
    /*
    arraySubArrayKaArrays(R)
    arraySubsequenceKaArrays(R)
    arraySubsetKaArrays(R)
    arrayCombinationKaArray(R)
    arrayPermutaionKaArray(R)
    arraySubArraySubsequenceSubsetCombinationPermOutationfSizeK(R)
    */


    //NUMBER
    /*
    numerIsHappy(R)
    numberCountAndSay(R)
    numberBitsSetKaCount(BA)
    numberBitsSetKaIndex(BA)
    numberBitsReverse(BA)
    numberBitsToFlipToConvertToOtherNumber(BA)
    numberBitsSetInRangeSetAnotherNumber(BA)
    numberBitsSetKaTotalCount0ToN(BA)
    numberBitsSetKaEachCount0ToN(BA)

    numberIsAPowerOf2(BA)
    numberIsAPowerOf3(BA)
    numberIsWhatPowerOf2(BA)
    numberPower(BA)
    numberSqrt(BA)
    numberFactorial(BA)
    numberFibbonaci(BA)
    numberPrime(BA)
    numberPrime0toNCount(BA)
    numberLCM(BA)
    numberHCF(BA)
    numberFibbonaci(R)

    */
    //EVALUATE EXPRESSION
    /*
    stringEvaluetePostFixExpression
    stringEvaluetePreFixExpression
    stringEvaluateArithmeticExpression

    stringValidParanthesis
    stringValidParanthesWithRedundant

    stringSubstringValidParanthesisLongestShortest

    stringPermutationKabalanceParanthesisKaString
    */
    //INCREASING
    /*
    arraySubArrayKaIncreasingKaLongestLength(R)
    arraySubarrayKaIncreasingTripletKaPossibleAndArray(BA)

    stringSubsequencekaIncreasingKaLongestlength(R)
    stringSubsequenceKaIncreasingTripletKaPossibleAndString(R)

    arrayConvertToIncreasingWithMinIncrementOperation(BA)
    */
    //ISOMORPHIC,ANAGRAM  
    /*
    stringCompare2StringForIsomorphic,stringCompare2StringForIsomorphicc(BA,BA)                             
    stringCompare2StringsForAnagram,stringCompare2StringsForAnagramm,stringCompare2StringsForAnagrammm(BA,BA,BA)                                         
    stringCompare2StringsForAnagramWithOneExtraCharacter,stringCompare2StringsForAnagramWithOneExtraCharacterr(BA,BA)  
    stringSubStringKaContainingAnagramOfOtherStringKaStringAndCount(BA)

    matrixCompareRowsForAnagramsGrouping(BA)
    */
    //PALLINDROME
    /*
    intPallindrome(BA)                                                                               
    stringPallindrome(BA)                                                                           
    stringPallindromeAlphNumeric(BA)                                
    stringPallindromeWith1deletion(BA)   
    linkedListisPallindrome(LL)

    stringSubstringKaPallindromeKaLongestLengthAndLongestString(R)
    stringSubstringKaAllPallindromeKaCoundAndString(R)

    stringSubsequenceKaPallindromeKaLongestLength(R)

    stringPermutationKaPartitionIsPallindromeKaPossible(R)
    stringPermutationKaPartitionIsPallindromeKaStrings(R)

    stringConvertToPallindromeWIthMinInsertionDeletion(R)


    */



    //MAX MIN KTH
    /*
    arraykthSmallestElement,arraykthSmallestElementt(BA,BA)
    arraykthLargestElement,arraykthLargestElementt(BA,BA)
    arrayKsmallestElement,arrayKsmallestElementt(BA,BA)
    arraykLargestElement,arraykLargestElementt(BA,BA)
    arrayK1K2smallestElementsSum,arrayK1K2smallestElementsSumm(BA,BA)
    arrayKTopfrequentElements,arrayKTopfrequentElementss(BA,BA)
    arraykClosestElementsToOrigin,arraykClosestElementsToOriginn(BA,BA)
    arraykClosestElementsToPoint,arraykClosestElementsToPointt(BA,BA)
    */
    //MAX, MIN NEAREST
    /*
    arrayGreatestToLeft(BA)
    arraySmallestToLeft(BA)
    arrayGreatestToRight(BA)
    arraySmallestToRight(BA)

    arrayNearestGreatestToLeft(BA)
    arrayNearestSmallestToLeft(BA)
    arrayNearestGreaterToRight(BA)
    arrayNearestSmallestToRight(BA)

    arrayConsecutiveGreatestToLeft(BA)
    arrayConsecutiveSmallestToLeft(BA)
    arrayConsecutiveGreatestToRight(BA)
    arrayConsecutivemallestToRight(BA)

    arrayHistogramMaxArea(BA)
    arrayContainerMaxArea(BA)
    arrayContainerTotalArea(BA)
    arrayDaysToWaitForNextGreatestTemp(BA)


    */
    //MAXIMISE MINIMUM
    /*
    arraySubarrayKaPartitionKaSumMinimiseMaximum(R, BA -- arrayUnSortedBinarySearchOnSolutionSpace)
    arraySubarrayKaPartitionKaSumMaximiseMinimum(R,BA -- arrayUnSortedBinarySearchOnSolutionSpace)
    arrayUnSortedBinarySearchOnSolutionSpace(BA)

    */
    //ROTATE
    /*
    arrayRotateRight(BA)
    arrayRotateLeft(BA)
    arrayRotateRightKTimes(BA)
    arrayRotateLeftKTimes(BA)
    matrixRotateClockWise(BA)
    matrixRotateAntiClockWise(BA)

    arrayRotatedSortedMinElement(BA)
    arrayRotatedSortedNoOfRotations(BA)
    arrayRotatedSortedFindElements(BA)


    stringCompare2StringsForRotation,stringCompare2StringsForRotationn(BA,BA)  


    */
    //REVERSE
    /*
    numberBitsReverse(BA)
    intReverse(BA)
    stringReverse(BA)
    arrayReverse(BA)
    linkedListReverseRecursive(R)
    stackReverse,stringReversee,stackReverseRecursive(BA,BA,R)
    queueReverse,queueReverseRecursive(BA,BA)
    queueReverse1stKElements(BA)
    stringReverseVovels(BA)
    stringReverseKIntervals(BA)
    stringReverseWordsOrder(BA)
    stringReverseWords(BA)

    */
    //REMOVE
    /*
    arrayRemoveDuplicate,arrayRemoveDuplicatee(BA,BA)
    arrayRemoveDuplicateII,arrayRemoveDuplicateeII(BA,BA)
    arrayRemoveElement(BA)

    stringRemoveVowels(BA)
    stringFirstUniqueCharacterReplaceAtEveryPosition,stringFirstUniqueCharacterReplaceAtEveryPositionn(BA,BA)

    stackDeleteKthElementRecursive(R)
    */
    //SORT 
    /*
    arraySquareSort(BA)
    arrayQuadraticSort(BA)
    arraySetBitsFrequencySort(BA)

    arrayKNearlySortedSort,arrayKNearlySortedSortt(BA,BA)
    arrayfrequencySort,arrayfrequencySortt(BA,BA)

    arrayLargestNumberOnRearrangingSort(BA)

    matrixSortRow(BA)
    matrixSortRowColumn(BA)
    */
    //SORTED FIND
    /*
    arraySortedAscendingFindElement(BA)
    arraySortedDescendingFindElement(BA)
    arraySortedUnknownFindElement(BA)
    arraySortedFirstLastOccurence(BA)
    arraySortedFindInsertionIndex(BA)
    arraySortedFrequencyCountOfItem(BA)
    arraySortedFloorCeilOfItem(BA)
    arraySortedPreviousNextOfItem(BA)
    arraySortedMinimumDifferenceWithItem(BA)
    arraySortedInfiniteFindElement(BA)
    arraySortedInfiniteBinaryFirstLastOccurenceOf1(BA)

    arrayNearlySortedFindElement(BA)

    arrayMountainBitonicPeakElement(BA)
    arrayMountainBitonicFindElement(BA)

    arrayRotatedSortedMinElement(BA)
    arrayRotatedSortedNoOfRotations(BA)
    arrayRotatedSortedFindElements(BA)

    arrayKdiffSortedFindElement(BA)

    arrayUnSortedPeakElement(BA)

    matrixFindElements(BA)
    matrixRowWithMaxOccurenceOf1(BA)

    */
    //CONVERT
    /*
    numberBitsToFlipToConvertToOtherNumber(BA)
    numberExcelConvertToInteger(BA)
    numberRomanconvertToInteger(BA)
    numberIntegerConvertToRoman(BA)
    numberIntegerConvertToToWords(BA)
    numberStringConvertToMobileNumber(BA)
    numberStringConvertToInteger(BA)
    numberFractionConvertToRecurringDecimal(BA)

    stringConvertToPallindromeWIthMinInsertionDeletion(R)
    stringConvertToAnotherStringWithMinimumInsertionDeletion(R)
    stringConvertToEqualStringsWithMinimumDeletion(R)

    arrayConvertToIncreasingWithMinIncrementOperation(R)
    arrayConvertToMinRangeWithIncDecOpertionsI(R)
    arrayConvertToMinRangeWithIncDecOpertionsII(R)

    numberPermutationKaIntegerToStringKaCount(R)
    stringPermutationKaIntegerToMobileString(R)
    matrixComareRowsForNonOverlappingIntervalByMinRemoval(BA)

    */
    //GROUP  
    /*
    arrayGroupByZero(BA)
    arrayGroupByEvenOdd(BA)
    arrayGroupByNegativePositive(BA)
    arrayGroupByLessThanK(BA)

    arrayGroupByEvenOddAlternate(BA)
    arrayGroupByNegativePositiveAlternate(BA)
    arrayGroupByLessThanKAlternate(BA)
    arrayGroupByUniqueAlternate(BA)

    arrayGroupIn3PartsByRange(BA)
    arrayGroupIn3PartsBy012(BA)

    arrayGroupByNegativeTogetherMinSwaps,arrayGroupByNegativeTogetherMinSwapss(BA,BA)
    arrayGroupByLessThanKTogetherMinSwaps,arrayGroupByLessThanKTogetherMinSwapss(BA,BA)
    arrayGroupBy01AlternateMinSwaps,arrayGroupBy01AlternateMinSwapss(BA,BA)
    arrayGroupByEvenTogetherMinSwaps,arrayGroupByEvenTogetherMinSwapss(BA,BA)
    */
    //DISTINCT(UNIQUE),REPEATING(DUPLICATE)
    /*
    arrayContainsDuplicate,arrayContainsDuplicatee(BA,BA)

    stringFirstRepeatedCharacter(BA)
    stringFirstUniqueCharacter(BA)
    stringMaxRepeatedCharacter(BA)
    stringnUniqueAndRepeatedCharacterCount(BA)
    stringFirstUniqueCharacterReplaceAtEveryPosition,stringFirstUniqueCharacterReplaceAtEveryPositionn(BA,BA)

    arrayRemoveDuplicate,arrayRemoveDuplicatee(BA,BA)
    arrayRemoveDuplicateII,arrayRemoveDuplicateeII(BA,BA)

    arrayMissingRanges(BA)
    arrayMissingDuplicate0ToN,arrayMissingDuplicatee0ToN,arrayMissingDuplicateee0ToN(BA,BA,BA)
    arrayMissingDuplicate1ToN,arrayMissingDuplicatee1ToN,arrayMissingDuplicateee1ToN(BA,BA,BA)
    arrayMissingPositive1ToNPlus1,arrayMissingPositivee1ToNPlus1(BA,BA)

    stringSubstringKaCharacterEqualsKDistinctKaLongesKaLengthAndString_PickFruits(R)
    stringSubstringKaCharactersEqualsKDistinctKaCount(R)
    stringSubstringKaCharactersAtMostKDistinctKaLongestShortestKaLengthAndStringAndCount__PickFruits(R)
    stringSubstringKaCharactersAtLeastKDistinctKaLongestShortestKaLengthAndStringAndCount(R)
    stringSubstringKaCharactersAllDistinctKaLongestShortestKaLengthAndStringAndCount(R)
    stringSubstringKaCharacterAllRepeatingOnKReplacementKaLongestShortestLengthAndStringAndCount(R)
    stringSubstringKaCharacterAtleastKRepeatedKaLongestLength(R)
    stringSubstringKaCharactersOddNumberEverythingKaLongestShortestKaLengthAndStringAndCount(R)
    */
    //MISSING,REPEATING(DUPLICATE)
    /*
    arrayMissingRanges(BA)
    arrayMissingDuplicate0ToN,arrayMissingDuplicatee0ToN,arrayMissingDuplicateee0ToN(BA,BA,BA)
    arrayMissingDuplicate1ToN,arrayMissingDuplicatee1ToN,arrayMissingDuplicateee1ToN(BA,BA,BA)
    arrayMissingPositive1ToNPlus1,arrayMissingPositivee1ToNPlus1(BA,BA)
    arrayNelementsPtimesOtherKtimes,arrayNelementsPtimesOtherKtimess,arrayNelementsPtimesOtherKtimesss(BA,BA)
    arrayElementsAppearingMoreThanNbyKTimes,arrayElementsAppearingMoreThanNbyKTimess(BA,BA)
   
    */
    //REPEATING
    /*
    arraySubArrayKaContinuousOneKaLongestLength(R)

    stringSubsequenceKaRepeatingKaLongestLength(R)
    arraySubsequenceKaConsecutiveNumbersInAnyOrderKaLongestLength(R)

    arrayContinuousSumEqualsMinCost_RopesJoining,arrayContinuousSumEqualsMinCost_RopesJoiningg(R)
    */
    //SUM,PRODUCT
    /*
    numberSumWithoutOperator(BA)
    arrayProductExceptSelf(BA)
    arrayContinuousSumEqualsMinCost_RopesJoining,arrayContinuousSumEqualsMinCost_RopesJoiningg(R)

    arraypair2TargetSumI,arraypair2TargetSummI(BA,BA)
    arraypair2TargetSumII,arraypair2TargetSummII(BA,BA)
    arraypair3TargetSumI,arraypair3TargetSummI(BA,BA)
    arraypair3TargetSumII,arraypair3TargetSummII(BA,BA)
    arrayPairKTargetSumI,arrayPairKTargetSummI(BA,BA)
    arraypair2TargetDifferenceI,arraypair2TargetDifferenceeI(BA,BA)

    arraySubarraykaSumKthLargestKaSum(R)
    arraySubArrayKaSumEqualsKKaLongestShortestKaLengthAndStringAndCount(R)
    arraySubArraySumAtMostKKaLongestShortestKaLengthAndStringAndCount(R)
    arraySubArrayKaSumAtleastKKaLongestShortestKaLengthAndStringAndCount(R)
    arraySubArrayKaSumMaxMinKaArray(R)
    arraySubArrayKaProductMaxMinKaArray(R)
    arraySubarrayKaPartitionKaSumMinimiseMaximum(R, BA -- arrayUnSortedBinarySearchOnSolutionSpace)
    arraySubarrayKaPartitionKaSumMaximiseMinimum(R,BA -- arrayUnSortedBinarySearchOnSolutionSpace)


    arraySubsequenceKaSumEqualsTargetKaPossible(R)
    arraySubsequenceKaSumEqualsTargetKaCountI(R)
    arraySubsequenceKaSumEqualsTargetKaCountII_CoinChangeCombinationCount(R)
    arraySubSequenceKaSumEqualsTargetKaMinLengthI(R)
    arraySubSequenceKaSumEqualsTargetKaMinLengthII_CoinChangeCombinationMinCount_PerfectSquareMinCount(R)
    arraySubsequenceKaSumEqualsTargetKaArraysI(R)
    arraySubsequenceKaSumEqualsTargetKaArraysII_CoinChangeCombinationArray(R)
    arraySubsequenceKaSumOfPairsDifferenceEqualsZeroKaPossible(R)
    arraySubsequenceKaSumOfPairsDifferenceEqualsZeroKaCount(R)
    arraySubsequenceKaSumOfPairsDifferenceEqualsTargetKaPossible(R)
    arraySubsequenceKaSumOfPairsDifferenceEqualsTargetKaCount(R)
    arraySubsequenceKaSumOf2PairsDifferenceEqualsTargetKaCount___ArraySignPermutation(R)
    arraySubsequenceKaSumOfPairsDifferenceEqualsMinKaSum(R)
    arraySubsequenceOfSizeKKaSumEqualsTargetKaArraysI(R)


    */ 
    //SUM KNAPSACK
    /*
    arrayknapSack01(R)
    arrayknapSackUnbound_RodCuttingMaxCost(R)
    arrayPermutationFractionalKnapSack(BA)
    */
    //SIZE K 
    /*
    arraySubArraySubsequenceSubsetCombinationPermOutationfSizeK(R)

    arraySubarrayKaSizeKKaMaxMinSum(R)
    arraySubArrayKaSizeKKaFirstNegativeNumbers(R)
    arraySubArrayKaSizeKKaMaxNumbers(R)
    arraySubarrayKaSizekaOddElementKaMinCount(R)

    arraySubsequenceOfSizeKKaSumEqualsTargetKaArraysI(R)

    */
    //COMPARE 
    /*
    //ADDITION
    stringcompare2StringsForAddition(BA)                                                    
    arrayCompare2ArrayForPlusOneAddition(BA)    

    //INTERSECTION , COMMON , UNION , MERGING 
    arrayCompare2ArraysForIntersection,arrayCompare2ArraysForIntersectionn(BA,BA)                                                             
    arrayCompare2ArraysForCommon,arrayCompare2ArraysForCommonn(BA,BA)                                                                 
    arrayCompare2ArraysForUnion,arrayCompare2ArraysForUnionn(BA,BA)                                                          
    arrayCompare2ArrayForMergingI,arrayCompare2ArrayForMerginggI(BA,BA)
    arrayCompare2ArrayForMergingII,arrayCompare2ArrayForMerginggII(BA,BA)      
    arrayCompare2ArrayForMedian,arrayCompare2ArrayForMediann(BA,BA)                                  
    
    stringCompareNStringsForReplacement(BA)  
    stringCompareNStringForAutoComplete(BA)                    
    stringCompareNStringsForLongestCommonPrefix(BA) 
    stringCompareNStringsForLongestCommonPrefixWithWord(BA)  

    matrixCompareRowForIntersection(BA)
    matrixCompareRowForCommon(BA)
    matrixCompareRowForUnion(BA)
    matrixCompareRowForMerging(BA)
    matrixLLCompareRowForMerging(BA)
    matrixCompareRowsForMergingOverlappingInterval(BA)
    matrixCompareRowForMergingOverlappingIntervalByInsertion(BA)
    matrixComareRowsForNonOverlappingIntervalByMinRemoval(BA)
    matrixCompareRowsForMergingMeetingRoomIntervalI(BA)
    matrixCompareRowsForMergingMeetingRoomIntervalII(BA)

    stringSubsequenceKaCommonKaLongestLength(R)                                 
    stringSubsequenceKaCommonKaLongestString(R)
    stringSubstringKaCommonKaLongestLength(R)
    stringSupersequenceKaCommonKaShortestLength(R)
    stringSupersequenceKaCommonKaShortestString(R)

    //CONTAINING
    stringSubstringKaContainingOtherStringKaIndex(R) 
    stringSubsequenceContainingOtherStringIsPossible(R)
    stringSubStringKaContainingAnagramOfOtherStringKaStringAndCount(R)
    stringSubstringKaContainingCharactersOfOtherStringKaLongestShortestLengthAndStringAndCount(R)
    stringSubstringKaContainingCharactersOfItselfKaLongestShortestLengthAndStringAndCount(R)


    //ROTATION,ISOMPRPHIC,ANAGRAM
    stringCompare2StringsForRotation,stringCompare2StringsForRotationn(BA,BA)    
    stringCompare2StringForIsomorphic,stringCompare2StringForIsomorphicc(BA,BA)                             
    stringCompare2StringsForAnagram,stringCompare2StringsForAnagramm,stringCompare2StringsForAnagrammm(BA,BA,BA)                                         
    stringCompare2StringsForAnagramWithOneExtraCharacter,stringCompare2StringsForAnagramWithOneExtraCharacterr(BA,BA)  
    stringSubStringKaContainingAnagramOfOtherStringKaStringAndCount

    matrixCompareRowsForAnagramsGrouping(BA)


    */
    //PERMUTATION, COMBINATION
    /*
    numberPermutationKaStepsKaCount(R)
    numberPermutationKaIntegerToStringKaCount(R)
    stringPermutationKaIntegerToMobileString(R)
    arrayPermutationMaxRobberSumKaSumI(R)
    arrayPermutationMaxRobberSumKaSumII(R)
    stringPermutationKaSpaceKaString(R)
    stringPermutationKaLetterCaseKaString(R)
    stringPermutationKaNumberLetterCaseKaString(R)
    stringPermutationKabalanceParanthesisKaString(R)
    stringPermutationKaBinaryPrefixKaString(R)

    stringPermutationKaPartitionInOtherListKaPossible(R)
    stringPermutationKaPartitionInOtherListKaStrings(R)
    stringPermutationKaPartitionIsPallindromeKaPossible(R)
    stringPermutationKaPartitionIsPallindromeKaStrings(R)

    arrayPermutationKaMinJumpKaCount(BA)
    arrayPermutationKaMinJumpKaPossible(BA)
    arrayPermutationKaMaxStockDifferenceKaDiffI(BA)
    arrayPermutationKaMaxStockDifferenceKaDiffII(BA)
    arrayPermutationKaGasStationKaIndex(BA)

    */
    //PARTITION
    /*
    arraySubArrayKaSplitKaEqualOnesAndZerosKaCount(R)
    arraySubarrayKaPartitionKaSumMinimiseMaximum(R)
    arraySubarrayKaPartitionKaSumMaximiseMinimum(R)


    stringPermutationKaPartitionInOtherListKaPossible(R)
    stringPermutationKaPartitionInOtherListKaStrings(R)
    stringPermutationKaPartitionIsPallindromeKaPossible(R)
    stringPermutationKaPartitionIsPallindromeKaStrings(R)
    */
    //MATRIX,GRAPH
    /*
    maxtrixTraversal(R)
    matrixUniquePathKaCountI(R)
    matrixUniquePathKaCountII(R)
    matrixAllPathsKaMinSum(R)
    matrixConnectedComponentFill_FloodFill(R)
    matrixConnectedComponentArea_FloodFillArea(R)
    matrixConnectedComponentCount_NoOfIslands(R)
    matrixConnectedComponentMaxArea_MaxAreaOfIslands(R)
    matrixWordSearch(R)
    matrixWordSearchII(R)


    graphConstruct(R)
    graphUndirUnionFind(R)
    graphTraversal(R)
    graphDirUndirPathExists(R)
    graphDirUndirConnectedComponentsCount(R)
    graphDirAcyclicTopologicalSort(R)
    graphDirCycleDetection(R)
    graphUnDirCycleDetection(R)
    graphCourseSchedule(R)
    graphCourseScheduleII(R)
    graphDirAcyclicShortestLongestPath(R)
    graphUnDirShortestLongestPath(R)
    graphUndirisBipirtite(R)
    graphDirUndirMinimumSpanningTree(R)
    graphUndirIsValidTree(R)

    */
    //MATRIX
    /*
    matrixPascalTriangle(BA)
    matrixTranspose(BA)
    matrixReflect(BA)
    matrixRotateClockWise(BA)
    matrixRotateAntiClockWise(BA)
    matrixSpiralTraversal(BA)
    matrixMaximumArea(BA)
    matrixZeroFill(BA)
    matrixAliveDeadSimultaneousFill(BA)
    matrixTikTakToe(BA)
    matrixTikTakToeDesign(BA)
    matrixIsValidSudoku(BA)

    */



    //ALGORITHM
    /*
    1.DUTCHFLAG ALGORITHM                                                                           --arrayGroupIn3PartsByRange(),arrayGroupIn3PartsBy012()
    2.KADANES ALGORITHM                                                                             --arraySubArrayKaSumMaxMinKaArray
    3.KMP ALGORITHM                                                                                 --stringSubstringKaContainingOtherStringKaIndex
    3.TOPOLOGICAL-SORT ALGORITHM                                                                    --graphDirAcyclicTopologicalSort, search in recursion methods that use this algo 
    4.UNIO-FIND ALGORITHM                                                                           --graphUndirUnionFind(), search in recursion methods that use this algo 
    5.KAHNS ALGORITHM                                                                               --graphDirAcyclicTopologicalSort()
    6.DIJKSHTRAS ALGORITHM                                                                          --graphUnDirShortestLongestPath
    7.BELLMAN FORD ALGORITHM                                                                        --graphUnDirShortestLongestPath
    8.PRIMS ALGORITHM                                                                               --graphDirUndirMinimumSpanningTree()
    9.KRUSJALS ALGORITHM                                                                            --graphDirUndirMinimumSpanningTree                         

    */

    /* #endregion */




    class Node{}

    //MATH     
    public int     numberBitsSetKaCount(int n){
        /*
        22 -- in a number find the number of set bits
        */
    
        //USING MATHS BIT MANIPULATION
        /*
       EXPLANATION OF BIT MANIPULATION IN JAVA/OBJECT/BITWISE OPERATOR
        22 --   initialise count to 0
                while(n != 0){                                      --move while n!+=0
                    int mask = 1;                                   mask with 0th index set from right 
                    int rightMostBit = n & mask;                       get the bit at 0th index from right        
                    count = (rightMostBit == 1)?count+1:count;      if bit at 0th index is set increment count
                    n = n >>> 1;                                     reduce n by 1 bit on right
                }
                return count;
            }
        Time:O(log2n) -- An integer has log2n bits  
        Space:O(1)
        */
        int count = 0;
        while(n != 0){
            int mask = 1;
            int rightMostBit = n & mask;            
            count = (rightMostBit == 1)?count+1:count;
            n = n >>> 1;
        }
        
        return count;
    }
    public int     numberBitsSetKaIndex(int n){
        /*
        22 -- in a number with only 1 bit set find the position of the set bit
              if more than 1 bits are set return -1
        */   
       
        //USING MATHS BIT MANIPULATION
        /*
       EXPLANATION OF BIT MANIPULATION IN JAVA/OBJECT/BITWISE OPERATOR
        22 -int count = 0;
            int index = 0;
            int indexWith1 = 0;
            while(n != 0){                       --move while n!=0
                int mask = 1                       mask with 0th bit set from right 
                int rightMostBit = n & mask;       get bit at 0th index from right
                if(rightMostBit == 1){             if bit at 0th i == 1
                    count++;                           increment count
                    indexWith1 = index;                indexWith1 = index
                n = n >>> 1;                        reduce n by 1 bits on right                     
                index++;                           increment index
            }
  
            return (count == 1)?indexWith1+1:-1;   -- if count is 1 return pos = indexWith1+1(because position asked) else return -1
        Time:O(log2n) -- An integer has log2n bits  
        Space:O(1)
        */
        
        int count = 0;
        int index = 0;
        int indexWith1 = 0;
        while(n != 0){
            
            int rightMostBit = n & 1;
            if(rightMostBit == 1){
                count++;
                indexWith1 = index;
            }
            n = n >>> 1;
            index++;
        }
        
        return (count == 1)?indexWith1+1:-1;
    }
    public int     numberBitsReverse(int n){
        //USING MATHS BIT MANIPULATION
         /*
        EXPLANATION OF BIT MANIPULATION IN JAVA/OBJECT/BITWISE OPERATOR
         22 --   initialise res to 0; shiftToLeftCount to 31
                 while(n != 0){                                                --move while n!=0
                     int mask = 1;                                               mask with 0th index set from right 
                     int rightMostBit = n & mask;                                get the bit at 0th index from right        
                     int rightMostBitShifted = rightMostBit << shiftToLeftCount; shift rightmostBit to left starting from 31 for 1st bit , 30 times for 2nd time and so on   
                     res = res | rightMostBitShifted;                            shifted bit is ORed with res                     
                     
                     n = n >>> 1;                                                reduce n by 1 bit on right
                 }
                 return res;
             }
         Time:O(log2n) -- An integer has log2n bits  
         Space:O(1)
         */
         int res = 0;
         int shiftToLeftCount = 31;
         while(n!=0){
             int mask = 1;
             int rightMostBit = n & mask;
             int rightMostBitShifted = rightMostBit << shiftToLeftCount;
             res = res | rightMostBitShifted;      
             
             n = n >>> 1;
             shiftToLeftCount--;
         }
         return res;
     }
    public int     numberBitsToFlipToConvertToOtherNumber(int n1,int n2){
        /*
        22 -- Count no of bits of 22 to be flipped to convert to 33  
        33

        */   
       
        //USING MATHS BIT MANIPULATION
        /*
       EXPLANATION OF BIT MANIPULATION IN JAVA/OBJECT/BITWISE OPERATOR
       22 --int count = 0
       33   while(n1!=0 || n2 !=0){                                   ----move while either n1!=0 n2!=0
                int mask = 1                                                mask with 0th index set from right 
                int rightMostBit1 = n1 &1;                                  get 0th bit from right  for n1            
                int rightMostBit2 = n2 &1;                                  get 0th bit from right for n2
                if(rightMostBit1 != rightMostBit2){                         if 0th bit from right  for n1  != 0th bit from right  for n2
                    count++;}                                                   increment count
                n1 = n1>>>1;                                                 reduce n1 by 1 bits on right        
                n2 = n2>>>1;                                                 reduce n2 by 1 bits on right
                
            }
                
            return count;

        Time:O(log2n) -- An integer has log2n bits  
        Space:O(1)
        */
        
        int count = 0;
        while(n1>0 || n2 > 0){
            int rightMostBit1 = n1 &1;
            int rightMostBit2 = n2 &1;
            count = (rightMostBit1 != rightMostBit2)?count+1:count;
            n1 = n1>>1;
            n2 = n2>>1;
            
        }
        
        return count;
        
        
    }
    public void    numberBitsSetInRangeSetAnotherNumber(int n1,int n2,int l , int r){
        /*
        n1,n2                 -- for all bits set in n1 in range l,r 
        l,r  1<=l,r<=32          set equivalent pos in n2
        Eg:n1 = 10 , n2 = 13 , 
           l= 2 , r = 4
           n1 = 1010 -->in pos [2,4] the set bits are at pos 2,4 
           n2 = 1101     so in n2 set pos 2,4 from right
              = 1111
        */   
       
        //USING MATHS BIT MANIPULATION
        /*
       EXPLANATION OF BIT MANIPULATION IN JAVA/OBJECT/BITWISE OPERATOR
       10--int count = 0
       13  -if (l < 1 || r > 32)                     //null check for l , r in bit range
                return n1;
 
            for (int pos=l; pos<=r; pos++){           --move from left to right pos
                int index = pos -1                         index = pos-1 beause index from 0 pos from 1
                int mask = 1 << (index);                   mask with nth index set from right 
                if (n2 & mask == 1)                         get n2 ka nth index  from right == 1                              
                    n1 = n1 | mask;                              set nth index of x ka from right 
            }

        Time:O(log2n) -- An integer has log2n bits  
        Space:O(1)
        */
        
       

        
        
    }
    public int     numberBitsSetKaTotalCount0ToN(int n){
        /*
        0 to 5 -- in a number 1 to 5  find the total number of set bits
        */
    

        //USING MATHS -->Time:O(logn), Spae:O(1)
        /*
        Consider n = 14
            E   D   C   B   A
        0	0	0	0	0	0
        1	0	0	0	0	1
        2	0	0	0	1	0
        3	0	0	0	1	1
        4	0	0	1	0	0
        5	0	0	1	0	1
        6	0	0	1	1	0
        7	0	0	1	1	1
        8	0	1	0	0	0
        9	0	1	0	0	1
        10	0	1	0	1	0
        11	0	1	0	1	1
        12	0	1	1	0	0
        13	0	1	1	0	1
        14	0	1	1	1	0
        A = 7 B =7  C = 7 D = 7


        n = n+1                                                              --n+1 to compensate for 0 aded in beginning
        p = 0
        while (Math.pow(2,p)<= n){                                            -- SET A(p=0) SET B(p=1) SET C(p = 2) ... so on
            int numberOfPairsOf0And1   = n / (int)Math.pow(2,p);                  15        7          3
            int numberOfPairOf1        = numberOfPairsOf0And1/2;                  7         3          1
            int numberOf1              = numberOfPairOf1 * (int)Math.pow(2,p);    7         6          4
            int numberOfExtra1         = (numberOfPairsOf0And1 % 2 != 0)?         0         1          3        
                                         (n % (int)Math.pow(2,p)) : 0; 
            cnt = cnt + numberOf1 + numberOfExtra1;                               7         7          7
            p++; 
        }
    
        
        
        Time:O(log2n) -- An integer has log2n bits  
        Space:O(1)

        
        
        */
        /*
        n =n+1;
        int cnt = 0;
        int p = 0;

        while (Math.pow(2,p)<= n){
            int numberOfPairsOf0And1   = n / (int)Math.pow(2,p);
            int numberOfPairOf1        = numberOfPairsOf0And1/2;
            int numberOf1              = numberOfPairOf1 * (int)Math.pow(2,p);
            int numberOfExtra1         = (numberOfPairsOf0And1 % 2 != 0)?
                                         (n %    (int)Math.pow(2,p)) : 0;
            
            cnt = cnt + numberOf1 + numberOfExtra1;
            p++;
        }
    
        return cnt;
        
        */
        
        //USING MATHS BIT MANIPULATION -->TIME:O(nlogn) , Space:O(1)                     
        /*
        1,2,3,4,5 -- iterate from 0 to n
                     count no of bits in each number
                     return count

        Time:O(n * log2n) -- We iterate n integers and each integer has log2n bits  
        Space:O(1)

        */
        /*
        int count = 0;
        for(int i = 0; i <=n ;i++){
            count = count +  numberBitsSetKaCount(i);
        }
        return count;
        
        */

        return 0;
    }
    public int[]   numberBitsSetKaEachCount0ToN(int n){
        /*
        0 to 2 -- in a number 0 to 2  find return the count of set bits for each no
                  [0,1,1]
        */
    
        //USING MATHS -->Time:O(n) , Space:O(1)
        /*
        Index : 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
        Count:0 1 1 2 1 2 2 3 1 2 2 3 2 3 3 4
        res[0] = 0
        res[1] = res[0] + 1 = res[1-1] + 1;
        res[2] = res[0] + 1 = res[2-2] + 1;
        res[3] = res[1] + 1 = res[3-2] +1;
        res[4] = res[0] + 1 = res[4-4] + 1;
        res[5] = res[1] + 1 = res[5-4] + 1;
        res[6] = res[2] + 1 = res[6-4] + 1;
        res[7] = res[3] + 1 = res[7-4] + 1;
        res[8] = res[0] + 1 = res[8-8] + 1;
   
        res[0] = 0
        res[index] = res[index - offset]
                  
        
        int res[] = new int[n + 1];                       
        res[0] = 0;                                     --initialise res[0] to 0
        int offset = 1;                                   initialise offset t0 1

        for (int index = 1; index <=n ; index++){       --iterate 1 to n
            if (offset*2  == index){offset *= 2;}           if offset*2 == index then reassign offset to offset*2
            res[index] = res[index - offset] + 1;           res[index] = res[index-offser]
        }
        return res;                                       return res

        Time:O(n)
        Space:O(1)



        */

        /*
        int res[] = new int[n + 1];
        res[0] = 0;
        
        int offset = 1;
        for (int index = 1; index <=n ; index++){
            if (offset * 2 == index){
                offset *= 2;
            }
            res[index] = res[index - offset] + 1;
        }
        return res;
         */

        //USING MATHS BIT MANIPULATION -->TIME:O(nlogn) , Space:O(1)                     
        /*
        1,2,3,4,5 -- iterate from 1 to n
                        arr[i] =  no of bits in each number
                    return arr

        Time:O(n * log2n)  --We iterate  n integers and each integer has log2n bit  
        Space:O(1)

        */
        /*
        int[] arr = new int[n+1];int index = 0;
        for(int i = 0; i <=n ;i++){
            arr[index] =   numberBitsSetKaCount(i);
        }
        return arr;
        
        */

        return null;
    }
    public boolean numberIsAPowerOf2(int n){
        /*
        32-- check whether number is a power of 2

        */   
       
        //USING MATHS --> Time: 0(log2n) , Spae:0(1)
        //                n can be byte,short,int,long,float,double(+ve )
        //                return type is T/F    
        /*
        22 -long p = 0;                                         --initialise power to 0
            while(true){                                           move infinitely
                if(Math.pow((double)2,(double)p) == (double)n){    if 2^p == no
                    return true;}                                     return true
                if(Math.pow((double)2,(double)p) > (double)n){     if 2*p > no
                    return false;                                     return false                                   
                p++;                                                increment power
            } 

        Time: 0(lon2n) --as we multiply by power of 2
        Spae:0(1)
        */
        /*
        long  p = 0;                            
        while(true){                             
            if(Math.pow((double)2,(double)p) == (double)no){            
                return true;}                       
            if(Math.pow((double)2,(double)p) > (double)no){  
                return false;                                                       
            p++;                             
        } 
        */
        
        //USING MATHS  -->Time: 0(log10n) , Spae:0(1) 
        //                n can be byte,short,int,long,float,double(+ve )
        //                return type is T/F    
        /*
        32 -- double pow = (double)(Math.log10((long)n) / Math.log10((long)2)); -- 2^p = n ; p = logn/log2 
              return Math.floor((double)pow) == Math.ceil((double)pow)           --chek if p is integer 
                                                                                  Note:
                                                                                  Math.log base(n)   --base e gives precision issue; base 10 doesnt give precision issue
                                                                                        
        
        Time:O(log10n) -- as log calculates internally by repeated multiplication
        Space:O(1)
        */
        /*
        double pow = (double)(Math.log((long)n) / Math.log((long)2));
        return Math.floor((double)pow) == Math.ceil((double)pow);
        */
        
        //USING MATHS BIT MANIPULATION -->Time: 0(log2n) , Spae:0(1) 
        //                n can be byte,short,int,long(+ve)
        //                return type is T/F
        /*
        32 -- return numberBitsSetKaCount(n) == 1;  -- for powers of 2 only 1 bit shoulf be set 
                                                      for all other numbers more than 1 bits are set  
        Time:O(log2n) --integers have log2n bits
        Space:O(1)      
        */
        return numberBitsSetKaCount(n) == 1;
        

        
        
    }
    public boolean numberIsAPowerOf3(int n){
        /*
        27-- check whether number is a power of 3

        */   
       
        //USING MATHS --> Time: 0(log3n) , Spae:0(1)
        //                n can be byte,short,int,long,float,double(+ve )
        //                return type is T/F 
        /*
        22 -long  p = 0;                                                 --initialise power to 0
            while(true){                                                    move infinitely
                if(Math.pow((double)3,(double)p) == (double)no){           if 3^p == no
                    return true;}                                             return true
                if(Math.pow((double)3,(double)p) > (double)no){            if 3^p > no
                    return false;                                             return false                                   
                p++;                                                       increment power
            } 

        Time: 0(log3n) --as we multiply by power of 3
        Spae:0(1)
        */
        /*
        long  p = 0;                            
        while(true){                             
            if(Math.pow((double)3,(double)p) == (double)no){            
                return true;}                       
            if(Math.pow((double)3,(double)p) > (double)no){  
                return false;                                                       
            p++;                             
        } 
        */
        
        //USING MATHS  -->Time: 0(log10n) , Spae:0(1) 
        //                n can be byte,short,int,long,float,double(+ve )
        //                return type is T/F    
        /*
        32 -- double pow = (double)(Math.log10((long)n) / Math.log10((long)3)); -- 3^p = n ; p = logn/log3 
              return Math.floor((double)pow) == Math.ceil((double)pow)           --chek if p is integer 
                                                                                 Note:
                                                                                  Math.log base(n)   --n can be int or long ; fn will return double
                                                                                                       base e gives precision issue; base 10 doesnt give precision issue
                                                                       
        Time:O(log10n) -- as log calculates internally by repeated multiplication
        Space:O(1)
        */
        /*
        double p = (double)(Math.lo10((long)n) / Math.log10((long)2));
        return Math.floor((double)p) == Math.ceil((double)p);
        */
        

        return true;
        

        
        
    }
    public int     numberIsWhatPowerOf2(int n){
        /*
        32-- check whether number is a power of 2
             and return what power of 2

        */   
       
        //USING MATHS --> Time: 0(lon2n) , Spae:0(1)
        //                n can be byte,short,int,long,float,double(+ve )
        //                ret type can be is  byte,short,int,long(+ve)
        //
        /*
        22 -long p = 0;                                         --initialise power to 0
            while(true){                                           move infinitely
                if(Math.pow((double)2,(double)p) == (double)n){    if 2^p == no
                    return (retType)p;}                               return p
                if(Math.pow((double)2,(double)p) > (double)n){     if 2*p > no
                    return (retType)-1;                                return -1                                   
                p++;                                                increment power
            } 

        Time: 0(lon2n) --as we multiply by power of 2
        Spae:0(1)
        */
        /*
        long  p = 0;                            
        while(true){                             
            if(Math.pow((double)2,(double)p) == (double)no){            
                return (retType)p;}                       
            if(Math.pow((double)2,(double)p) > (double)no){  
                return (retType)-1;                                                       
            p++;                             
        } 
        */
        
        //USING MATHS  -->Time: 0(log2n) , Spae:0(1) 
        //                n can be byte,short,int,long,float,double(+ve )
        //                ret type can be  byte,short,int,long,float,double(+ve)
        /*
        32 -- double p = (double)(Math.log10(n) / Math.log10(2)); -- 2^p = n ; p = log2n ; p = log10n/log2n
              if(Math.floor(p) == Math.ceil(p))                      if p is integer  
                     return (retType)p                                 return p
              return (retType)-1                                    return -1
                                                                    Note:
                                                                    Math.log base(n)--base e gives precision issue; base 10 doesnt give precision issue
        Time:O(log2n) -- as log calculates internally by repeated multiplication
        Space:O(1)
        */
        /*
        double p = (double)(Math.log(n) / Math.log(2));
        if(Math.floor(p) == Math.ceil(p)){
            return (retType)p;
        }
        return (retType)-1;
        */
        
        //USING MATHS BIT MANIPULATION -->Time: 0(log2n) , Spae:0(1) 
        //                n can be byte,short,int,long(+ve )
        //                ret type can be byte,short,int,long(+ve)
        /*
        32 -- if(numberBitsSetKaCount(n) == 1);  --  for powers of 2 only 1 bit shoulf be should be set in that case
                  long p=numberBitsSetKaIndex(n)-1    return the index of set bit-1 as the fn returns pos not index
                  return (retType)p
              return (retType)-1                      retun -1

        Time:O(log2n) --  integer has log2n bit
        Space:O(1)    
        */
        /*
        if(numberBitsSetKaCount(n) == 1){
            long p =  numberBitsSetKaIndex(n) -1;
            return (retType)p;
        }
        return (retType)-1;
        */
        return 0;

        
        
    }
    public int     numberPower(int n1, int n2){
        /*
        n1^n2 -- find power
        */
        
        //USING MATHS -->Time:0(n), Space:O(1)
        //                n1 can be byte, short, int ,long, float , double(+ve,-ve), n2 can be byte, short, int ,long(+ve or -ve)
        //                return type can be byte, short, int ,long, float , double(+ve,-ve)
        /*
        double a = (double)n1;          --initialise a to double , b to long
        long b = (long)n2;
            
        if (b < 0) {                     --if b < 0 
            a = (double)(1/a);             invert a and reverse b
            b = -b;
        }
        double res = 1;                    --iterate 1 to b
        for (long i = 1; i <= b; i++)           multiply a to res
            res = res *a;
        
        return (retType)res;               --return res
        
        Time:O(n) -- as we multiply numbers n times
        Space:O(1)
        */

        //USING MATHS -->Time:O(log n); space:O(1)
        //                n1 can be byte, short, int ,long, float , double(+ve,-ve), n2 can be byte, short, int ,long(+ve or -ve)
        //                return type can be byte, short, int ,long, float , double(+ve,-ve)
        /*
              
        double a = (double)n1;                                 --initialise a to double , b to long
        long b = (long)n2;

        if (b < 0) {                                            --if b < 0 
            a = (double)(1/a);                                     invert a and reverse b
            b = -b;
        }
        double ans = 1;
        double currentProduct = n1;
        while(b >= 1){                                          --keep on dividing b by 2
            if(b %2 == 0){                                           if b is even
                ans = ans;                                              ans as it is 
                currentProduct = currentProduct * currentProduct;       currentProduct ka square
            }                                                        else if b is odd
            else{                                                        ans multtiply to currentProduct
                ans = ans * currentProduct;
                currentProduct = currentProduct * currentProduct;
            }
            
            b = (long)b/2; 
        }
        return (reType)ans;                                    --return ans
        
                                                                EXPLANATION
                                                                a^b = (a^2)^b/2      b is even
                                                                    = a*((a^2)^b/2)  b is odd
                                                                EG:
                                                                3^6 
                                                                ans = 1; cp = 3                                
                                                                b = 6 so ans = 1                  ; cp = 3^2             
                                                                b = 3 so ans =1*3^2               ; cp = (3^2)^2      
                                                                b = 1 s0 and = 3^2 * (3^2)^2      ; cp = ((3^2)^2)^2 
                                                                
                                                                3^7
                                                                ans = 1; cp = 3
                                                                b = 7 so ans = 3                  ;cp = 3^2
                                                                b = 3 so ans = 3*(3^2);           ;cp = (3^2)^2
                                                                b = 1 so ans = 3*(3^2) * (3^2)^2  ;cp = ((3^2)^2)^2

                                                        
        Time:O(log n):as we reduce n2 by half for each iteration
        Space:o(1)   

        */

        
        return 0;



    }
    public int     numberSqrt(int n){
        /*
        22 -- Given an integer return sqrt by truncating the decimal part
             Eg: sqrt(8) = 2.82842 = 2
        
        */
        //USING MATHS -->Time:0(n), Space:O(1)
        //                n can be byte, short, int ,long(+ve)
        //                return type can be byte, short, int ,long(+ve)
        /*
        long sqrt = 0;
        
        for(long i= 0; i <= (long)n ; i++){         --iterate till n
            if(i*i == n){                               if i*i == n
                sqrt = (long)i;                             return i
                return (retType)sqrt;                   else if i*i > n 
            }                                               return i-1 as you need truncated value so take lower value
            else if(i*i > n){                         
                sqrt = (long)(i-1);
                return (retType)sqrt;
            }        
        }
        
        return (retType)-1;                           --return -1
        
        Time:O(n)  --as you iterate till n 
        Space:O(1)
        */

        //USING MATHS(BINARY SEARCH)
        /*
        0,1,2,3,4,5
        |        | 
        l        r  
                    
        long left = (long)0;                                           -- initialise l to 0 r to n
        long right = (long)(n);
        while(left <= right){                                              --move till l <= r 
            long mid = left + (right-left)/2;                                   initialise mid, prev , mext
            long prev = mid-1;                                                  
            long next = mid + 1;                                                null check for mid = 0 and mod == n as prev and next may go out of bond 
            if(mid == 0){                                                       if(mid == 0)
                if(mid * mid == (long)n){return (retType)mid;}                    if mid*mid == n ret mid
                else if(next*next > (long)n){return (retType)mid;}                 else mid is a candidate if next satisfies the condition
            }                                                                   else if mid == n
            else if(mid == n){                                                     if mid*mid == n ret mid
                if(mid * mid == (long)n){return (retType)mid;}                     else mid is a candidate if prev satisfies the condition
                else if(prev*prev < (long)n){return (retType)mid;}
            }
            
            if(mid * mid == (long)n)                                            if mid*mid == n
                return (retType)mid;                                                 ret mid
            else if(mid*mid > (long)n){                                         else if mid*mid > n
                right = mid-1;                                                       move to left                                   
            else if(mid*mid < (long)n){                                         else if mid*mid < n            
                if(prev* prev < (long)n && next*next > (long)n){return (int)mid;}   mid is a candidate if prev and next satisfy condition as you need truncated value so take lower value
                left = mid + 1;                                                    
            }
        }
        
        return (retType)-1;
            
        Time:O(log n)  --as you perform BS
        Space:O(1)
        */

        return 0;
    }
    public int     numberFactorial(int n){
        /*
        3 ----> iterate from 3 to 1 and keep on multiplying

       Time:O(n) where n = given n
        Space:O(1)
         */
        
        //USING MATHS
        if(n ==0 )
            return 1;

        int res = 1;
        for(var i = n ; i >= 1 ; i --){
            res = res* i;
        }

        return res;

        //USING MATHS
        /*
        12 -- ArrayList<Integer> res = new ArrayList<>();   --res is an arrayList of digits of the result because factorial of big nos cant be stored in  "long"
                                                            res will store the result of product in reverse order ie 6*4 = [4,2]                                                   

            res.add(1);                                    --initialise res with 1 
            for(int i=2; i<=n; i++) {                      --iterate from 2 to the n and  multiply the number with every digit in result
                int carry = 0;                                   initialise carry to 0
                for(int j=0; j<res.size(); j++) {                res contains digits in reverse order so start from 0
                    int product = res.get(j) * i + carry;        calculate product by multiplying digit with res ka digit and adding carry
                    res.set(j, product % 10);                    product ka last element put in result
                    carry = product/ 10;                         product ka remaining element put in carry 
                }
                while(carry > 0) {                               break carry and put those digits back in result in reverse order
                    res.add(carry % 10);
                    carry /= 10;
                }
            }
            Collections.reverse(res);                    --res contains all digits in reverse order so reverse res
            return res; 
        
        */

        /*
          ArrayList<Integer> res = new ArrayList<>();
           
          res.add(1); 
          for(int x=2; x<=n; x++) {
              int carry = 0;
              for(int i=0; i<res.size(); i++) {
                  int product = res.get(i) * x + carry;
                  res.set(i, product % 10);
                  carry = product/ 10;
              }
              while(carry > 0) {
                  res.add(carry % 10);
                  carry /= 10;
              }
          }
          Collections.reverse(res);
          return res;
          */
    
    

    
    }
    public int     numberFibbonaci(int n){
        /*

        6 --- 1    1     2   3  5  8
              |     |
            prev1  prev2 -- initialise prev1 nd prev2 to 1 and iterate from 2 to n and shift prev1 and prev2
    
        Time:O(n) where n = given n
        Space:O(1)
         */

        //USING MATHS
        if(n == 1 || n == 2)
            return 1;


        int previous1 = 1;
        int previous2 = 1;
        int result =0;

        for(int i=3; i < n ; i++){
            result =  previous1 + previous2;
            previous1 = previous2;
            previous2 = result;
        }

        return result;

        //USING RECURSION
        /*
        Look in recursion
        */





    }
    public boolean numberPrime(int n){
        /*               
        14 -- chek if a number is prime
         */
        
        //USING MATHS
        /*        
        14 -->   if(n == 0||n==1){                               --chek for 0,1 ,2              
                    return false;}
                if(n == 2){
                    return true;}
                if(n%2 == 0){                                     --skip even numbers 
                    return false;                           
                }
                for (int i = 3; i <= (int)Math.sqrt(n) i= i+2){    --iterate 3 to sqrt(n) for odd numbers 
                    if (n % i == 0)                                  if n% i == 0  
                        return false;                                   return false 
                return true;                                         return true
        
        Time:O(sqrt(n)) -- as we iterate till sqrt(n) numbers only
        Space:O(1)
        
        */
        /*
        if(n == 1){
            return false;
        }
        if(n == 2){
            return true;
        }
        if(n%2 == 0){
            retirn false;
        }
        for (int i = 3; i <= (int)Math.sqrt((int)n); i = i+2){
            if (n % i == 0)
                return false;
        }
        return true;
        */
        return true;

    }
    public boolean numberPrime0toNCount(int n){
        /*
        n = 15 -- return the count of prime numbers strictly less that n
                  EG:  n = 15 --2,3,5,7,11,13 so return 6

        */

        //USING MATHS
        /*
        int count = 0;
        for(int i=0;i <= n-1 ; i++){  --iterate from 0 to n-1(prims strictly less than n )
            if(numberPrime(i))        if number s prime
                count++;                 increment count
        }
        return count;                  return couny

        Time:O(n*sqrt(n))  -- you iterate n numbers ; and check if each numver is a prime of not
        Space:O(1)
        
        */

        //USING MATHS(Seive of Eratosthenes)
        /*
        if (n == 0 || n == 1) {                        --check for 0, 1
            return 0;
        }
        
        boolean[] numbers = new boolean[n];             --numbers store prime as false and composite as true 
        for (int i = 2; i <= (int)Math.sqrt(n); i++) {    iterate i = 2 to sqrt(n)
            if (numbers[i] == false) {                         if number is prime(false)
                for (int j = i*i; j <= n-1; j =j+i) {            iterate from i*i to n-1(primes less than n) over multiples of i
                    numbers[j] = true;                           mark number[i] as true
                }
            }
        }
        
        int numberOfPrimes = 0;                         --iterate number from 2 to n-1(primes less than n)
        for (int i = 2; i <= n-1; i++) {                      count number of false
            if (numbers[i] == false) {
                numberOfPrimes++;
            }
        }
        return numberOfPrimes;                            --return number of Primes

                                                            Explanation:
                                                            iterate from 2 to n-1
                                                            if it is a prime(false) 
                                                                    mark all its multiple from 2*i to n-1(primes less than n) as true as they will be composite
                                                            
                                                            count the number of primes by counting number of false from 2 to n-1(primes less than n)

                                                            Improvements:
                                                            In outer loop:Move only till sqrt(n) because after sqrt(n) numbers will be multiple of numbers before sqrt(n)
                                                            In inner loop: Instead of starting from 2*i start from i*i because all the previous multiples would have 
                                                            already been covered by previous prime numbers

                                                            Eg:
                                                            Consider 13

                                                            f f f f f f f f f f f  f  f
                                                            0 1 2 3 4 5 6 7 8 9 10 11 12

                                                            i = 2
                                                            2 is  false so it is a prime
                                                            mark multiples of 2 from 4 to 12 as composite(True)
                                                            f f f f t f t f t f t  f  t
                                                            0 1 2 3 4 5 6 7 8 9 10 11 12

                                                            i = 3
                                                            2 is  false so it is a prime
                                                            mark multiples of 3 from 9 to 12 as composite(True)
                                                            f f f f t f t f t t t  f  t
                                                            0 1 2 3 4 5 6 7 8 9 10 11 12

                                                            f f f f t f t f t t t  f  t --> all primes are marked as false
                                                            0 1 2 3 4 5 6 7 8 9 10 11 12 



        
        Time:O(sqrt(n) log(log(n))) --> sqrt(n)
                                        In outer loop  We iterate from 2 t sqrt(n)

                                        log(log(n))
                                        In inner loop we check every prime number and its multiple
                                        For 2 we check n/2 numbers
                                        For 3 we check n/3 numbers
                                        For 5 we check n.5 numbers
                                        =n/2 + n/3 + n/5 + n/last prime < n
                                        = log(log n)--> Proof of summation http://www.cs.umd.edu/~gasarch/BLOGPAPERS/sump.pdf





        Space:O(n)-->as you create an array of size n
        
        */
        return false;

    }
    public int     numberLCM(int n1,int n2){

        /*
        7,5 --> initialise greater = 7 and keep on icreasing greater till you get greater %7==0 and greater%5 ==0

        Time:O(n) where n = greater
        Space:O(1)
         */

        //USING MATHS
        int greater = (n1>=n2) ? n1:n2;

        while (true) {
            if (greater % n1 == 0 && greater % n2 == 0)
                break;
            greater++;
        }
        return greater;
    }
    public int     numberHCF(int n1, int n2){
        /*
        10,5 --> initialise smaller = 5 and iterate 5 to 1  5%i==0 and 10%i ==0

        Time:O(n) where n = smaller element
        Space:O(1)
         */

        //USING MATHS
        int smaller = (n1 > n2)? n2:n1;

        for(var i =smaller; i > 1; i ++){

            if(n1%i == 0 && n2 %i ==0)
                return i;

        }
        return 1;
    }
    public int     numberExcelConvertToInteger(String s){
        /*
        "A" -> 1   --> convert excel str to integer
        "B" -> 2
        "C" -> 3
        ...
        "Z" -> 26
        "AA" -> 27
        "AB" -> 28 
        ...

        
        */
        
        
        //USING MATHS
        /*
        
        "LZX"
        |  | |
        |  |  25*26^0
        |  26*27^1
        12*27^2
        
       "LZX"
          |
          ptr -- initialise ptr to s.length-1
                while(ptr >= 0){                                  --move ptr to -1(ptr at -1 , cb ptr enc till 0 , ca ptr enc till -1)        
                    int val = (int)(s.charAt(ptr)) - 64;               find the equivalent value of character ('A' -> 65 but here 'A' -> 1)
                    int pow = (int)(Math.pow(26,p));p++;               find the pow of 27 and increment pow
                    res = res+ val*pow;                                res = res + val*pow

                    ptr--;                                             move pyr behinnd
                }
                
        Time:O(n)
        Space:O(1)


        
        */
        int ptr = s.length()-1;
        int res = 0;
        int p = 0;
        while(ptr >= 0){
            int val = (int)(s.charAt(ptr)) - 64;
            int pow = (int)(Math.pow(26,p));p++;
            res = res+ val*pow;
            
            ptr--;
        }
        
        
        return res;
        
        
    }
    public int     numberRomanconvertToInteger(String romanNumber){
        /*
        //Question
        Symbol       Value  --> convert roman str to integer
        I             1         EG : "III" -- 3 ; "LVIII" -- 58 ; "MCMXCIV" -- 1994
        V             5
        X             10
        L             50
        C             100
        D             500
        M             1000
                
        
        */

         //USING MATHS
        /*
        {'I':1,'V':5,'X':10,'L':50,'C':100,'D':'5000','M':5000} --populate map with romanNumber and corresponding intNumber
                                                                   for 1,5,10,50,100,500,1000
        "MCMXCIV" 
               |    |
        currentptr previousptr           -- while currentptr != -1
                                                if currentptr == previousptr 
                                                    add currentptr to intNumber
                                                if currentptr > previousptr
                                                    add currentptr to intNumber
                                                if currentptr < previousptr
                                                    subtract currentptr from intNumber
                                                    
                                                move currentptr and previousptr behind 
                                                //EGDE CASE
                                                previousptr  >= s.length()
                                                then add current to previous
                                                move curr,previous back
                                                continue      
                                            return intNumber; 
         

       Time:O(n) where n = length of roman number 
       Space:O(n) as we use map 
        */
        Map<Character,Integer> map  = new HashMap<>();
        map.put('I',1);
        map.put('V',5);
        map.put('X',10);
        map.put('L',50);
        map.put('C',100);
        map.put('D',500);
        map.put('M',1000);
        
        
        
        
        
        
        int intNumber = 0;
        int previous = romanNumber.length();
        int current = romanNumber.length()-1;
        while(current != -1){
            //EDGE CASE
            if(previous >= romanNumber.length()){
                intNumber = intNumber + map.get(romanNumber.charAt(current));
                current--;
                previous--;
                continue;
            }
            
            if(  map.get(romanNumber.charAt(current)) == map.get(romanNumber.charAt(previous))){
                intNumber = intNumber + map.get(romanNumber.charAt(current));}
            if(  map.get(romanNumber.charAt(current)) > map.get(romanNumber.charAt(previous))){
                intNumber = intNumber + map.get(romanNumber.charAt(current));}
            if(  map.get(romanNumber.charAt(current)) < map.get(romanNumber.charAt(previous))){
                intNumber = intNumber - map.get(romanNumber.charAt(current));}
            
            
            
            
            
            
            current--;
            previous--;
        }
        
        
        return intNumber;
    }
    public String  numberIntegerConvertToRoman(int intNumber){
       /*
        //Question
        Symbol       Value  -->convert int to roman str
        I             1        EG :  3--"III" ;58--"LVIII" ;1994--"MCMXCIV"
        V             5
        X             10
        L             50
        C             100
        D             500
        M             1000
                
        
        */

        //USING MATHS
        /*

        intNums = {1   ,4    ,5  ,9  ,10  ,40 ,50  ,90 ,100 ,400,500 ,900 ,1000}; --populate arrays with intNumber and  corresponding romanNumber
        romanNums  = {"I" ,"IV","V","IX","X","XL","L","XC","C","CD","D","CM" ,"M"}; for 1,5,10,50,100,500,1000
                                                                                   also   4 9  40  90 400 900
                                                                                  
                            
        {1   ,4    ,5  ,9  ,10  ,40 ,50  ,90 ,100 ,400,500 ,900 ,1000}; 
        {"I" ,"IV","V","IX","X","XL","L","XC","C","CD","D","CM" ,|"M"};    
                                                                 | |
                                                              ptr1 ptr2  -- while ptr1 >=0
                                                                                if intNumber >=ptr1  you have found nearest number
                                                                                  while intNumber>=ptr2
                                                                                     remove ptr1 from number
                                                                                     add ptr2 to string 

                                                                                move ptr1 , ptr2 behind

                                         
       Time:O(n) where n = length of roman number 
       Space:O(n) as we use map 
        */
        
        int[]    intNums = {1   ,4    ,5  ,9  ,10  ,40 ,50  ,90 ,100 ,400,500 ,900 ,1000};
        String[] romanNums  = {"I" ,"IV","V","IX","X","XL","L","XC","C","CD","D","CM" ,"M"};
        
        String s = "";
        int ptr1 = intNums.length-1;
        int ptr2 = romanNums.length-1;
        while(ptr1 >=0){
            
            
            if(intNumber >= intNums[ptr1]){
                while(intNumber >= intNums[ptr1]){
                    intNumber = intNumber - intNums[ptr1];
                     s = s + romanNums[ptr2];
                    
                }
               
            }
            
            
            ptr1--;
            ptr2--;
        }    
    
        return s;
            
            
            
        
        
            
    }
    public String  numberIntegerConvertToToWords(int intNumber) {
        /*
        //Question
        123--"One Hundred Twenty Three"                                                       -->convert integer to  word  strin
        12345--"Twelve Thousand Three Hundred Forty Five"
        123467 --"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
        1234567891--"One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One"

                
        
        */

        //USING MATHS
        /*

        GROUPS = {"", "Thousand", "Million", "Billion"}; -->populate GROUPS                                                                          
        1234567 
            |--| -->while (intNumber > 0) 
                     if (groupDigits!= 0) words = IntegerToWordsThreeDigits(groupDigits) +GROUPS[groupCount] + " " + words;                               
                      move groupDigits ahead        |
                      increment groupCount          |
                                                    |
                   return word.trim() -- remove extra space at beginning and end  
                   //EDGE CASE                      |
                   if num ==0 return "zero"         |
                                                    |
                                                    |
        String[] UNITS = {"", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"};
        String[] TENS = {"", "Ten", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"};  -->populate UNITS AND TENS
        123      -->if (integerNum >0 && integerNum < 20){
                        int unitsDigit = integerNum;
                        return UNITS[unitsDigit] + " ";}
                    if (integerNum >=20 && integerNum < 100){
                        int tensDigit = integerNum/10;
                        int unitsDigit = integerNum%10;
                        return TENS[tensDigit] + " " + IntegerToWordsThreeDigits(unitsDigit);}
                    else{
                        int hundredsDigit = integerNum/100;
                        int tendsAndUnitsDigit = integerNum%100;
                        return UNITS[hundredsDigit] + " Hundred " + IntegerToWordsThreeDigits(tendsAndUnitsDigit);
                   }
                   //EDGE CASE
                   if (integerNum == 0)
                    return "";


             

        */
        String[] GROUPS = {"", "Thousand", "Million", "Billion"};
        
        //EDGE CASE
        if (intNumber == 0) return "Zero";

       
        String words = "";
        int groupDigits = intNumber % 1000 ;
        int groupCount = 0;
        while (intNumber > 0) {
            if (groupDigits!= 0) words = "";//IntegerToWordsThreeDigits(groupDigits) +GROUPS[groupCount] + " " + words;
            
            intNumber =intNumber/1000;
            groupDigits = intNumber % 1000 ;
            groupCount++;
        }

        return words.trim();

            
        //IntegerToWordsThreeDigits
        /*
        private String IntegerToWordsThreeDigits(int integerNum) {
            String[] UNITS = {"", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"};
            String[] TENS = {"", "Ten", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"};
            
            if (integerNum == 0)
                return "";
            if (integerNum >0 && integerNum < 20){
                int unitsDigit = integerNum;
                return UNITS[unitsDigit] + " ";}
            if (integerNum >=20 && integerNum < 100){
                int tensDigit = integerNum/10;
                int unitsDigit = integerNum%10;
                return TENS[tensDigit] + " " + IntegerToWordsThreeDigits(unitsDigit);}
            else{
                int hundredsDigit = integerNum/100;
                int tendsAndUnitsDigit = integerNum%100;
                return UNITS[hundredsDigit] + " Hundred " + IntegerToWordsThreeDigits(tendsAndUnitsDigit);
            }
        }
        */

    }
    public String  numberStringConvertToMobileNumber(String s){
        /*
        Question
       "HEY U" -- convert the string to its uquivalent mobile number
                  Look diagram at https://practice.geeksforgeeks.org/problems/convert-a-sentence-into-its-equivalent-mobile-numeric-keypad-sequence0547/1#
                  Eg:"HEY U" -- "4433999088"
        */
        
        //USING MATHS
        /*
        "HEY U"  --populate hashmap with character and its  equivalent number and  number of times the number must be pressed
                   iterate string and get the  character ka equivalent number and  number of times the number must be pressed
                   append number that many times to result string
        Time:O(n)
        Space:O(n)
        
        */
        String res = "";
        for(int i=0 ; i <= s.length()-1;i++){
            //int[] arr = getEquivalentNumber(s.charAt(i));
            int[] arr  = new int[0];
            for(int j=1 ; j <= arr[1];j++){
                res = res+ String.valueOf(arr[0]);
            }
            
        }
    
       return res;

       //getEquivalentNumber()
       /*
       public int[] getEquivalentNumber(char ch){
        Map<Character, int[]> map = new HashMap<>();
        map.put('A',new int[]{2,1});
        map.put('B',new int[]{2,2});
        map.put('C',new int[]{2,3});
        map.put('D',new int[]{3,1});
        map.put('E',new int[]{3,2});
        map.put('F',new int[]{3,3});
        map.put('G',new int[]{4,1});
        map.put('H',new int[]{4,2});
        map.put('I',new int[]{4,3});
        map.put('J',new int[]{5,1});
        map.put('K',new int[]{5,2});
        map.put('L',new int[]{5,3});
        map.put('M',new int[]{6,1});
        map.put('N',new int[]{6,2});
        map.put('O',new int[]{6,3});
        map.put('P',new int[]{7,1});
        map.put('Q',new int[]{7,2});
        map.put('R',new int[]{7,3});
        map.put('S',new int[]{7,4});
        map.put('T',new int[]{8,1});
        map.put('U',new int[]{8,2});
        map.put('V',new int[]{8,3});
        map.put('W',new int[]{9,1});
        map.put('X',new int[]{9,2});
        map.put('Y',new int[]{9,3});
        map.put('Z',new int[]{9,4});
        map.put(' ',new int[]{0,1});
        
        return map.get(ch);    
        
       
        
  
    }
    
    
       
       */
        
        
        
    }
    public int     numberStringConvertToInteger(String s) {
        /*
        "42" -- given string convert it to integer with the following rules
                 1.Read in and ignore any leading whitespace.
                 2.Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.
                 3.Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.
                   Convert these digits into an integer (i.e. "123" -> 123, "0032" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).
                 4.If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.
                 5. Return the integer as the final result.        
        */


        //USING MATHS
        /*
        "    -42"
         |
         ptr     -- initialise ptr to 0
                //SKIP WHITE SPACES
                while (ptr <= s.length()-1 && s.charAt(ptr) == ' ') {             --move ptr till no space(ptr at non space, cb ptr enc till ' ' ca ptr enctill non space)   
                    ptr++; }
                

                //CHECK FIRST CHAR FOR  + -  
                if (ptr <= s.length() - 1 && s.charAt(ptr) == '+') {              --if ptr <= s.length-1 and s[ptr] == '+' 
                    sign = 1;                                                           sign = 1
                    ptr++;}                                                             move ptr ahead
                else if (ptr <= s.length() - 1 && s.charAt(ptr) == '-') {           else if ptr <= s.length-1 and s[ptr] = '-'
                    sign = -1;                                                          sign = -1
                    ptr++;                                                              move ptr ahead
                }
                
                //CHECK NEXT CHAR FOR DIGITS
                while (ptr <= s.length() - 1 && Character.isDigit(s.charAt(ptr))) {   --move ptr till ptr is non digit(ptr at non digit, cb ptr enc till digit ca ptr enctill non digit) 
                    int digit = Integer.parseInt("" +s.charAt(ptr));                              digit = convert ptr to digit                        
                                                            
                                                                                                 //null check res for max before multiplying 10 
                    if ((result > Integer.MAX_VALUE / 10)                                         if result > all except last digit of max
                        || (result == Integer.MAX_VALUE / 10 && digit > Integer.MAX_VALUE % 10)) {      || (result == all except last digit of max and digt > last digit of max) 
                        result = sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;                      return max or min based on sign 
                        return result;
                    }
                                                                                                     //null check res for max before multiplying 10 
                                                                                                    We convert -ve numbers to +ve by keeping a sign variable
                                                                                                    and the conditioin for +ve will suffice for -ve as
                                                                                                    -ve = +ve + 1
                    
                    
                    result = 10 * result + digit;                                                 result = 10*result + digit 
                    ptr++;                                                                        move ptr ahead
                }
                
        //RETURN RES
         return sign * result;                                                         --return res based on sigm
           
        
        */
         int sign = 1; 
         int result = 0; 
         
 
         int ptr = 0;
         while (ptr <= s.length()-1 && s.charAt(ptr) == ' ') { 
             ptr++; 
         }
         

         if (ptr <= s.length() - 1 && s.charAt(ptr) == '+') {
             sign = 1;
             ptr++;} 
         else if (ptr <= s.length() - 1 && s.charAt(ptr) == '-') {
             sign = -1;
             ptr++;
         }
         

         while (ptr <= s.length() - 1 && Character.isDigit(s.charAt(ptr))) {
             int digit = Integer.parseInt("" +s.charAt(ptr));
 
             // Check overflow and underflow conditions. 
             if ((result > Integer.MAX_VALUE / 10) || (result == Integer.MAX_VALUE / 10 && digit > Integer.MAX_VALUE % 10)) { 
                 result = sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
                 return result;
             }
             result = 10 * result + digit;
             ptr++;
         }
         
 
         return sign * result;
     }
    public int     numberIntegerConvertToReverse(int n){
        /*
        -123 -->reverse the integer withouit using string
               Eg: -123 --> -321
              
        
        */
        
        //USING MATHS
        /*
        -123 -- //CHECK FOR + -
                int sign = 1    
                if(n >=0 ){                             --if n >= 0 
                    sign = 1;                                 sign = 1
                    n = n;}                                    n = n   
                else if(n <0){                            else if n <0 
                    sign = -1;                                sign = -1
                    n = -1*n;  X                              n = -1*m X dont do this as we will have an edge case 
                                                                          at n = Int.MIN_VALIE as min = max + 1
                } 

                //REVERSE DIGITS
                int res = 0;
                while (n != 0) {                                                             --while n>0                            
                    int digit = n % 10;                                                          digit = n % 10;                  
                    n = n/10;                                                                    n = n/10
                                                                                                  //null check res for max before multiplying 10 
                    if (res > Integer.MAX_VALUE/10                                                if result > all except last digit of max
                       || (res == Integer.MAX_VALUE / 10 && digit > Integer.MAX_VALUE % 10)){       ||(result == all except last digit of max && digt > last digit of max) 
                        reurn 0;}                                                                   return 0;     
                                                                                                  //null check res for min before multiplying 10 
                    if (res < Integer.MIN_VALUE/10                                                if result < all except last digit of min
                        || (res == Integer.MIN_VALUE / 10 && digit < Integer.MIN_VALUE %10)){        ||(result == all except last digit of min && digt < last digit of min) 
                        return 0;}                                                                   return 0  
                    
                    res = res * 10 + digit;                                                       res = res*10 + digit 
                } 
                return res;                                                                       return res
                
        Time: log10(n)  as youi divide by 10 every time
        Space:O(1)
        */
        
        int sign = 1;
        if(n >=0 ){
            sign = 1;
        }
        else if(n <0){
            sign = -1;
        }
        
        
        
        int res = 0;
        while (n != 0) {
            int digit = n % 10;
            n = n/10;
            if (res > Integer.MAX_VALUE/10 || (res == Integer.MAX_VALUE / 10 && digit > Integer.MAX_VALUE % 10)) return 0;
            if (res < Integer.MIN_VALUE/10 || (res == Integer.MIN_VALUE / 10 && digit < Integer.MIN_VALUE %10   )) return 0;
            res = res * 10 + digit;
        }
        return res;
            
            
    }
    public String  numberFractionConvertToRecurringDecimal(int numerator, int denominator){
        /*
         numerator = 1, denominator = 2 --"0.5"  -->convert fraction to recurring decimal
         */
        /*
         StringBuilder res = new StringBuilder("");
        
        //CHECK NUM, DEN = 0
        if (numerator == 0) {                                     -->Based on num,den = 0 assign res
            res.append("0");
            return res.toString();
        }
        if(denominator == 0){
            res .append("Infinity");
            return res.toString();
        }
        
        //CHECK NUM,DEN>0  < 0
        if (numerator > 0 && denominator > 0) {                  -->Based on num,den= 0 assign +,-(+ is not to be assigned acc to question ) to res 
            res.append("");
        }
        else if(numerator < 0 && denominator > 0){
            res.append('-');
        }
        else if(numerator > 0 && denominator < 0){
            res.append('-');
        }
        else if(numerator < 0 && denominator < 0){
            res.append("");
        }
        
        
        
        //CHECK NUM , DEN =Int.Max,Int.min 
        long dividend = Math.abs((long)numerator);          -->Convert num,den to +ve and Long or else abs(Integer.MIN_VALUE) causes overflow
        long divisor = Math.abs((long)denominator);

        
        //CHECK NUM/DEN = Fractional or not
        long quotient = (long)(dividend / divisor);          -->Based on num/den  assign "." to res
        long remainder = dividend % divisor;
        
        if (remainder == 0) {
            res.append(String.valueOf(quotient));
            return res.toString();
        }
        else{
            res.append(String.valueOf(quotient));
            res.append(".");
        }
  
        //DIVIDE
        Map<Long, Integer> map = new HashMap<>();              -->Perform long division and when remainder repeats at that position recurreing decinal starts
        quotient = (long)(dividend / divisor);                    Find qioutient  
        remainder = (long)(dividend % divisor);                   Find remainder
        while (remainder != 0) {                                  while(remainder != 0){
            if (map.containsKey(remainder)) {                        if(map contains remainder){
                int startPos = map.get(remainder);                     recurrence starts at pos where remainder was found 
                int endPos = res.length();                             recurrence ends at res.length
                 res.insert(startPos, "(");                            put "(" at startPos and ")" at endPos + 1
                res.insert(endPos+1, ")");
                return res.toString();                                 return res
            }                                                     
            map.put(remainder, res.length());                       put remainder and position of remainder in result string to map
            remainder =remainder*10;                                reassign rem = rem*10 for long division
            quotient = (long)(remainder / divisor);                 reassign quotient = rem/divisor for long division
            remainder =remainder%divisor;                           reassign rem = rem % divisor
            res.append(String.valueOf(quotient));                   append quotient to res                  
        }                                                           
        
        return res.toString();                                    --return res
                                                                   EXPLANATION(LONG DIVISION)    
                                                                    
                                                                    0.16 -->res
                                                                    ____
                                                                  6|1.00
                                                                    0
                                                                    _____
                                                                    10            -->remainder = 1  map = {1:2}
                                                                     6
                                                                    ____
                                                                       40         -->remainder = 4 , map = {1:2, 4:3}
                                                                       36
                                                                       ___
                                                                       4         -->remainder =4 ;map contains remainder 4 at pos 3 of res string
                                                                                    so recurring element starts at pos 3 and ends at 3
                                                                                    so res  = 0.1(6)
                                                                                    
                                                                     
        
        
        Time:O(|numerator|/|denominator}).length till recurring digit -->we lopp till we encounter the recurring digits
        Space:O(1)
        
        */
        
        
        StringBuilder res = new StringBuilder("");
        
        if (numerator == 0) {
            res.append("0");
            return res.toString();
        }
        if(denominator == 0){
            res .append("Infinity");
            return res.toString();
        }
        

        if (numerator > 0 && denominator > 0) {
            res.append("");
        }
        else if(numerator < 0 && denominator > 0){
            res.append('-');
        }
        else if(numerator > 0 && denominator < 0){
            res.append('-');
        }
        else if(numerator < 0 && denominator < 0){
            res.append("");
        }
        
    
        long dividend = Math.abs((long)numerator);
        long divisor = Math.abs((long)denominator);
        
    
        long quotient = (long)(dividend / divisor);
        long remainder = dividend % divisor;
        if (remainder == 0) {
            res.append(String.valueOf(quotient));
            return res.toString();
        }
        else{
            res.append(String.valueOf(quotient));
             res.append(".");
        }
     
        quotient = (long)(dividend / divisor);
        remainder = dividend % divisor;
        Map<Long, Integer> map = new HashMap<>();
        while (remainder != 0) {
            if (map.containsKey(remainder)) {
                int startPos = map.get(remainder);
                int endPos = res.length();
                res.insert(startPos, "(");
                res.insert(endPos+1, ")");
                return res.toString();
            }
            map.put(remainder, res.length());
            remainder *= 10;
            quotient = (long)(remainder / divisor);
            res.append(String.valueOf(quotient));
            remainder %= divisor;
        }
        return res.toString();
        
    }
    public int     numberSumWithoutOperator(int n1,int n2){
        /*
         n1 = 1; n2 = 3 -->Find the sum of 2 numbers without using + operator
         * 
         */
        
        //USING MATHS BIT MANIPULATION      
        /*
        3  --0011
        2    0010  --while(n2 !=0 ) {          --move while n2 which holds carry != 0
                        int sum = n1^n2;            n1^n2 will give the sum without worrying about carry
                        int carry = (n1&n2);        n1&n2 will give tha carry generated at that bit
                        carry = carry<<1;           carry<<1 will give the carry to be added because carry is generated at particular bit and is carried frwared to next bit so you need carry at 1 pos left

                        n1 = sum;                   reassign n1 to sum for next iteration
                        n2 = carry;                 reassign n2 to carry for next iteration
                    }
                    return n1;                  return n1 which holds sum
    
        
        
        Time:O(logn)
        Space:O(1)
        */
        while(n2 !=0 ) {
            int sum = n1^n2;
            int carry = (n1&n2);
            carry = carry<<1;

            n1 = sum;
            n2 = carry;
          }
        return n1;
        
    }
    public void    arrayMissingDuplicateee0ToN(int[] arr){

        /*
        QUESTION
        [0,2,3,4,5,6,7] --array of size n must have elements from 0 to n not in sorted order 
                         but array has missing 1 number
                         return the missing  number
                         Eg: [0,2,3,4,5,6,7]  
                             missing  = 1
                         EG [1,2,3]
                            missing = 0
                         EG [0,1]
                            missing = 2 
        */
 
        //USING MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)  -->Time:O(nlogn + n), Soace:O(1)
                                                                  // Multiple    :Array can have  multiple missing duplicates ; we can find multiple  missing,duplicates   
                                                                  // Manipulation :Array is changed      
        /* 
        LOOK IN   ARRAY - MULTIPOINTER SORTSEARCH 
        */
        
        //USING MULTIPOINTER SWAPSORT SEARCH(ARRAY REQUIRES SORTING)   -->Time:O(n) , Space O(1)
        //                                                               Multiple    :Array can have  multiple missing duplicates ; we can find multiple  missing,duplicates   
        //                                                               Manipulation:Array is changed 
        /* 
        LOOK IN   ARRAY - MULTIPOINTER SORTSEARCH 
        */
        
        //USING HASHMAP(ARRAY REQUIRES STORING ELEMENTS)   -->Time:O(n);Space = O(n)
        //                                                    Multiple      :Array can have multiple missing and multiple duplicate ;we can find multiple missing and duplicates                  
        //                                                    Manipulation  :Array is unchanged    
        /*
        LOOK IN HASHMAP/HASHSET
        */             

        //USING  MATHS (ARRAY ELEMENTS HAVE PATTERN)                    -->Time:O(n) , Space O(1)
        //                                                                  Multiple      :Array can have multiple missing duplicate  ; we can find 1 missing and no duplicate so array must ave only 1 missing and no duplicate
        //                                                                  Manipulation  :Array is unchanged
        /*


         Consider numbers as variables
         ideal numbers:  [0,1,2,3,4,5,6]  
         missing  arr :  [0,1,2,3,4,5]  Missing = 6
 
         sum(ideal) - sum(missing) = M                                        

         Time:O(n)   
         Spce:O(1)
 

        */
        
        /*
        int missing = sumOfNumbers(0 to arr.length) - sumOfNumbersOfArray(arr[0] to arr[arr.length-1]);
        return missing; 

        
        */
        

        //USING  MATHS  BIT MANIPULATION(ARRAY ELEMENTS HAVE PATTERN)    -->Time:O(n) , Space O(1)
        //                                                                   Multiple     rray can have multiple missing duplicate  ; we can find 1 missing and no duplicate so array must ave only 1 missing and no duplicate
        //                                                                   Manipulation  :Array is unchanged
        /*
        EXPLANATION OF BIT MANIPULATION IN JAVA/OBJECT/BITWISE OPERATOR
        [0,2,3,4,5,6,7]
         0 1 2 3 4 5 6 nt - initialise exorResult = arr.length;        -->initialise exorResult to arr.length because index reaches 6(arr.length-1) but element reaches 7(arr.length) so ypu need 1 exor element as 7
                            for(int i = 0 ; i <= arr.length -1 ; i++){ -->iterate 0 to arr.length
                                exorResult = exorResult ^ arr[i]^i ;      eliminate elements in even pair(a^a=0 ) and leave missing
                            }                                              7^0^0^1^2^2^3^3^4^5^5^6^6^7 
                            int missing = exorResult;                      0^0^1^2^2^3^3^3^4^4^5^5^6^6^7^7 
                            return missing;                                1


        */

        /*
        int exorResult = arr.length;
        for(int i = 0 ; i <= arr.length -1 ; i++){
            exorResult = exorResult ^ arr[i]^i ;
        }
        int missing = exorResult;
        return missing;
        */




    
 
     }
    public void    arrayMissingDuplicateee1ToN(int[] arr){

        /*
        QUESTION
        [1,2,3,4,4,4,7] --array of size n must have elements from 1 to n not in sorted order 
                         but array has missing number replaced by duplicate numberss
                         return the missing and duplicate number
                         Eg: [1,2,3,4,4,4,7]  
                             missing  = [5,6]
                             duplicate = [4]
                         EG [1,2,3,1,5,1,7,2]
                            missing = [4,6,8]
                            duplicate = [1,2]

        */
 
        //USING MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)  -->Time:O(nlogn + n), Soace:O(1)
                                                                 // Multiple    :Array can have  multiple missing duplicates ; we can find multiple  missing,duplicates   
                                                                 // Manipulation :Array is changed
        /*
        LOOK IN ARR -MULTIPTR SORT SEARCH
        
        */
        
        //USING MULTIPOINTER SWAPSORT SEARCH(ARRAY REQUIRES SORTING)   -->Time:O(n) , Space O(1)
        //                                                                 Multiple    :Array can have  multiple missing duplicates ; we can find multiple  missing,duplicates   
        //                                                                 Manipulation:Array is changed      
        /*
        LOOK IN ARR -MULTIPTR SORT SEARCH
        
        */
       
        //USING HASHMAP(ARRAY REQUIRES STORING ELEMENTS)      -->Time:O(n);Space = O(n)
        //                                                       Multiple      :Array can have multiple missing and multiple duplicate ;we can find multiple missing and duplicates                  
        //                                                       Manipulation  :Array is unchanged
        /*
        LOOK IN HASHMAP HASHSET          
        */


 
        //USING  MATHS (ARRAY ELEMENTS HAVE PATTERN)             -->Time:O(n) , Space O(1)
        //                                                          Multiple      :Array can have only multiple missing and multiple duplicate ;but we can find 1 missing and 1 duplicate(so array must have 1 missinga and 1 duplicate only)
        //                                                          Manipulation  :Array is unchanged
        /*
         Consider numbers as variables
         ideal array           :  [1,2,3,4,5,6]  
         missing duplicate arr :  [1,2,2,4,5,6]  Missing = 3 , duplicate = 2
 
         sum(ideal) - sum(missindDuplicate) = M -D                                       --1
         sumofSquares(ideal) - sumofSquares(missindDuplicate) = M^2 - D^2 = (M+D)(M-D)   --2
         sumofSquares(ideal) - sumofSquares(missindDuplicate)  =M + D                    --3
         ----------------------------------------------
         sum(ideal) - sum(missindDuplicate)   
 
         M= (1+3)/2
         D= M - 1

         Time:O(n)   
         Space O(1)  
 
         


         */
        
        
        /*
        int diff = sumOfNumbers(1 to arr.length) - sumOfNumbersOfArray(arr[0] to arr[arr.length-1]); 
        int diffOfSquare = sumOfSquareOfNumbers(1 to arr.length) - sumOfSquareOfNumbersOfArray(arr[0] to arr[arr.length-1]);
        int sum = (diff!=0)? (int)(diffOfSquare/diff):0";
        int missing   = (int)((diff + sum)/2);
        int duplicate = (int)(missing - diff);
        */
         

        //USING  MATHS BIT MANIPULATION(ARRAY ELEMENTS HAVE PATTERN)    -->Time:O(n)  Space O(1) 
        //                                                                  Multiple      :Array can multiple missing duplicate; but we can use this only 1 missing 1 duplicate(so array must have 1 missinga and 1 duplicate only)
        //                                                                  Manipulation  :Array is unchanged
        /*
        EXPLANATION OF BIT MANIPULATION IN JAVA/OBJECT/BITWISE OPERATOR
         1 2 3 4 5
        [1,2,2,4,5]  --  initialise exorResult to 0;
                        for(int i = 1 ; i <= arr.length;i++){     -->iterate 1 to arr.length
                            exorResult = exorResult^arr[i-1]^i;      eliminate elements in even pair(a^a=0 ) and leave missing^ duplicate)
                        }                                            1^1^2^2^2^3^4 ^4^5^5                 
                                                                    3^2
                                                                    000..001
                        int mask = exorResult&-exorResult;         -->mask is set with  exorResult ka 1st set index ; because exorResult is exor of 2 different elements it will have atleast 1 bit set
                        int n1 = 0;                                  000..001 & -000..010   
                        int n2 = 0;                                  000..011 & 000..110 ka 2' complement

                        for(int i = 0 ; i <= arr.length-1; i++){       
                            if((arr[i] & mask) == 0){               -->get the bit at index = exorResult and segregate elements based on that bit [2,4]  [1,3,5]
                                n1 = n1 ^ arr[i];}                     eliminate elements in even pair(a^a=0 ) 
                                                                        (2^2^4)^(2^4) 
                                                                        2^2^2^4^4
                                                                        2
                            else{                                        
                                n2 = n2 ^ arr[i];}                      (1^5)^(1^3^5)
                        }                                                1^1^5^5^3
                                                                        3
                        
                        int missing = -1;
                        int dulicate = -1;
                        for(int i =0 ; i <=arr.length-1;i++){    -->   iterate over array
                            if(arr[i] == n1){                          if(arr[i] == n1)
                                dulicate = n1;                            duplicate = n1
                                missing = n2;                             missing = n2
                            }
                            if(arr[i] == n2){                         if(arr[i] == n2)
                                dulicate = n2;                          dulicate = n2;
                                missing = n1;                            missing = n1;    
                            }
                        } 
                        
                        
                        
                        
                        
                    return new int[] {dulicate,missing};
        */

        /*
        int exorResult = 0;
        for(int i = 1 ; i <= arr.length;i++){    
            exorResult = exorResult^arr[i-1]^i;     
        }                                                         
                                                     
                                                     
        int mask = exorResult&-exorResult;         
        int n1 = 0;                                  
        int n2 = 0;                                  

        for(int i = 0 ; i <= arr.length-1; i++){       
            if((arr[i] & mask) == 0){               
                n1 = n1 ^ arr[i];}                    
                                                        
                                                        
                                                         
            else{                                        
                n2 = n2 ^ arr[i];}                      
        }                                                
                                                         
         
        int missing = -1;
        int dulicate = -1;
        for(int i =0 ; i <=arr.length-1;i++){   
            if(arr[i] == n1){                         
                dulicate = n1;                           
                missing = n2;                            
            }
            if(arr[i] == n2){                         
                dulicate = n2;                        
                missing = n1;                    
            }
        } 
         
         
         
         
         
       return new int[] {dulicate,missing};
        
        
        */


 


     }
    public void    arrayNelementsPtimesOtherKtimesss(int[] arr){
         /*
         Question
         [2,2,3,2] -- array has elements where n elements appear p times and other elements appear k times
                      return element that appears p times
                      EG
                      [2,2,3,2] n=1,p = 1,k = 3         --means 1 element appears 1 time and other elements appear 3 times ; so return 3
                      [2,2,3,2,3,1,1,1] n=1,p = 2,k = 3 --means 1 element appears 2 time and other elements appear 3 times ; so return 3
                      [1,2,1,3,2,5]  n=2,p = 1,k = 2    --means 2 element appears 1 time and other elements appear 2 times ; so return [3,5] 

         
        */
        
        //USING MULTIPTR SORT AND SEARCH(ARRAY REQUIRES SORTING) -->Time:O(logn + n), Soace:O(1)
        //                                                           Multiple    :Array can have  multiple missing duplicates ; we can find multiple  missing,duplicates   
        //                                                           Manipulation :Array is changed
        /*
        LOOK IN ARR- MULTIPTR SORT SEARCH
        */
        
        //USING  MATHS BIT MANIPULATION(ARRAY ELEMENTS HAVE PATTERN)     -->Time:O(n)  Space O(1) 
        //                                                                  Multiple      :AArray can have n=anything,p=anything,k=anything; but we can use this only for n=2,p=1,k=2.
        //                                                                  Manipulation  :Array is unchanged
        /*
        LOOK IN ARR- MULTIPTR SORT SEARCH
        */

        //USING  MATHS BIT MANIPULATION(ARRAY ELEMENTS HAVE PATTERN)     -->Time:O(n)  Space O(1)   
        //                                                                   Multiple      :Array can have n=anything,p=anything,k=anything; but we can use this only for n=1,p=anything,k=anything
        //                                                                   Manipulation  :Array is unchanged
        /*
        EXPLANATION OF BIT MANIPULATION IN JAVA/OBJECT/BITWISE OPERATOR
        int xm = 0,                    //m =  2^m >=k
        .
        .
        int x2 = 0,
        int x1 = 0
        int mask = 0;
        
        
        for (int i : nums) {
            xm = xm ^ (xm-1 & ... & x1 & i)
            .
            .
            x2 ^= x1 & i;
            x1 ^= i;
            
            mask = ~(xm & .. x2 & x1);   //If 2^m ==k :mask not req
                                         //If 2^m >k; mask req
                                         //K = kj...k2k1 (binary form)-->if kj = 1  xj = xj ; if kj=0  xj = ~xj  where k = kj...k2k1k0  binary form  
                                         
            
            xm = xm & mask
            .
            .
            x2 =x2 & mask;
            x1 =x2 & mask;
            
            
            return x1                //p' = p%k = = pj...p2p1(binary form)-->  if pj =1 you can return xj 
                                      
        }
        
        Time:O(n logk) 
        Space O(log k) 
           
           
        
        //EXPLANATION:--https://leetcode.com/problems/single-number-ii/discuss/43295/Detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers
        Consider [2,2,3,2] k = 3, p = 1,n=1
        int x1 = 0, x2 = 0, mask = 0;    //m = 2^m >= 3 ; m = 2
        for (int i : arr) {
         x2 =x2^(x1 & i);
         x1 = x1^i;

         mask = ~(x1 & x2);         //2^m >k mask req
                                    //k = 11   k2=1 x2 = x2 ; k1 = 1 x1 = x1
         x2 = x2 & mask;
         x1 = x1 &  mask;

         return x1                   //p' = 1%3 = 1 = 01  p2 = 0 ; p1 = 1 so you can return x1
        
        i         x2[x2^(x1&i)] & mask            x1[x1 ^i] & mask -->~(x1 & x2)
                  00                                00   M =11                

                  
        10        00                                10   M=11

                   
        10        10                                00   M=11

        
        11        10                                11    M=01
                  00                                01
                  
        10        00                                11   M=11

        return 11 = 3
        
        
        
        Consider [2,2,1,2,1] k = 3 , p = 2 , n=1
        int x1 = 0, x2 = 0, mask = 0;          //m = 2^m >= 3 ; m = 2
        for (int i : arr) {
         x2 =x2^(x1 & i);
         x1 = x1^i;

         mask = ~(x1 & x2);               //2^m >k mask req
                                         //k = 11   k2=1 x2 = x2 ; k1 = 1 x1 = x1

         x2 = x2 & mask;
         x1 = x1 &  mask;

         return x2                     //p' = 2%3 = 2 = 10  p2 = 1 ; p1 = 0 so you can return x2
             
        i         x2[x2^(x1&i)] & mask            x1[x1 ^i] & mask -->~(x1 & x2)
                  00                              00
            
        10        00                              10    M=11                 

                  
        10        10                              00    M=11

        
        01        10                              01    M=11

                  
        10        10                              11    M=01
                  00                              01
        
        01        01                              01    M=01
        
        
        
                     
        
        
        
        
        
        
        */
        

        /*
        //k = 2 ; p = 1
        int x1 = 0;            //m = 2^m >=k  m = 1        
        int mask = 0;
         
        for (int i : arr) {
            x1 = x1^i;
                                //2^m ==k ; mask noy required
        
        
        }

        return x1;  // p' = 1%3 = 1 = 01 -->p2 = 0 p1 =1 so return x1 


        //k = 3 ; p = 1
        int x2 = 0;     //m = 2^m >=k  m = 2
        int x1 = 0;                   
        int mask = 0;
         
        for (int i : arr) {
            x2 = x2 ^(x1 &i); 
            x1 = x1^i;
            
            mask = ~(x1 & x2);      //2^m > k ; mask  required
                                    //k = 3 = '11'-->k2 = 1 x2 = x2 ; k1 = 1 x1 = x1
            
            x2 = x2 & mask;
            x1 = x1 & mask;
        
        }
           
        return x1;              // p' = 1%3 = 1 = 01 -->p2 = 0 p1 =1 so return x1    

        //k = 5 ; p = 3
        int x3 = 0;             //m = 2^m >=k  m = 3
        int x2 = 0;
        int x1 = 0;
        int mask = 0;
         
        for (int i : arr) {
            x3 = x3^(x2&x1&i);
            x2 = x2 ^(x1 &i); 
            x1 = x1^i;
            
            mask = ~(x1 & ~x2 & x3);   //2^m > k ; mask  required
                                      //k = 5 = '101'-->k3 = 1 x3 = x3 ; k2 = 0 x2 = ~x2 ; k1 = 1 x1 = x1
            
            x3 = x3 & mask;                          
            x2 = x2 & mask;
            x1 = x1 & mask;
        
        }
           
        return x1;              // p' = 3%5 = 3 = 11 -->p2 = 1 p1 =1 so return x2 or x1   

        */

 
        

        
    }
    public boolean stringCompare2StringsForRotationn(String s1 , String s2){
        /*
        s1 = "abc"  -- compare s1 and s2
        s2 = "bca"     amd find whether s2 is a right/left rotation of s1( Rotate right -- Move array to right ;the displaced element at last pos place at first index  Eg: 1 2 3 4 5 -- 5 1 2 3 4 -- 4 5 1 2 3  
                                                                            Rotate left  -- Move array to left ; the displaced element at first pos place  at last index Eg: 1 2 3 4 5 -- 2 3 4 5 1 -- 3 4 5 1   )

        */
        
        //USING -MULTIPOINTERS  (ARRAY REQUIRES MULTIPTR FOR) -->Time: O(n^2) , Space:O(n)
        /*
        LOOK IN ARRAY -MULTIPOINTERS
        */

        
        //USING MATHS (ARRAY ELEMENTS HAVE PATTERN) -->TIME: O(1) , SPACE:O(1)
        /*
        s1 = "abc"
        s2 = "bca"- if (s1.length() != s2.length()) {return false;}  -- s1 length and s2 length must be equal
                    if (!(s1 + s1).contains(s2)) {return false;}      -- s1 +s2 must contain s2
                    return true;
        */

        if (s1.length() != s2.length()) {return false;}
        if (!(s1 + s1).contains(s2)) {return false;}
        return true;
    }
    public boolean stringCompare2StringsForAnagrammm(String s1 , String s2){
        /*
        Question
        s1 = "abcde" -- compare s1 and s2
        s2 = "dbace"    and find if s2 is a anagram of s1((anagram means same characters in hjumbled sequence)

                 
        */
        
        
        //USING -MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES COMPARISION FOR  2 ARRAYS) -->Time: O(nlogn + n); Space:O(1)
        /*
        LOOK IN ARRAY MULTIPTR SORT SEARCH
        */
        
        //USING MATHS BIT MANIPULATION(ARRAY ELEMENTS HAVE PATTERN) -->Time: O(n); Space:O(1) XXX  CANT  USE 
        /*
        EXPLANATION OF BIT MANIPULATION IN JAVA/OBJECT/BITWISE OPERATOR
        exorResult = exorResult ^ s1.charAt(i);^ s2.charAt(i)  --Consider s1 = "aa" ; s2 = "bb" 
                                                                  =a^a^b^b       
                                                                  =0            -->both are not anagrams still it goves 0 
                                                                                   hence we can't use bit manipulation

        
        */
        /*
        CANT USE BIT MANIPULATION
        */
        return false;
        

        
        
        
    }
    public char    stringCompare2StringsForAnagramWithOneExtraCharacterr(String s1 , String s2){
        /*
        Question
        s1 = "abcde" -- compare s1 and s2 which are anagram with 1 extra characrer
        s2 = "dbafce"   find and return extra character                 
                 
        */
         
         //USING -MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES COMPARISION FOR  2 ARRAYS)--> Time: O(nlogn + n); Space:O(1)
         /*LOOK IN ARRAY MULTIPTR SORT SEARCH
         */

        
        //USING MATHS BIT MANIPULATION(ARRAY ELEMENTS HAVE PATTERN) -->Time: O(n); Space:O(1)
        /*
        EXPLANATION OF BIT MANIPULATION IN JAVA/OBJECT/BITWISE OPERATOR
        s1 ="abcde"
        s2 ="dbafce"    -- int exorResult = 0;                                                        -- initialise exorResult result to 0 
                         
                            int ptr1 = 0;
                            int ptr2 = 0;
                            while(ptr1 <= s1.length()-1 && ptr2 <= s2.length()-1){
                                exorResult = exorResult ^ (int)s1.charAt(ptr1) ^ (int)s2.charAt(ptr2);  -->eliminate elements in pair (a^a=0)and exorResult will have  extra element
                                ptr1++;                                                                    a^b^c^d^e^d^b^a^f
                                ptr2++;                                                                    a^a^b^b^c^c^d^d^e^f
                            }                                                                              e^f                     

                            
                                                                            
                            
                            if(ptr1 != s1.length()){
                                exorResult = exorResult ^ (int)s1.charAt(ptr1);                  -- eliminate elements in pair (a^a=0)and exorResult will have  extra element
                                ptr1 ++;
                                
                            }
                            else if(ptr2 != s2.length()){
                                exorResult = exorResult ^ (int)s2.charAt(ptr2);                 -- eliminate elements in pair (a^a=0)and exorResult will have  extra element
                                ptr2++;                                                            e^f^e
                            }                                                                      e^e^f
                                                                                                   f
                            return (char)exorResult;
        
        Time:O(n)
        Space:O(1)
        */

        int exorResult = 0;
        
        
        int ptr1 = 0;
        int ptr2 = 0;
        while(ptr1 <= s1.length()-1 && ptr2 <= s2.length()-1){
            exorResult = exorResult ^ (int)s1.charAt(ptr1) ^ (int)s2.charAt(ptr2);
            ptr1++;
            ptr2++;
        }
        
        if(ptr1 != s1.length()){
            exorResult = exorResult ^ (int)s1.charAt(ptr1); 
            ptr1 ++;
            
        }
        else if(ptr2 != s2.length()){
            exorResult = exorResult ^ (int)s2.charAt(ptr2);
            ptr2++;
        }
        
        return (char)exorResult;


        
        
    }



    
    //ARRAY - MULTIPOINTERS 
    /*
   IDENTIFY
   ARRAY REQUIRES MULTIPLR PTRS
   */
    public boolean intPallindrome(int num){

        /*
        Question
        "-121" -- check if int is pallindrome   without converting it to string ie constant space
                  and return true or false
                  Eg -121 is not a pallindrome
                    121  is a pallindrome
        */

        //USING REVERSE AND COMPARE INSTEAD OF  MULTIPOINTERS SINGLE  ARAY
        /*
        121   --  if(num < 0)    
                    return false;
        
                int reversed_num =0;
                int original_num = num; 
                while(num != 0) {
                    int remainder = num % 10; 
                    reversed_num = reversed_num * 10 + remainder; 
                    num  = num/10; }

                return original_num == reversed_num;
        
        Time:O(n) where n = length of num
        Space:O(1)               
        */

        if(num < 0)    
            return false;

            int reversed_num =0;
            int original_num = num; 
            while(num != 0) {
                int remainder = num % 10; 
                reversed_num = reversed_num * 10 + remainder; 
                num  = num/10; }

            return original_num == reversed_num;
            

        }
    public boolean stringPallindrome(String s){
            /*
        Question
        "civic" -- check if string is pallindrome
                    so return true or false
        */
        
            //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR)
            /*
            "civic"    --- while(ptr1 <= ptr2){   -->move ptr1 , ptr2 till ptr1 <= ptr2
            |    |              if(ptr1 != right)    (ptr1 right reach at node where ptr1=ptr2 ; code before moving ptr encounter till ptr1eft < ptr2; code after moving ptr encounter till ptr1 == ptr2)
            ptr1 ptr2            return false;
                                move ptr1 ahead
                                move ptr2 behind
                        return true;

                        //EDGE CASE :str length = 0 rthen return true

                        
            Time : O(n) as we reduce n(length of str ) by 1
            Space: O(1)
            
            */                 


            //EDGE CASE
            if(s.length() == 0)
                return true;
    

                    
            int ptr1 = 0;
            int ptr2 = s.length() -1;
            while(ptr1 <= ptr2){
                char chl = s.charAt(ptr1);
                char chr = s.charAt(ptr2);

                if(Character.toLowerCase(chl) != Character.toLowerCase(chr))
                    return false;
                            
                ptr1++;
                ptr2--;
            
            
                
                
                
                
            }
            
            return true;
        }
    public boolean stringPallindromeAlphNumeric(String s){
        /*
        Question
        "A man, a plan, a canal: Panama" -- check is pallindrome considering only alphanemuric characters after converting them to lowercase 
                                            so return true or false
                                            Eg "amanaplanacanalpanama" is a pallindrome 



        */

        //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR)
        /*
        "A man, a plan, a canal: Panama"    --- while(ptr1 <= ptr2){                 -->move ptr1 , ptr2 till ptr1 <= ptr2
        |                             |              if(ptr1 is not a digit or letter)  (ptr1 ptr2 reach at node where ptr1=ptr2 ; code before moving ptr encounter till ptr1 < ptr2; code after moving ptr encounter till ptr1 == ptr2)
        ptr1                         ptr2              move ptr1 ahead
                                                    else if(ptr2 is not a digit or letter)
                                                        move ptr2 behind
                                                    else
                                                    |  if(ptr1 lowercase != ptr2 lowercase)
                                                    |    return false
                                                    |  move ptr1 ahead
                                                    | move ptr2 behind
                                                retur|n true;
                                                    |
                                            else if because ptr1,ptr2 modifies inside if else
                                                and ptr1,ptr2  used as conditiom

                                            //EDGE CASE :str length = 0 rthen return true

                                                
        Time : O(n) as we reduce n(length of str ) by 1
        Space: O(1)
        
        */     
        //EDGE CASE
        if(s.length() == 0){return true;}


        int ptr1 = 0;
        int ptr2 = s.length() -1;
        while(ptr1 <= ptr2){
            char chl = s.charAt(ptr1);
            char chr = s.charAt(ptr2);
            if(!Character.isLetterOrDigit(chl) )
                ptr1 ++;
                    
            else if(! Character.isLetterOrDigit(chr))
                ptr2--;
            else{
                if(Character.toLowerCase(chl) != Character.toLowerCase(chr))
                    return false;
                        
                ptr1++;
                ptr2--;
        
        
            
            }
            
            
        }
        
        
        return true;
        
    }
    public boolean stringPallindromeWith1deletion(String s){
        /*
        cividc  -- delete 1 element and check if string is pallindrome
                   so return true or false
                  Eg d is dleted then "cividc" is a pallindrome
        */

        //USING MULTIPOINTERS SINGLE  ARAY(ARRAY REQUIRES MULTIPLE PTR)
        /*
        cividc
        |     |
        ptr1  ptr2  -         while(ptr1 <= ptr2){                    
                                if(s.charAt(ptr1) != s.charAt(ptr2)){
                                    At mismatch we check if from i+1 to j is a pallindrome OR  if from i to j-1 is a pallindrome  
                                }         
                                ptr1++;
                                ptr2--;
                            }
                            
                            return true;

        
        Time : O(n) -->O(n) not O(n^2)   
        Space: O(1)    because iterate through arr and if there is a mismatch you check if i+1 j-1 is pallindrome  so you "return  without going  to outer loop" 
                        ie c  c
                        i  d           -- mismatch
                        v  i OR i  i  --  continue searching without going to outer loop
                                v  v
            
            */



        int ptr1 = 0;
        int ptr2 = s.length() -1;
        
        while(ptr1 <= ptr2){
            if(s.charAt(ptr1) != s.charAt(ptr2)){
                //return  stringPallindrome(s , ptr1+1 , ptr2)|| stringPallindrome(s, ptr1 ,ptr2-1);
                
            }
            
            
            ptr1++;
            ptr2--;
        }
        
        return true;
        




    }
    public void    arrayRotateRight(int[] arr , int startIndex, int endIndex){
        /*
        Rotate right -- Move array to right ;the displaced element at last pos place at first index
                        Eg: 1 2 3 4 5 -- 5 1 2 3 4 -- 4 5 1 2 3  
        Rotate left  -- Move array to left ; the displaced element at first pos place  at last index
                        Eg: 1 2 3 4 5 -- 2 3 4 5 1 -- 3 4 5 1   
        */

        //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR)
        /*
        [1,2,3,4,5,6]
                |      consider startIndex = 0 , endIndex = arr.length-1 
                ptr -- initialise ptr at endIndex
                        int temp = arr[ptr]
                        move ptr till startIndex+1(ptr reaches at startIndex and exits ; code before moving ptr encounter till startIndex+1 ; code after moving ptr encounter till startIndex)
                            arr[ptr] = arr[ptr-1];
                        arr[startIndex] = temp 
        
        Time :O(n)
        Space:O(1)
        */

        int ptr = endIndex;
        int temp = arr[ptr];
        while(ptr >=startIndex+1){
            
            arr[ptr] = arr[ptr-1];            
            ptr--;
        }
        
        arr[startIndex] = temp;
        }
    public void    arrayRotateLeft(int[] arr , int startIndex, int endIndex){
        /*
        Rotate right -- Move array to right ;the displaced element at last pos place at first index
                        Eg: 1 2 3 4 5 -- 5 1 2 3 4 -- 4 5 1 2 3  
        Rotate left  -- Move array to left ; the displaced element at first pos place  at last index
                        Eg: 1 2 3 4 5 -- 2 3 4 5 1 -- 3 4 5 1   
        
        
        */

        //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR)
        /*
        [1,2,3,4,5,6]
        |     consider startIndex = 0 , endIndex = arr.length-1 
        ptr -- initialise ptr at startIndex
                int temp = arr[ptr]
                move ptr till endIndex-1(ptr reaches at endIndex and exits ; code before moving ptr encounter till endIndex-1 ; code after moving ptr encounter till endIndex)
                    arr[ptr] = arr[ptr+1];
                arr[endIndex] = temp 
        
        Time :O(n)
        Space:O(1)
        */

        int ptr = startIndex;
        int temp = arr[ptr];
        while(ptr <=endIndex-1){
            arr[ptr] = arr[ptr+1];            
            ptr++;
        }
        
        arr[endIndex] = temp;
        }
    public void    arrayRotateRightKTimes(int[] arr , int k){
        /*
            Rotate right k times-- Move array to right ;the displaced element at last pos place at first index ; do this k times
                                Eg: 1 2 3 4 5 -- 5 1 2 3 4 -- 4 5 1 2 3  
            Rotate left k times -- Move array to left ; the displaced element at first pos place  at last index  ; do this k times
                                Eg: 1 2 3 4 5 -- 2 3 4 5 1 -- 3 4 5 1   
            */
        

        //USING MULTIPOINTERS(ARRAY REQUIRES MULTIPLE PTR) -->ROTATION Time :O(n*k), Space:O(1)
        /*
        [1,2,3,4,5,6]
        |    
        ptr -- k = k% arr.length --> k=1=rotate 1 times ; k = 2 = rotate 2 times ..k=7 = rotate 7 times = rotate 1 time
                for(int i = 1 ; i <=k ; i++){
                    arrayRotateRight(arr,0, arr.length-1);
                } 
        
        Time :O(n*k)
        Space:O(1)
        */

        k = k%arr.length;
        for(int i = 1 ; i <=k ; i++){
            arrayRotateRight(arr,0, arr.length-1);
        }

        //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR)--> REVERSE Time :O(n), Space:O(1)
        /*
        [1,2,3,4,5,6] k =2
        |
        ptr  -- k = k% arr.length --> k=1=rotate 1 times ; k = 2 = rotate 2 times ..k=7 = rotate 7 times = rotate 1 time
                reverse array 0 to arr.length -1   [6,5,4,3,2,1]
                reverse array 0 to k-1             [5,6,4,3,2,1]
                reverse array k to arr.length-1    [5,6,1,2,3,4]
        */
        k = k% arr.length;
        arrayReverse(arr, 0, arr.length-1);
        arrayReverse(arr, 0, k-1);
        arrayReverse(arr, k, arr.length-1);



    }
    public void    arrayRotateLeftKTimes(int[] arr , int k){
        /*
        Rotate right k times-- Move array to right ;the displaced element at last pos place at first index ; do this k times
                                Eg: 1 2 3 4 5 -- 5 1 2 3 4 -- 4 5 1 2 3  
        Rotate left k times -- Move array to left ; the displaced element at first pos place  at last index  ; do this k times
                                Eg: 1 2 3 4 5 -- 2 3 4 5 1 -- 3 4 5 1   
        */
    

        //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR) -->ROTATION Time :O(n*k), Space:O(1)
        /*
        [1,2,3,4,5,6]
        |    
        ptr -- k = k% arr.length --> k=1=rotate 1 times ; k = 2 = rotate 2 times ..k=7 = rotate 7 times = rotate 1 time
                for(int i = 1 ; i <=k ; i++){
                    arrayRotateLeft(arr,0, arr.length-1);
                } 
        
        Time :O(n*k)
        Space:O(1)
        */

        k = k%arr.length;
        for(int i = 1 ; i <=k ; i++){
            arrayRotateLeft(arr,0, arr.length-1);
        }

        //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR) -->REVERSE :Time :O(n), Space:O(1)
        /*
        [1,2,3,4,5,6] k =2   
        |
        ptr  -- k = k% arr.length --> k=1=rotate 1 times ; k = 2 = rotate 2 times ..k=7 = rotate 7 times = rotate 1 time
                reverse array 0 to arr.length -1               [6,5,4,3,2,1]
                reverse array 0 to arr.length -k -1            [3,4,5,6,2,1]
                reverse array arr.length -k to arr.length-1    [3,4,5,6,1,2]
        */
        k = k% arr.length;
        arrayReverse(arr, 0, arr.length-1);
        arrayReverse(arr, 0, arr.length-k-1);
        arrayReverse(arr,arr.length-k , arr.length-1);



    }
    public void    arrayReverse(int[] arr , int startIndex ,int endIndex){
        /*
        Question
        [1,2,3,4]  -- reverse array bw start and end index
                    EG:[1,2,3,4] si = 0 ; ei = arr.length -1 -->[4,3,2,1]
                    [1,2,3,4] si = 1; ei = 2              -->[1,3,2,4]

        */

        //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR)
        /*
        [1,2,3,4,5] 
        |       |
        ptr1    ptr2  -- initialise ptr1 to si , ptr2 to ei
                        while(ptr1 <= ptr2){   -->move left , right till ptr1 <= ptr2
                            swap ptr1 , ptr2     (ptr1 prr2 reach at node where ptr1=ptr ; code before moving ptr encounter till ptr1 < ptr2; code after moving ptr encounter till ptr1 == ptr2)        
        Time :O(n)   
        Space: O(1)   
        */


        int ptr1 = startIndex;
        int ptr2 = endIndex;

        while(ptr1 <= ptr2){

            int temp = arr[ptr1];
            arr[ptr1] = arr[ptr2];
            arr[ptr2] = temp;


            ptr1 ++;
            ptr2 --;
        }



        }
    public void    stackReverse(Stack<Integer> stack , int startIndex , int endIndex){
        /*
        Question
        [1,2,3,4,5] -- reverse stack bw start and end index
                    EG:[1,2,3,4,5] si = 0 ; ei = s.length -1  -->[5,4,3,2,1]
                        [1,2,3,4,5] si = 1; ei = 2             -->[5,4,3,2,1]


        */

        //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR)
        /*
        Consider startIndex = 2 ; endIndex = 3
        [1,2,3,4,5] -> [5,4,3,2,1]
                        [1,2,3,4,5] 
        [1,3,2,4,5] <- [1,2,4,3,5]
        
                    -- iterate over stack and populate array
                        reverse array 0 to arr.length-1
                        reverse array startindex to endindex
                        iterate over array and push  stack 
        Time : O(n)    
        Space: O(n)   
        */



        int[] arr = new int[stack.size()];

        int index = 0;
        while(!stack.isEmpty()){
                arr[index] = stack.pop();
                index++;
            }
    
        arrayReverse(arr, 0, arr.length-1); 
        arrayReverse(arr, startIndex, endIndex);
    
        int ptr = 0;
        while(ptr <=arr.length-1){
            stack.push(arr[ptr]);
            ptr++;
        }
    
    
            
    
            
    
    
    
            
    
    
        }
    public void    queueReverse(Queue<Integer> queue , int startIndex , int endIndex){
        /*
        Question
        [1,2,3,4,5] -- reverse queue bw start and end index
                    EG:[1,2,3,4,5] si = 0 ; ei = s.length -1  -->[5,4,3,2,1]
                        [1,2,3,4,5] si = 1; ei = 2             -->[5,4,3,2,1]
    
    
        */
    
        //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR)
        /*
        Consider startIndex = 2 ; endIndex = 3
        [1,2,3,4,5] -> [1,2,3,4,5] 
        [1,3,2,4,5] <- [1,3,2,4,5]
        
        
                    -- iterate over queue and populate array
                        reverse array startindex to endindex
                        iterate over array and add to  queue 
        Time : O(n)    
        Space: O(n)  
    */
    
    
    
        int[] arr = new int[queue.size()];
    
        int index = 0;
        while(!queue.isEmpty()){
            arr[index] = queue.remove();
            index++;
        }
    
        arrayReverse(arr, startIndex, endIndex);
        
        int ptr = 0;
        while(ptr <=arr.length-1){
            queue.add(arr[ptr]);
            ptr++;
        }
        
        
            
        
            
        
        
        
            
        
        
        }
    public void    intReverse(int a){
        /*
        -123 -->reverse the integer withouit using string
               Eg: -123 --> -321
              
        
        */

        //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR)
        /*
         look in numberIntegerConvertToReverse()
         */
    }
    public String  stringReverse(String s , int startIndex, int endIndex){
            
        /*
        Question
        "prasann"  -- reverse string bw start and end index
                    EG:"prasann" si = 0 ; ei = s.length -1  -->"nnasarp"
                        "patil"   si = 1; ei = 2             -->"parsann"


        */

        //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR)
        /*
        "prasann" -> ['p','r','a','s','a','n','n']
                    ['n','n','a','s','a','r','p']
                    |       
                    ptr-- convert string to  array 
                            reverse array startIndex to startIndex
                            convert array to string  and return string because it is immutabke
        Time : O(n)    
        Space: O(n)  
        */


        char[] arr = s.toCharArray();
        //arrayReverse(arr, startIndex, endIndex);  // arrayReverse(char[] instead of int[])
        return String.valueOf(arr);

        }
    public String  stringReverseVovels(String s){
        /*
        Question
        "leetcode"  -- reverse viwel in a string
                       EG:"leetcode" -->"leotcede"
                        "hello" --> "holle"


        */

        //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR)
        /*
        "leetcode" -> ['l','e','e','t','c','o','d','e'] 
                        |                           |
                        ptr1                      ptr2
                                                    --convert string to char array
                                                        reverse voewls in array
                                                        while(ptr1 <= ptr2)               -->move ptr1 , ptr2 till ptr1 <= ptr2
                                                            if ptr1 and ptr2 are vowels     (ptr1 prr2 reach at node where ptr1=ptr ; code before moving ptr encounter till ptr1 < ptr2; code after moving ptr encounter till ptr1 == ptr2)        
                                                                swap ptr1 ptr2
                                                                move ptr1 ahead
                                                                move ptr2 behond
                                                            else if ptr1 is vowel
                                                                move ptr2 behind
                                                            else if ptr2 is voewl 
                                                            move ptr1 ahead
                                                            else
                                                            move ptr1 behind ptr2 ahead
                                                            |
                                                            else if because ptr1 , ptr2 are used and modified  in condition
                                                        convert array to string and return string because it is immutable     
        Time : O(n)    
        Space: O(n)  
        */

        
        
        char[] arr = s.toCharArray();
        
        int ptr1 = 0 ; 
        int ptr2 = arr.length-1;
        while(ptr1 <= ptr2){
            //if(isVowel(arr[ptr1]) && isVowel(arr[ptr2])){
                char temp = arr[ptr1];
                arr[ptr1] = arr[ptr2];
                arr[ptr2] = temp;
                
                ptr1++;
                ptr2--;
            //}
            //else if(isVowel(arr[ptr1]) ){
                ptr2--;
            //}
            //else if(isVowel(arr[ptr2]) ){
                ptr1++;
            //}
            //else{
                ptr1++;
                ptr2--;
            //}   
            
        }
                    
                    
        return String.valueOf(arr);     
        
        //ISVOWEL
        /*
            public boolean isVowel(char c){
                return  (c == 'a') || (c == 'e') || (c == 'i') || (c == 'o') || (c == 'u')
                    ||(c == 'A') || (c == 'E') || (c == 'I') || (c == 'O') || (c == 'U');     
            }
            */
            
            
            
        }
    public String  stringReverseKIntervals(String s , int k){
        /*
        Question
        "abcdefg"  -- reverse k characters after k intervals ie reverse k characters for every 2k characters 
                      If less than k characters are left in array  then reverse all 
                      EG:"abcdefghij" k =2 -->"bacdfeghjik"
                         "abcdefghijklmno" k =3 -->"cbadefjihklmon"


        */

        
        //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR)
        /*
        "abcdefghij" -> ['a','b','c','d','e','f','g','h','i','j'] k = 3 
                        |        |
                        ptr1    ptr2
                                        --convert string to char array
                                        initialise ptr1 =0 ptr2 = ptr1 + k-1                  -->k = 2 reverse 0-1,4-5,8-9,12,13
                                        while(ptr1 <= arr.length-1 && ptr2 <= arr.length -1){    k=3 reverse 0-2,6-8,12-14,18-20
                                            arrayReverse(arr, ptr1, ptr2);                    
                                            ptr1 = ptr2+k+1;
                                            ptr2 =  ptr1 + k-1;
                                        }

                                        if(ptr1 <= arr.length){                              //null check ptr1 <= arr.length   to check if elements are left then reverse the remaining elements    
                                            arrayReverse(arr,ptr1,arr.length-1);}            
                                        if(ptr2 <= arr.length){                             //null check ptr2 <= arr.length is not possible
                                            //not possible}  
        Time : O(n)    
        Space: O(n)   
        
        */



        char[] arr = s.toCharArray();
        
        int ptr1 = 0;
        int ptr2 = ptr1 + k-1;        
        while(ptr1 <= arr.length-1 && ptr2 <= arr.length -1){
            //arrayReverse(arr, ptr1, ptr2);
            ptr1 = ptr2+k+1;
            ptr2 =  ptr1 + k-1;
        }
        
            

        
        if(ptr1 <= arr.length){
            //arrayReverse(arr,ptr1,arr.length-1);
        }
        if(ptr2 <= arr.length){
            //not possible
        }
        
        
        
        
        return String.valueOf(arr);
            
            
        
            
            
            
        
            
            
            
            
            
            
        }
    public String  stringReverseWordsOrder(String s , int startIndex, int endIndex){ 
        /*
        Question
        "Today is Monday"  -- reverse words order  in string
                              EG:"Today is Monday" -->"Monday is Today" 



        */

        //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR)
        /*
        "Today is Monday" -> ["Today","is","Monday"]
                            |
                            ptr-- convert string to  array of words  by removing leading trailing whitespaces splitting based on multiple whitespaces 
                                    reverse array startIndex to startIndex                       |
                                    iterate through array and append string and " " to  sb       |
                                    convert sb to string and remove the last whitespace added and return string because it is immutable       
                                                                                                |
                                                                            //trim() , split() loses the whotespace in beginning , end and middle                                   
                                                                            //if ip string does not have  whitespace in begin end and 1 whitespace in middle then we have no issue
                                                                            //if ip string has whitespace in begin end and  and multiple whitespace in middle then so question must exclusively have op string without whitespace in begin end and  only 1 whitesace in middle 
        Time : O(n)    
        Space: O(n) 
        */


        String[] arr = s.trim().split(" +"); 

        //arrayReverse(arr,0,arr.length-1); // arrayReverse(String[] instead of int[])

        StringBuilder sb = new StringBuilder("");
        for(int i =0 ; i <= arr.length-1;i++){
            sb.append(arr[i]).append(" "); 
        }
        return sb.toString().trim();


        }
    public String  stringReverseWords(String s , int startIndex, int endIndex){
            
        /*
        Question
        "Today is Monday"  -- reverse words   in string
                            EG:"Today is Monday"  --> "yadoT si yadnoM" 



        */

        //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR)
        /*
        "Today is Monday" -> ["Today","is","Monday"]
                            |
                            ptr-- convert string to  array of words  by removing leading trailing whitespaces splitting based on multiple whitespaces 
                                    iterate through array and append reverse word  and " " to  sb       |
                                    convert sb to string and remove the last whitespace added  and return string because it is immutable                               |
                                                                                                        |
                                                                            //trim() , split() loses the whotespace in beginning , end and middle                                   
                                                                            //if ip string does not have  whitespace in begin end and 1 whitespace in middle then we have no issue
                                                                            //if ip string has whitespace in begin end and  and multiple whitespace in middle then so question must exclusively have op string without whitespace in begin end and  only 1 whitesace in middle 
        Time : O(n)    
        Space: O(n) 
        */

        String[] arr = s.trim().split(" +"); 
        

        StringBuilder sb = new StringBuilder("");
        for(int i =0 ; i <= arr.length-1;i++){
            for(int j=arr[i].length()-1 ; j >=0 ;j--){
                sb.append(arr[i].charAt(j));
            }
            sb.append(" ");
        }
        return sb.toString().trim();

        


        }
    public void    arrayGroupByZero(int[] arr){
        /*
        [0,1,0,3,12] -- move all zeros on left and numbers to right and do this in place
        */

        //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR)
        /*
        [0,1,0,3,12]
         |
         ptr1 --initialise ptr1 to 0
                while(ptr <= arr.length-1){    --move ptr till arr.length(ptr1 at arr.length,cb ptr1 till arr.length-1,ca ptr1 till arr.length)
                    if(arr[ptr] == 0){              if(arr[i] == 0)
                        ptr++;                         move ptr ahead
                    else{                           else
                        arr[index++] = arr[ptr];       arr[index++] = arr[ptr]
                        ptr++;
                }    
                while(index <= arr.length-1){   --move index till arr.length(ptr1 at arr.length,cb ptr1 till arr.length-1,ca ptr1 till arr.length)
                    arr[index++] = 0;                 fll arr with 0's
                }

        Time:O(n)
        Space:O(1)


        */
        int zeroCount = 0;
        int ptr = 0;
        int index = 0;
        while(ptr <= arr.length-1){
            if(arr[ptr] == 0){
                ptr++;
            }
            else{
                arr[index++] = arr[ptr];
                ptr++;
            }
         }
        
        while(index <= arr.length-1){
            arr[index++] = 0;
        }
        
    } 
    public void    arrayGroupByEvenOdd(int[] arr){
        /*
        [3,1,2,4] -- move all even elements to left and odd to right and do this in place
                     and order doesnt matter
        Time:O(n)
        Space:O(1)
        */

        //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR)
        /*
        [3,1,2,4] 
         |     |
         ptr1  ptr2 -- initialise ptr1 and ptr2
                        while(ptr1 <= ptr1){               --move ptr1 ptr2 till pt1 < ptr2(ptr1 ptr2 at ptr1 < ptr2 ; cb moving ptr enc till ptr1 = ptr2 , ca oving ptr wn till ptr1 < ptr2)
                            if(arr[ptr1] % 2 == 0){          if arr[ptr1] == even
                                ptr1++; }                          move ptr1 ahead
                            else{                            else
                                //swap(arr,ptr1,ptr2);            swap ptr1 , ptr2
                                ptr2--;                           move ptr2 behing
                            }  
                       }

        */
        int ptr1 = 0;
        int ptr2 = arr.length-1;
        while(ptr1 <= ptr2){
            if(arr[ptr1] % 2 == 0){
                ptr1++;
            }
            else{
                //swap(arr,ptr1,ptr2);
                ptr2--;
            }
            
            
        }
        
    }
    public void    arrayGroupByNegativePositive(int[] arr){
        /*
        [3,-1,2,-4] -- move all -ve elements to left and +ve to right and do this in place
                     and order doesnt matter
        */    
         //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR)
         /*
         SAME AS arrayGroupByEvenOdd() just replace arr[ptr1] % 2 == 0 by arr[ptr1] < 0
         */
    }
    public void    arrayGroupByLessThanK(int[] arr){
        /*
        [3,1,2,4] k = 3 -- move all  elements <=k  to left and +ve to right and do this in place
                           and order doesnt matter
        */    
         //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR)
         /*
         SAME AS arrayGroupByEvenOdd() just replace arr[ptr1] % 2 == 0 by arr[ptr1] <= k
         */

    }
    public void    arrayGroupByEvenOddAlternate(int[] arr){
        /*
        [3,1,2,4] -- move all  elements such that even od are alternate starting with even
                     and order doesnt matter
                     Eg:[3,1,2,4] -- [2,1,3,4]
        */
        
        /*
        [3,1,2,4] -- bring all even elements to left and odd to right

        [2,4,1,3]  
         |     |
         ptr1  ptr2- initialise ptr1 to 0 ptr2 to arr,length-1
                     so ptr1 is at even pos(0) 
                     and ptr2 is at odd pos(arr.length = even so arr.length-1 will be odd)
                     while(ptr1 <= arr.length-1 && ptr2 >=0){   --move ptr1 till arr.length-1(ptr1 at arr.length,cb ptr1 enc till arr.length-1 , ca ptr1 enc till ar.length)
                                                                  move ptr2 till -1(ptr2 at -1, cb ptr2 enc till 0 , ca ptr2 enc till -1)
                        if(arr[ptr1]%2 == 0){                         if arr[ptr1]%2 == 0
                            ptr1 = ptr1+2;}                              means even pos has even element move ptr2 ahead by 2
                        else if(arr[ptr2]%2 != 0){                    if arr[ptr2]%2 != 0
                            ptr2 = ptr2-2;}                               means odd pos has odd element so move ptr2 behnd by 2
                        else{                                         else
                            //swap(arr,ptr1,ptr2);                         meanse neither even on even pos neither odd on odd pos so swap
                        }
                    }
        */

        arrayGroupByEvenOdd(arr);

        int ptr1 = 0;
        int ptr2 = arr.length-1;
        
        while(ptr1 <= arr.length-1 && ptr2 >=0){
            if(arr[ptr1]%2 == 0){
                ptr1 = ptr1+2;
            }
            else if(arr[ptr2]%2 != 0){
                ptr2 = ptr2-2;
            }
            
            else{
                //swap(arr,ptr1,ptr2);
            }
        }

        
        


        
        
        
    }
    public void    arrayGroupByNegativePositiveAlternate(int[] arr){
        /*
        [3,-1,2,-4] -- move all  elements such that +ve  -ve are  alternate starting with -ve
                      and order doesnt matter
                       Eg:[3,1,2,4] -- [-1,3,-2,4]
        */    
         //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR)
         /*
         SAME AS arrayGroupByEvenOddAlternate() just replace if(arr[ptr1]%2 == 0) by if(arr[ptr1] < 0)
                                                             if(arr[ptr2]%2 != 0) by if(arr[ptr1]%2 > 0)    
         */
    }
    public void    arrayGroupByLessThanKAlternate(int[] arr){
        /*
        [3,1,2,4] -- move all  elements such that ele<=k and ele>k are  alternate starting with <=k
                      and order doesnt matter
                       Eg:[3,1,2,4],k=2 -- [1,2,3,4]
        */    
         //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR)
         /*
         SAME AS arrayGroupByEvenOddAlternate() just replace if(arr[ptr1]%2 == 0) by if(arr[ptr1] <= k)
                                                             if(arr[ptr2]%2 != 0) by if(arr[ptr1]%2 > k)    
         */
    }
    public void    arrayGroupByUniqueAlternate(int[] arr) {        
        
        /*
        Question
        [1,1,2,2] -- rearrange array such that no 2 dupliates are together and if not posssible return -1
                      order doesnt matter
                     EG [1,1,2,2] -- [1,2,1,2]
                        [1,1,1,2,2] -- -1
        */
        
        //USING ARRAY MULTIPTR(ARRAY REQUIRES MULTIPTR)
        /*
        [1,1,1,2,2,2,3,4,4]-- {1:3,2:3,3:1,4:3}    -- populate hashmap with ele as key and freq as value
                                                      find the maxKey and maxValue
        
        [1,3,1,4,1,4,2,4,2]
         |
         ptr         --initialise ptr to 0          
                       
                       while (map.get(maxChar) > 0){              --get maxKey from hashmap
                            res[index] = maxChar;index =index+ 2;   while maxKey >0  
                            map.put(maxChar, map.get(maxChar)-1);      put maxKey at 0,2,4....
                            
                        }
                        
                       if (map.get(maxKey) > (int)((arr.length+1)/2)){return -1;} 
                                                                 //null check:we are going to place maxChar at even pos so check if there are enough even pos(arr.length 5 ke liye 3 pos chahiye ,arr.length 6 ke liye 3 pos chahiye )
                        
                      for (var i: map.entrySet()) {             --iterate hashmap and get all key
                        char key = i.getKey();                     while key >0
                        int val = i.getValue();                     if index exceeds arrlength swap index to 1 so that key will now be put at  be put at 1,3,5,7...
                        while (map.get(key) > 0) {                  put key at 6,8,10...
                            if (index >= res.length) index = 1;
                            res[index] = key;index += 2;
                            map.put(key, map.get(key)-1);

                        }
                    }

                        
        
                       
                       
        
        */
        Map<Integer, Integer> map = new HashMap<>();
        for(int i=0 ; i <= arr.length-1;i++){
            if(!map.containsKey(arr[i])){
                map.put(arr[i],1);
            }
            else{
                map.put(arr[i],map.get(arr[i])+1);
            }
        }
        
        int maxKey  = Integer.MIN_VALUE;
        int maxVal  = Integer.MIN_VALUE;
               
       if (map.get(maxKey) > (int)((arr.length+1)/2)    )//{return -1;}

        for(var i:map.entrySet()){
            int key = i.getKey();
            int val = i.getValue();
            if(val >=maxVal ){
                maxVal = val;
                maxKey = key;
            }
            
        }
        
        int[] res = new int[arr.length];int index=0;
        int ptr = 0;
        while (map.get(maxKey) > 0) {
            res[index] = maxKey;index =index+ 2;
            map.put(maxKey, map.get(maxKey)-1);
            
        }
        
        for (var i: map.entrySet()) {
            int key = i.getKey();
            int val = i.getValue();
            while (map.get(key) > 0) {
                if (index >= res.length) index = 1;
                
                res[index] = key;index += 2;
                map.put(key, map.get(key)-1);
                
            }
        }
    
        
        

    }
	public void    arrayGroupIn3PartsByRange(int[] arr, int a , int b){
        /*
        Question
        [7,8,11,22,1,3,11,6,7] a=5,b=12 --> group arr in 3 parts of ramge [-inf,a) [a,b] (b,inf] and all cmbination of inlusive exclusive
                                            order inside those part doesnt matter
                                            Eg[7,8,11,22,1,3,11,6,7] a=5,b=12 -->  [1,3,7,8,11,6,22]
        
        
        */

         //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR) -->DUTCHFLAG ALGO
         /*
         [7,8,11,22,1,3,11,6,7]
          |                  |
        ptr1,ptr2            ptr3  --initialise ptr1 ptr3 to 0 and arr.length; initialise ptr2 to 0 
                                    while(ptr2 <= ptr3 ){                         move ptr2 ptr3 till ptr2 > ptr3(ptr2 ptr3 at ptr2 > ptr3; cb ptr enc till ptr2 <= ptr3, ca ptr emnc till ptr2 > ptr3)
                                        if(arr[ptr2] < a){                             if ptr2 < a
                                            swap(arr,ptr1,ptr2);                           swap ptr1 ptr2 and put that element at beginning of arr
                                            ptr1++;                                        move ptr1 ahead
                                            ptr2++; }                                      move ptr2 ahead because if ptr1 moved ahead ptr2 must with or ahead of ptr1
                                        else if(arr[ptr2] > b){                        else if ptr2 >b
                                            swap(arr,ptr2,ptr3);                            swap ptr1 and ptr3 and put that element in end of arr
                                            ptr3--;                                         move ptr3 behong
                                            ptr2++ XX}                                      dont move ptr2 ahead because after swapping ptr2 and ptr3 ; element<b or element>b  can appear on ptr2(depending on what was on ptr3) ;so this element at ptr2 need to be thrown at beginning or end of arr; so dont move ptr2 so that element at ptr2 can be encountered in next  iteration
                                        else{                                          else                      
                                            ptr2++;                                        move ptr2 ahead
                                        }
                                    }
            
                                    < a  , > b -->(-inf,a) [a,b] (b,inf)  (a ke left me nahi feka, b ko right me nahi feka) 
                                    <= a , > b -->(-inf,a] (a,b] (b,inf)  (a ke left me feka, b ko right me nahi feka)
                                    < a , >= b -->(-inf,a) [a,b) [b,inf)  (a ko left me nahi feka, b ko right me feka)
                                    <=a , >= b --> (-inf,a](a,b) [b,inf]   (a ko left me frka , b ko right me feka)

         
         */
        
        int ptr1= 0;
        int ptr2 = 0;
        int ptr3 = arr.length-1;
        while(ptr2 <= ptr3 ){
            if(arr[ptr2] < a){
                //swap(arr,ptr1,ptr2);
                ptr1++;
                ptr2++;
            }
            else if(arr[ptr2] > b){
                //swap(arr,ptr2,ptr3);
                ptr3--;
            }
            else{
                ptr2++;
            }
            
            
            
        }

        
        
        
    }
    public void    arrayGroupIn3PartsBy012(int[] arr){

        /*
        Question
        [2,0,2,1,1,0] a=5,b=12 --> group arr in 3 parts such that all 0 are together all 1 are together all 2 are together
                                    order inside those part doesnt matter
                                    Eg:[2,0,2,1,1,0] -- [0,0,1,1,2,2]
        */

        //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR) -->DUTCH FLAG ALGO
        /*
        
        [2,0,2,1,1,0] --arrayGroupIn3PartsByRange(arr,1,2)
                        with cond <a , >=b as you want (-inf,1) . [1,2) ,[2,inf)

        Time:O(n)
        Space:O(1)
        */

        arrayGroupIn3PartsByRange(arr,1,2); //cond <a and >=b
        




    }
    public int     arrayGroupByEvenTogetherMinSwaps(int arr[], int k){

        /*
        Question
        [1,3,5,7,9,2,4,6,3,5,10] k=4-- move all elements such that even elements are together
                                       and order doesnt matter
                                       return min no of swaps req
                                       Eg:[1,3,5,7,9,2,4,6,3,5,10] --swap 3 and 10 so min 1 swap rea
        */

        //USING ARRAY --  MULTIPOINTERS GREEDY(DECISION AT EACH STEP)
        /*
        Look in Array multiptr - greedy
        
        */
        return 0;

        
    }
    public int     arrayGroupByNegativeTogetherMinSwaps(int arr[], int k){

        /*
        Question
        [1,3,5,7,9,-2,-4,-6,3,5,-10] k=4-- move all elements such that -ve elements are together
                                           and order doesnt matter
                                           return min no of swaps req
                                          Eg: [1,3,5,7,9,-2,-4,-6,3,5,-10] -swap 3 and -10 so min 1 swap rea
        */

        //USING ARRAY --  MULTIPOINTERS GREEDY(DECISION AT EACH STEP)
        /*
        Look in Array multiptr - greedy
        
        */
        return 0;
    }
    public int     arrayGroupByLessThanKTogetherMinSwaps(int arr[], int k){

        /*
        Question
        [9,10,11,12,1,2,3,5,4] k=4-- move all elements such that elements<=k  are together
                                      and order doesnt matter
                                     return min no of swaps req
                                     Eg: [9,10,11,12,1,2,3,5,4] -swap 5 and 4 so min 1 swap rea
        */

        //USING ARRAY --  MULTIPOINTERS GREEDY(DECISION AT EACH STEP)
        /*
        Look in Array multiptr - greedy
        
        */
        return 0;
    }
    public int     arrayGroupBy01AlternateMinSwaps(char[] arr){
        /*
        ["1","1","1","0","0","0"] -- given an array of "0" and "1"
                                     return min swaps to make it alternating "0" and "1"
                                     order doesnt matter
        */

        //USING ARRAY --  MULTIPOINTERS GREEDY(DECISION AT EACH STEP)
        /*
        Look in Array -- multiptr greedy
        }
        */
        return 0;


    }
    public int[]   arrayProductExceptSelf(int[] arr) {
        /*
        [1,2,0,4] -- find the product of all elements except itself
                     follow up: do without division
                     follow up:do without division and O(1) space
                     Eg [1,2,0,4] -- [0,0,8,0]
        */

        //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR) 
        /*
        [1,2,0,4]
         |
         ptr    --initialise ptr to 0                                                    //product =product*arr[i] taking into account "0"
                 while(ptr <= arr.length-1){                                             move ptr till arr.length(ptr at arr.length , cb ptr at arr.length-1,ca ptr till arr.length                                          
                    if(arr[ptr] == 0){                                                        if we enc 0
                        zeroCount++;                                                              increment zero count
                         if(zeroCount == 1){product = product;zeroIndex = ptr;}                   if zeroCount== 1 then product =product and note down where the zero is encountered
                        if (zeroCount >= 2){product = 0;break;} }                                 if zeroCount >=2 then product =0  and break
                    else{                                                                     else 
                        product = product*arr[ptr];}                                               product = product*arr[ptr]
                    ptr++;                                                                    move ptr ahead
                }
                                                                                        
                int[] result = new int[arr.length];                                    //arr[i] = product/arr[i] taking into account "0"    
                if (zeroCount > 0) {                                                    if zeroCount >0
                    if(zeroCount == 1){result[zeroIndex] = product;return result;}            if zeroCount== 1 then result[zeroIndex] = product and result[remainingIndex] =0 (arr is by default initialised to 0)
                    if(zeroCount >=2){ return result;} }                                      if zeroCount>=2  then result[allIndex] = 0  (arr is by default initialised to 0)
                else {                                                                   else
                    for (int i = 0; i <= arr.length-1; i++) {                                iterate arr and result[i] = (int)(product/arr[i]
                        result[i] = (int)(product/arr[i]);
                    }
                }

                return result;                                                        return result
         
        Time:O(n)
        Space:O(1)
        
        */
        /*
        int product = 1; 
        int zeroCount = 0;
        int zeroIndex = 0;
        int ptr = 0;
        while(ptr <= arr.length-1){
            if(arr[ptr] == 0){
                zeroCount++;
                if(zeroCount == 1){product = product;zeroIndex = ptr;}
                if (zeroCount >= 2){product = 0;break;} 
            }
            else{
                product = product*arr[ptr];
            }
            
            ptr++;
        }
        
        int[] result = new int[arr.length];
        if (zeroCount > 0) {
            if(zeroCount == 1){result[zeroIndex] = product;}
            if(zeroCount >=2){ return result;}
        } 
        else {
            for (int i = 0; i <= arr.length-1; i++) {
                result[i] = (int)(product/arr[i]);
            }
        }
        
        return result;
        */

        //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR) 
        /*
        [1,2,3,4]
         |
         ptr1
        [1,1,2,6]
           |       
          ptr2    --//left[] stores product of all elements on left 
                    initialise ptr1 to 0 ptr2 to 1
                    initialise left[0] to 1
                    while(ptr2 <= arr.length-1){                 
                        left[ptr2] = left[ptr2-1]*arr[ptr1];    
                        ptr1++;
                        ptr2++;}

        [24,12,4,1]  
               |         
              ptr2 --//right[] stores product of all elements on right 
                    initialise ptr1 to arr.length-1 ptr2 to arr.length-2
                    initialise right[arr.length-1] to 1
                    while(ptr2>=0){
                        right[ptr2] = right[ptr2+1]*arr[ptr1];  
                        ptr2--;
                        ptr1--;}

        [1,1,2,6]
        [24,12,4,1] 
        |
        ptr1,ptr2     //result[] = left[] * right[]
                       initialise ptr1 ,ptr2 to 0
                        while(ptr1 <= arr.length-1 && ptr2 <=arr.length-1 ){
                            result[index++] = left[ptr1]*right[ptr2];
                            ptr1++;
                            ptr2++;
                        }
        



        Time:O(n)
        Space:O(1)
        */
        /*
        int[] left = new int[arr.length];
        int[] right = new int[arr.length];
        
        int ptr1 = 0;
        int ptr2 = 1;
        left[0] = 1;
        while(ptr2 <= arr.length-1){
            left[ptr2] = left[ptr2-1]*arr[ptr1];
            ptr1++;
            ptr2++;
        }
        
        ptr1 = arr.length-1;
        ptr2 = arr.length-2;
        right[arr.length-1] = 1;
        while(ptr2>=0){
            right[ptr2] = right[ptr2+1]*arr[ptr1];
            ptr2--;
            ptr1--;
        }
        
        
        ptr1= 0;
        ptr2 = 0;
        int[] result = new int[arr.length];int index =0;
        while(ptr1 <= arr.length-1 && ptr2 <=arr.length-1 ){
            result[index++] = left[ptr1]*right[ptr2];
            ptr1++;
            ptr2++;
        }
        
        return result;
        
        */

        //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR) 
        /*
        Same as above but left[] replace by result[] and right[] replaced by rightProduct

        Time:O(n)
        Space:O(1)
        */
        /*
        int[] result = new int[arr.length];
        
        int ptr1 = 0;
        int ptr2 = 1;
        result[0] = 1;
        while(ptr2 <= arr.length-1){
            result[ptr2] = result[ptr2-1]*arr[ptr1];
            ptr1++;
            ptr2++;
        }
        
        ptr1 = arr.length-1;
        ptr2 = arr.length-2;
        int rightProduct = 1;
        while(ptr2>=0){
            
            rightProduct = rightProduct*arr[ptr1];
            result[ptr2] = result[ptr2]*rightProduct;
            ptr2--;
            ptr1--;
        }
        

        
        return result;
        */


        return null;
    }
    public String  stringcompare2StringsForAddition(String s1 , String s2){
        /*
        "11"  -- add the 2 strings and return result
        "123"
        
        */
        
        
        //USNG ARRAY --MULTPTR(ARRAY REQUIRES MULTIPTR)
        /*
          11
         121
           |
           p1,p2 -- initialise ptr1 and ptr2 to s1.length-1 and s2.length-1
                     while(ptr1 >= 0 && ptr2 >= 0){                                     --move ptr1 ptr2 to -1(ptr1 ptr2 at -1 , cb moving ptr enc till 0 , ca moving ptr enc till -1)      
                        int operand1 = Integer.parseInt("" + s1.charAt(ptr1));                calculate sum =  ptr1+ ptr2 + carry
                        int operand2 = Integer.parseInt("" + s2.charAt(ptr2));                reassign carry(calculate carry before sum  becaused sum is reassigned ) 
                        int sum = operand1 + operand2 + carry; ;                              reassign sum
                        carry = sum /10;                                                      add sum before res(because we getres in reverse direction)
                        sum = sum %10;                                                        
                        res = String.valueOf(sum) + res;                                      move pt1 behind
                                                                                              move ptr2 ahead
                        ptr1--;            
                        ptr2--;

                    }


                    if(ptr1 >= 0){                                                     //null check: for smaller s2
                        while(ptr1 >=0){                                               --move ptr1  to -1(..)
                            int operand1 = Integer.parseInt("" + s1.charAt(ptr1));         calculate sum =  ptr1 + carry
                            int sum = operand1  + carry;                                   reassign carry(calculate carry before sum  becaused sum is reassigned )
                             carry = sum /10;                                              reassign sum
                            sum = sum %10;                                                 add sum before res(because we get res in reverse direction)
                            res = String.valueOf(sum) + res;
                                                                                              
                            ptr1--;                                                        move ptr1 behind
                        }
                    }

                     else if(ptr2 >= 0){                                               //null check: for smaller s1
                        while(ptr2 >=0){                                               --move ptr2  to -1(..)
                            int operand1 = Integer.parseInt("" + s1.charAt(ptr2));         calculate sum =  ptr2 + carry
                            int sum = operand1  + carry;                                   reassign carry(calculate carry before sum  becaused sum is reassigned )
                             carry = sum /10;                                              reassign sum
                            sum = sum %10;                                                 add sum before res(because we get res in reverse direction)
                            res = String.valueOf(sum) + res;
                                                                                              
                            ptr2--;                                                        move ptr2 behind
                        }
                    }


      

                    if(carry != 0){                                                   //TAKE INTO ACCOUNT THE CARRY LEFT AFTER LAST ADDITIONM
                        res = String.valueOf(carry) + res ;                             add carry before res(because we get res in reverse direction)
                    }


        return res;
        
        
        Time:O(n1+n2)
        Space:O(1)
            
         
        
        */
        
        String res = "";
        
        int ptr1 = s1.length()-1;
        int ptr2 =s2.length() -1;
        int carry = 0;
        
   
        while(ptr1 >= 0 && ptr2 >= 0){
            int operand1 = Integer.parseInt("" + s1.charAt(ptr1));
            int operand2 = Integer.parseInt("" + s2.charAt(ptr2));
            int sum = operand1 + operand2 + carry;
            carry = sum /10;
            sum = sum %10;
            
            
            res = String.valueOf(sum) + res;
            
            
            ptr1--;
            ptr2--;
            
        }
        
     
        if(ptr1 >= 0){
            while(ptr1 >=0){
                int operand1 = Integer.parseInt("" + s1.charAt(ptr1));
                int sum = operand1  + carry;
                 carry = sum /10;
                sum = sum %10; 
                res = String.valueOf(sum) + res;
               
                
                ptr1--;
            
            }
            
        }
        
 
        else if(ptr2 >=0){
            while(ptr2 >=0){
                int operand1 = Integer.parseInt("" + s2.charAt(ptr2));
                int sum = operand1  + carry;
                 carry = sum /10;
                sum = sum %10;
               
                res = String.valueOf(sum) + res;
                
                ptr2--;
            }
            
        }
        
        if(carry != 0){
            res = String.valueOf(carry) + res ;
        }
        
        
        return res;
        
        
        
        
        
        
    }
    public int[]   arrayCompare2ArrayForPlusOneAddition(int[] arr){
        /*
         [1,2,3] -- a large number is representated in arr 
                    add 1 to the number and return result arr
                    an res arr should not have leading 0's
        
        */
        
        //USING ARRAY MULTIPTR(ARRAY REQUIRES MULTIPTR)
       /*
       [1,2,3]
          |
          ptr --initialise ptr to arr.length-1
                initialise res of 1 greater length
                while(ptr >= 0){                                      --mov ptr till 0                        
                    sum = arr[ptr]  + carry;                              sum =  arr[ptr] + carry + 1(only 1st time)
                    if(ptr == arr.length-1){sum = sum + 1;}                carry = sum/10; (initialise carry 1st because sum is being reset)
                    carry = sum/10;                                        sum = sum%10;
                    sum = sum%10;

                    res[ptr+1] = sum;                                      put sum in res[ptr-1] because res is  1 greater length 

                    ptr--;                                                 move ptr behind
                }

                res[0] = carry;                                        initialise res[0] to the carry left
                if(res[0] == 0){                                       if res[0] == 0 means there is no carry 
                    return Arrays.copyOfRange(res,1,res.length);           return res from 1 onwards
                else                                                   else
                    return res;                                            return enrire res
                
        Time:O(n)
        Space:O(n)
       */
        int[] res= new int[arr.length+1];
        
        int sum = 0;
        int carry = 0;
        int ptr = arr.length-1;
        while(ptr >= 0){
            sum = arr[ptr]  + carry;
            if(ptr == arr.length-1){sum = sum + 1;}
            carry = sum/10; ///pehle carry niklega kyuki sum modify horaha hai
            sum = sum%10;

            res[ptr+1] = sum;   
            
            ptr--;
        }
        
        res[0] = carry;        
        if(res[0] == 0){
            return Arrays.copyOfRange(res,1,res.length);
        }
        else{
            return res;
        }
        
    }
    public boolean stringCompare2StringsForRotation(String s1 , String s2){

        /*
        s1 = "abc"  -- compare s1 and s2
        s2 = "bca"     amd find whether s2 is a right/left rotation of s1( Rotate right -- Move array to right ;the displaced element at last pos place at first index  Eg: 1 2 3 4 5 -- 5 1 2 3 4 -- 4 5 1 2 3  
                                                                            Rotate left  -- Move array to left ; the displaced element at first pos place  at last index Eg: 1 2 3 4 5 -- 2 3 4 5 1 -- 3 4 5 1   )
        */
        
        //USING MULTIPOINTERS (ARRAY REQUIRES MULTIPLE PTR)-->Time: O(n^2) , Space:O(n)
        /*
        ['a','b,'c']
        ['b','c','a']     -- convert to array
                             rotate arr2 right/left(as asked in question) arr2.length times
                                 if(Arrays.equals(arr1,arr2))
                                    return true
        
        TME   :O(n^2)
        SPACE:O(n)                     
        
        */

        char[] arr1 = s1.toCharArray();
        char[] arr2 = s2.toCharArray();
        
        
        for(int i= 1; i <= arr1.length; i++){
            //arrayRotateLeft(arr1,0,arr1.length-1);  make the fn take char[] instead of int[]
            
            if(Arrays.equals(arr1,arr2)){
                return true;
            }
        }
        
        
        return false;

        
        //USING MATHS (ARRAY ELEMENTS HAVE PATTERN)  -->TIME: O(1) , SPACE:O(1)
        /*
        LOOK IN MATHS
        */

        
        

    }
    public void    stringCompareNStringsForReplacement(List<String> words,String sentence){
        /*
        words = ["cat","bat","rat"]                         - replace every word in sentece with root and 
        sentence = "the cattle was rattled by the battery    if word can be replaced by more than one root,
        Output: "the cat was rat by the bat"                 replace with shortest root.
                                                            EG :https://leetcode.com/problems/replace-words/
        */ 
    
        //USING TRIE
        /*
        Look in TrieSum
        */

    }
    public void    StringCompareNStringForAutoComplete(List<Integer> words, String searchWord){
        /*
        words:["card","carry","carma","cmd"] -->Given words
        searchWord:"car"                        Check the words which are autocomplete of searchWord
        */

        //USING TRIE
        /*
        Look in TrieSums
        */
    }
    public void    stringCompareNStringsForLongestCommonPrefix(List<Integer> words){
        /*
        words ["flower","flow","flight"] -- given list of words find the longest common prefix
                                            Eg words ["flower","flow","flight"] 
                                               longest common prefix = "fl"
        
        */

        //USING MULTIPTR
        /*
        public String stringCompareNStringForLongestCommonPrefix(List<String> words){
            
            if(words.size() == 0){return ""}                //null check
            if(words.size() == 1){return words.get(0);}      null ehcek for words of size 0 and 1
            
            int ptr1 = 0;                                 --find longest common prefix of first 2 strings and store in res
            int ptr2 = 1;
            String res = stringCompare2StringForLongestCommonPrefix(words.get(ptr1),words.get(ptr2));
            
            ptr1++;                                        --find longest common prefix ofres and remaining strings and store in res
            ptr2++;
            while(ptr2 <= words.size()-1){
                res = stringCompare2StringForLongestCommonPrefix(res,words.get(ptr2));
                ptr2++;
            }
            return res;                                    --return res 
        }

        public String stringCompare2StringForLongestCommonPrefix(String s1, String s2){
            int ptr1 = 0;
            int ptr2 = 0;
            
            while(ptr1 <= s1.length()-1 && ptr2 <= s2.length()-1 && s1.charAt(ptr1) == s2.charAt(ptr2)){
                ptr1++;                                    --iterate through strings until characters are same
                ptr2++;
            }
            
            
            String res = s1.substring(0,ptr1);            --return string from 0 to ptr1 exclusive
            return res;
        }


        Time:O(n) -->n = total number of characters in word
                     ypu iterate through all characters in word
        Space:O(1)

        
        
        
        */

    }
    public void    stringCompareNStringsForLongestCommonPrefixWithWord(List<Integer> words, int word){
        /*
        words ["flower","flow","flown"] -- given list of words find the longest common prefix of all given word with the given words
        word = "flom"                      Eg: ["flower","flow","flown"] word =  "flom"  
                                               longest common prefix with word= "flo"
        
        */

        //USING TRIE
        /*
        Look In Trie Sums

        
        
        
        */

    }




    //ARRAY --  MULTIPOINTERS SORT+SEARCH
    /*
    IDENTIFY
    ARRAY REQUIRES  SORTING OR ARRAY IS  ALREADY SORTED(ALREADY SORTED TO SORTING KA NLOGN BACH JAYEGA)
    */
    public int[]   arrayElementsAppearingMoreThanNbyKTimes(int[] arr,int n,int k){
        /*
        Question
        [3,2,3]  n = 3 , k = 3 -- find all the elements that appear more than n/k times
        
        */
        
        //USING MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)  --> Time : O(n logn) ;Space: O(1)
        /*
        SORT
        [3,2,3]  -- Arrays.sort(arr);

        SEARCH
        [2,3,3]
         |
         p1,p2   -- initialise ptr1,ptr2 to 0
                    while(ptr1 <= arr.length-1){                                   --move ptr1 till arr1.length(ptr1 att arr.length , cb ptr1 till arr.length-1 , a ptr1 till arr.length) 
                        while(ptr2 <= arr.length-1 && arr[ptr1] == arr[ptr2]){           move ptr2 till ptr1 != ptr2 (ptr2 at ptr1 != ptr2 , cb moving ptr enc till ptr1 == ptr2 , ca moving ptr enc till ptr1 != ptr2)
                            ptr2++; }                                                         move ptr1 ahead
                        int count = ptr2 - ptr1;                                         count = ptr2 - ptr2                                     
                        if(count >(int)(n/k)){result[index++] = arr[ptr1];}              if(count > (int)n/k){put ptr1 in result}
                        ptr1 = ptr2;                                                     reassign ptr1 to ptr2
                        
                    }
                     
                    return Arrays.copyOfRange(result,0,index);
        Time:O(n logn)
        Space:O(1)
                    
        */
        Arrays.sort(arr);
        
        int ptr1 = 0;
        int ptr2 = 0;
        int[] result = new int[arr.length];int index =0;
        while(ptr1 <= arr.length-1){
            while(ptr2 <= arr.length-1 && arr[ptr1] == arr[ptr2]){
                ptr2++;
            }
            int count = ptr2 - ptr1;
            if(count >(int)(n/k)){
                result[index++] = arr[ptr1];
            }
            
            ptr1 = ptr2;
            
        }
        
        return Arrays.copyOfRange(result,0,index);

        //USING HASHMAP    -->Time:O(n),space:O(n)
        /*
        LOOK IN HASHMAPS
        */

        
        
        
      
        
        
    }
    public void    arraypair2TargetSumI(int[] arr, int target) {
        /*
        [1,2,5,3] target = 7 --> given an arr find pairs of 2 whose sum is target
                                  return pairs,pairs ke index , pairs ke count
        */
        
        //USING MULTIPTR SORT + SEARCH(ARRAY REQUIRES SORTING)-->Time:O(nlogn + n),space:O(n)
        //                                                        Array duplicate     :Array cannot have duplicate for non unique pairs, array can have duplicate for unique pairs
        //                                                        Pair of value,index :Pair of value can be found, pair of index cant be found  
        /*

        //PAIRS
        SORT AR
        [1,2,5,3] -- [1,2,3,5]

        SEARH
        [1,2,3,5]
         |     |
         ptr1  ptr2 -- initialise ptr1 ptr2 to 0 
                       while(ptr1 <= ptr2){                                 -move ptr1 ptr2 till ptr1 <= ptr2(..)
                            if(arr[ptr1] + arr[ptr2] == target){              if ptr1 + ptr2 == target
                                if(ptr1 != ptr2){                                ptr1 != ptr2 
                                    pairOFValue.add(new int[]{arr[p1],arr[p2]})  pairOFValue ko add ptr1 ptr2 
                                    pairOfIndex.add(new int[]{-1,-1)             pairofIndex ko add -1,-1 
                                    noOfPairs++;}                                noOfPaits++
                                                                                 [PAIR OF INDEX CANT BE FOUND AS YOU SORT ARRAY]
                                ptr1++ OR ptr2--;                                move ptr1 ahead OR ptr2 behind if there are no duplicates 
                            }                                                    [ARRAY CANNOT HAVE DUPLICATES AS MOVING PTR1 PTR2 BECOMES INDECISIVE: EG [1,2(p1),2,5,5(p2)] target = 7
                            else if(arr[ptr1] + arr[ptr2] < target){          else if  ptr1 + ptr2 < target                                                                            
                                ptr1++;                                            move ptr1 ahead
                            }
                            else if(arr[ptr1] + arr[ptr2] > target){          else if ptr1 + ptr2 > target   
                                ptr2--;                                            move ptr2 behind
                            }
                            
                        }
                    
        return noOfPairs;

        //UNIQUE PAIRS
        ptr1++ OR ptr2 

        KE BADLE

        ptr1++;                                                      move ptr1 ahead
        ptr2--;                                                      move ptr2 behind
        while (ptr1 < ptr2 && arr[ptr1] == arr[ptr1 - 1])            move ptr1 head to skip duplicates
            ptr1++;                                                  move ptr2 behnd to skip dupliates
        while(ptr1 < ptr2 && arr[ptr2] == arr[ptr2 + 1])             [ARRAY CAN HAVE DUPLICATES AS WE SKIP DUPLICATES TO FIND UNIQUE]
            ptr2--; 
        }
        



        */
        
        /*
        //PAIRS
        Arrays.sort(arr);
        int ptr1 = 0;
        int ptr2 = arr.length-1;
        ArrayList<int[]> pairOFValue = new ArrayList<>();
        ArrayList<int[]> pairOFIndex = new ArrayList<>();
        int noOfPairs = 0;
        while(ptr1 <= ptr2){
            if(arr[ptr1] + arr[ptr2] == target){
                if(ptr1 != ptr2){
                    pairOFValue.add(new int[]{arr[ptr1],arr[ptr2]});
                    pairOFIndex.add(new int[]{-1,-1);
                    noOfPairs++;
                }     
                ptr2--; 
            }
            else if(arr[ptr1] + arr[ptr2] < target){
                ptr1++;
            }
            else if(arr[ptr1] + arr[ptr2] > target){
                ptr2--;
            }
            
        }
        return noOfPairs;

        //UNIQUE PAIRS
        Arrays.sort(arr);
        int ptr1 = 0;
        int ptr2 = arr.length-1;
        ArrayList<int[]> pairOFValue = new ArrayList<>();
        ArrayList<int[]> pairOFIndex = new ArrayList<>();
        int noOfPairs = 0;
        while(ptr1 <= ptr2){
            if(arr[ptr1] + arr[ptr2] == target){
                if(ptr1 != ptr2){
                    pairOFValue.add(new int[]{arr[ptr1],arr[ptr2]});
                    pairOFIndex.add(new int[]{-1,-1);
                    noOfPairs++;
                }     
                ptr1++;
                ptr2--;
                while (ptr1 < ptr2 && arr[ptr1] == arr[ptr1 - 1])
                    ptr1++;                                     
                while(ptr1 < ptr2 && arr[ptr2] == arr[ptr2 + 1])
                    ptr2--; 
            }
            else if(arr[ptr1] + arr[ptr2] < target){
                ptr1++;
            }
            else if(arr[ptr1] + arr[ptr2] > target){
                ptr2--;
            }
            
        }

        */

        //USING HASHSETS(ARRAY REQUIES STORING OF ELEMENTS ) -->Time:O(n),space:O(n)
        //                                                       Array duplicate:array can have duplicates  
        //                                                       Pair of value,index :Pair of value can be found, pair of index can be found  
        /*
        look in hashmaps
        */



    }
    public void    arraypair2TargetSumII(int[] arr, int target) {
        /*
        [1,2,5,3] target = 7 --> given an arr find pairs of 2 whose sum is less than target
                                  return pairs,pairs ke index , pairs ke count

        */

        //USING MULTIPTR SORT + SEARCH(ARRAY REQUIRES SORTING)-->Time:O(nlogn + n),space:O(n)
        //                                                        Array duplicate     :Array can have duplicate for non unique pairs, array can have duplicate for unique pairs
        //                                                        Pair of value,index :Pair of value can be found, pair of index cant be found  
        /*
        //PAIRS
        SORT AR
        [1,2,5,3] -- [1,2,3,5]

        SEARH
        [1,2,3,5]
         |     |
         ptr1  ptr2 -- initialise ptr1 ptr2 to 0 
                       while(ptr1 <= ptr2){                             --move ptr1 ptr2 till ptr1 <= ptr2(..)
                            if(arr[ptr1] + arr[ptr2] == target){               if ptr1 + ptr2 == target
                                ptr2--                                            move ptr2 behind as we need to reduce sum to reach targer                                                
                                                                                  [ARRAY CAN HAVE DUPLICATES AS WE JUST MOVE PTR2 BEHIND]

                            else if(arr[ptr1] + arr[ptr2] < target){          else if  ptr1 + ptr2 < target                                                                           
                                if(ptr1 != ptr2){                                  ptr1 != ptr2    
                                   pairOFValue.add(new int[]{ptr1,ptr2 to ptr1+1}) pairOFValue ko add [ptr1 ptr2], [ptr1,ptr2-1]..[ptr1,ptr1+1] 
                                   pairOfIndex.add(new int[]{-1,-1})               pairofIndex ko add -1 -1
                                   noOfPairs = noOfPairs + (ptr2-ptr1);}           noOfPaits ko add noOfPairs + (ptr2-ptr1)
                                                                                   [PAIR OF INDEX CANT BE FOUND AS YOU SORT ARRAY]
                                ptr1++;                                            move ptr1 ahead
                            }
                            else if(arr[ptr1] + arr[ptr2] > target){          else if ptr1 + ptr2 > target   
                                ptr2--;                                            move ptr2 behind
                            }
                        }
                    
        return noOfPairs;

        //UNIQUE PAIRS
        ptr2--

        KE BADLE

        ptr1++;                                                      move ptr1 ahead
        ptr2--;                                                      move ptr2 behind
        while (ptr1 < ptr2 && arr[ptr1] == arr[ptr1 - 1])            move ptr1 head to skip duplicates
            ptr1++;                                                  move ptr2 behnd to skip dupliates
        while(ptr1 < ptr2 && arr[ptr2] == arr[ptr2 + 1])             [ARRAY CAN HAVE DUPLICATES AS WE SKIP DUPLICATES TO FIND UNIQUE]
            ptr2--; 
        }
        





        */
        /*
        //PAIRS
        Arrays.sort(arr);
        int ptr1 = 0;
        int ptr2 = arr.length-1;
        ArrayList<int[]> pairOFValue = new ArrayList<>();
        ArrayList<int[]> pairOFIndex = new ArrayList<>();
        int noOfPairs = 0;
        while(ptr1 <= ptr2){
            if(arr[ptr1] + arr[ptr2] == target){ 
                ptr2--; 
            }
            else if(arr[ptr1] + arr[ptr2] < target){
                if(ptr1 != ptr2){
                    for(int p = ptr2;p>=ptr1+1;p--){pairOFValue.add(new int[]{arr[ptr1],arr[ptr2]})
                    pairOFIndex.add(new int[]{-1,-1});
                    noOfPairs = noOfPairs + (ptr2-ptr1);
                }    
                ptr1++;
            }
            else if(arr[ptr1] + arr[ptr2] > target){
                ptr2--;
            }
            
        }
        
        return noOfPairs;

        //UNIQUE PAIRS
        Arrays.sort(arr);
        int ptr1 = 0;
        int ptr2 = arr.length-1;
        ArrayList<int[]> pairOFValue = new ArrayList<>();
        ArrayList<int[]> pairOFIndex = new ArrayList<>();
        int noOfPairs = 0;
        while(ptr1 <= ptr2){
            if(arr[ptr1] + arr[ptr2] == target){ 
                ptr1++;
                ptr2--;
                while (ptr1 < ptr2 && arr[ptr1] == arr[ptr1 - 1])            
                    ptr1++;                                                  
                while(ptr1 < ptr2 && arr[ptr2] == arr[ptr2 + 1])            
                    ptr2--; 
            }

            else if(arr[ptr1] + arr[ptr2] < target){
                if(ptr1 != ptr2){
                    for(int c = ptr2; c >= ptr1+1; c--){pairOFValue.add(new int[]{ptr1,c});}
                    pairOFIndex.add(new int[]{-1,-1});
                    noOfPairs = noOfPairs + (ptr2-ptr1);
                }    
                ptr1++;
            }
            else if(arr[ptr1] + arr[ptr2] > target){
                ptr2--;
            }
            
        }
        
        */


        //USING HASHMAP(ARRAY REQUIRES STORING) -->Time:O(n),space:O(n)
        //                                         Array duplicate     :Array can have duplicate 
        //                                         Pair of value,index :Pair of value can be found, pair of index can be found  
        /*
        look in hashmaps
        */



    }
    public void    arraypair3TargetSumI(int[] arr, int target) {
        /*
        [1,2,5,3] target = 6 --> given an arr find pairs of 3 whose sum is target
                                  return pairs,pairs ke index , pairs ke count

        */
        
        //USING MULTIPTR SORT + SEARCH(ARRAY REQUIRES SORTING)-->Time:O(nlogn + n^2),space:O(n)
        //                                                        Array duplicate     :Array cannot have duplicate for non unique pairs, array can have duplicate for unique pairs
        //                                                        Pair of value,index :Pair of value can be found, pair of index cant be found  
        /*
        //PAIRS
        SORT ARR
        [1,2,5,3] -- [1,2,3,5]

        SEARH
        [1,2,3,5]
         |  |   |
      ptr1  ptr2 ptr3 -- while ptr1 <= arr.length-3
                           arraypair2TargetSumI for ptr1+1 to arr.length-1
         
         
        //UNIQUE PAIRS
        [1,2,3,5]
         |  |   |
      ptr1  ptr2 ptr3 -- while ptr1 <= arr.length-3
                            if (ptr1 == 0 || arr[ptr1] != arr[ptr1 - 1] ) {
                                arraypair2TargetSumI unique for ptr1+1 to arr.length-1





        */
        /*
        //PAIRS
        Arrays.sort(arr);
        ArrayList<int[]> pairOFValue = new ArrayList<>();
        ArrayList<int[]> pairOFIndex = new ArrayList<>();
        int noOfPairs = 0;
        int ptr1 = 0;
        while(ptr1 <= arr.length-3){
            int ptr2 = ptr1+1;
            int ptr3 = arr.length-1;
            while(ptr2 <= ptr3){
                if(arr[ptr1] + arr[ptr2] + arr[ptr3]== target){
                    if(ptr2 != ptr3){
                        pairOFValue.add(new int[]{ptr1,ptr2,ptr3});
                        pairOFIndex.add(null);
                        noOfPairs++;
                    }     
                    ptr3--; 
                }
                else if(arr[ptr1] + arr[ptr2] + arr[ptr3]< target){
                    ptr2++;
                }
                else if(arr[ptr1] + arr[ptr2] + arr[ptr3]> target){
                    ptr3--;
                }
                
            }
            

            ptr1++;
        }

        return noOfPairs;

        //UNIQUE PAIRS
        Arrays.sort(arr);
        ArrayList<int[]> pairOFValue = new ArrayList<>();
        ArrayList<int[]> pairOFIndex = new ArrayList<>();
        int noOfPairs = 0;
        int ptr1 = 0;
        while(ptr1 <= arr.length-3){
            if (ptr1 == 0 || arr[ptr1] != arr[ptr1 - 1] ) {
                int ptr2 = ptr1+1;
                int ptr3 = arr.length-1;
                while(ptr2 <= ptr3){
                    if(arr[ptr1] + arr[ptr2] + arr[ptr3]== target){
                        if(ptr2 != ptr3){
                            pairOFValue.add(new int[]{ptr1,ptr2,ptr3});
                            pairOFIndex.add(null);
                            noOfPairs++;
                        }     
                        ptr2++;
                        ptr3--;
                        while(ptr2 < ptr3 && arr[ptr2] == arr[ptr2-1]){
                            ptr2++;
                        } 
                        while(ptr2 < ptr3 && arr[ptr3] == arr[ptr3+1]){
                            ptr3--;
                        } 
                    }
                    else if(arr[ptr1] + arr[ptr2] + arr[ptr3]< target){
                        ptr2++;
                    }
                    else if(arr[ptr1] + arr[ptr2] + arr[ptr3]> target){
                        ptr3--;
                    }
                    
                }
            }
            ptr1++;
        }

        return noOfPairs;

        */

        //USING HASHSETS(ARRAY REQUIES STORING OF ELEMENTS ) -->Time:O(n^2),space:O(n)
        //                                                     Array duplicate     :Array can have duplicate
        //                                                     Pair of value,index :Pair of value can be found, pair of index can be found  
        /*
        look in hashmaps
        */



    }
    public void    arraypair3TargetSumII(int[] arr, int target) {
        /*
        [1,2,5,3] target = 6 --> given an arr find pairs of 3 whose sum is less than  target
                                  return pairs,pairs ke index , pairs ke count

                                        

        */
        
        //USING MULTIPTR SORT + SEARCH(ARRAY REQUIRES SORTING)-->Time:O(nlogn + n^2),space:O(n)
        //                                                        Array duplicate     :Array can have duplicate for non unique pairs, array can have duplicate for unique pairs
        //                                                        Pair of value,index :Pair of value can be found, pair of index cant be found  
        /*
        //PAIRS
        SORT ARR
        [1,2,5,3] -- [1,2,3,5]

        SEARH
        [1,2,3,5]
         |  |   |
      ptr1  ptr2 ptr3 -- while ptr1 <= arr.length-3
                           arraypair2TargetSumII for ptr1+1 to arr.length-1
         
         
        //UNIQUE PAIRS
        [1,2,3,5]
         |  |   |
      ptr1  ptr2 ptr3 -- while ptr1 <= arr.length-3
                            if (ptr1 == 0 || arr[ptr1] != arr[ptr1 - 1] ) {
                                arraypair2TargetSumII unique for ptr1+1 to arr.length-1





        */
        /*
        //PAIRS
        Arrays.sort(arr);
        ArrayList<int[]> pairOFValue = new ArrayList<>();
        ArrayList<int[]> pairOFIndex = new ArrayList<>();
        int noOfPairs = 0;
        int ptr1 = 0;
        while(ptr1 <= arr.length-3){
            int ptr2 = ptr1+1;
            int ptr3 = arr.length-1;
            while(ptr2 <= ptr3){
                if(arr[ptr1] + arr[ptr2] + arr[ptr3]== target){  
                    ptr3--; 
                }
                else if(arr[ptr1] + arr[ptr2] + arr[ptr3]< target){
                    if(ptr2 != ptr3){
                        for(int p = ptr3;p>=ptr2+1;p--){pairOFValue.add(new int[]{arr[ptr2],arr[ptr3]}
                        pairOFIndex.add(null);
                        noOfPairs = noOfPairs + (ptr3-ptr2);
                    }   
                    ptr2++;
                }
                else if(arr[ptr1] + arr[ptr2] + arr[ptr3]> target){
                    ptr3--;
                }
                
            }
            

            ptr1++;
        }

        return noOfPairs;

        //UNIQUE PAIRS
        Arrays.sort(arr);
        ArrayList<int[]> pairOFValue = new ArrayList<>();
        ArrayList<int[]> pairOFIndex = new ArrayList<>();
        int noOfPairs = 0;
        int ptr1 = 0;
        while(ptr1 <= arr.length-3){
            if (ptr1 == 0 || arr[ptr1] != arr[ptr1 - 1] ) {
                int ptr2 = ptr1+1;
                int ptr3 = arr.length-1;

                while(ptr2 <= ptr3){
                    if(arr[ptr1] + arr[ptr2] + arr[ptr3] == target){ 
                        ptr2++;
                        ptr3--;
                        while (ptr2 < ptr3 && arr[ptr2] == arr[ptr2 - 1])            
                            ptr1++;                                                  
                        while(ptr2 < ptr3 && arr[ptr3] == arr[ptr3 + 1])            
                            ptr2--; 
                    }

                    else if(arr[ptr2] + arr[ptr3] < target){
                        if(ptr2 != ptr3){
                            for(int c = ptr3; c >= ptr2+1; c--){pairOFValue.add(new int[]{ptr2,c});}
                            pairOFIndex.add(new int[]{-1,-1});
                            noOfPairs = noOfPairs + (ptr3-ptr2);
                        }    
                        ptr2++;
                    }
                    else if(arr[ptr1] + arr[ptr2] > target){
                        ptr3--;
                    }
                    
                }
            ptr1++;
        }

        return noOfPairs;

        */

    
        //USING HASHMAP(ARRAY REQUIES STORING OF ELEMENTS ) -->Time:O(n^2),space:O(n)
        //                                                     Array duplicate     :Array can have duplicate 
        //                                                     Pair of value,index :Pair of value can be found, pair of index can be found
        /*
        look in hashmaps
        */



    }
    public void    arrayPairKTargetSumI(int[] arr, int target, int start, int k) {
        /*
        [1,2,5,3] target = 7 --> given an arr find pairs of k integeres whose sum is target
                                  return pairs,pairs ke index , pairs ke count
                                        

        */
        
        //USING MULTIPTR SORT + SEARCH(ARRAY REQUIRES SORTING) -->Time:O(n^k) Spaxe:O(1)
        //                                                        Array duplicate     :Array cannot have duplicate for non unique pairs, array can have duplicate for unique pairs
        //                                                        Pair of value,index :Pair of value can be found, pair of index cant be found  
        /*
        //PAIRS

        List<List<Integer>> pairOfValue = new ArrayList<>();

        //BASE CASE
        int average_value = target / k;                                                                
        if (start == arr.length) {return pairOfValue;}                                                 --start == arr.length means recursion must terminate  by retuening pair of values
        if  (arr[start] > average_value || average_value > arr[arr.length - 1]) {return pairOfValue;}  --start > avg_val or avg_val> arr.length-1 means recursion must terminate  by retuening pair of values
        if (k == 2) {return arrayPair2TargetSumI(arr, target, start);}                                  --k==2  means recursion must terminate  by returning List<List<Integer>> for two sum
                                                                                                               arrayPair2TargetSum(arr, target, start){
                                                                                                                   //Arrays.sort(arr)  --do not sort arr as you sort arr in overriding fn
                                                                                                                   ptr = start       --initiaiise ptr to start
                                                                                                                                                                                                                        }
        //RECURSION
        for (int ptr = start; ptr <= arr.length-1; ptr++) {                                          --move ptr from 0 to arr.length-1
            List<List<Integer>> pairs = arrayPairKTargetSum(arr, target - arr[ptr], ptr + 1, k - 1);   fn will return pairs  for ptr+1 to end, k-1 size and target = target-arr[i] 
            for (List<Integer> pair : pairs) {                                                          add arr[ptr] with the pairs returned by fn 
                List<Integer> temp = new ArrayList<>();
                temp.add(arr[ptr]);
                for(var p:pair){temp.add(p);}                  
                pairOfValue.add(temp);

            }    
        }
    
        return pairOfValue;
        


        //UNIQUE
        for (int ptr = start; ptr <= arr.length-1; ptr++) {
            if (ptr == start || arr[ptr - 1] != arr[ptr]) {  
        
        */
        /*
        public List<List<Integer>>    arrayPairKTargetSumI(int[] arr, int target, int start, int k)
            //PAIRS
            List<List<Integer>> pairOfValue = new ArrayList<>();

            int average_value = target / k;
            if (start == arr.length) {return pairOfValue;}
            if  (arr[start] > average_value || average_value > arr[arr.length - 1]) {return pairOfValue;}
            if (k == 2) {return arrayPair2TargetSum(arr, target, start);}
        
            
            for (int i = start; i <= arr.length-1; i++) {    
                List<List<Integer>> pairs = arrayPairKTargetSum(arr, target - arr[i], i + 1, k - 1);
                for (List<Integer> pair : arrayPairKTargetSum(arr, target - arr[i], i + 1, k - 1)) {
                    List<Integer> temp = new ArrayList<>();
                    temp.add(arr[i]);
                    for(var p:pair){temp.add(p);}                  
                    pairOfValue.add(temp);
                }    
            }
            return pairOfValue;

            //UNIQUE
            List<List<Integer>> pairOfValue = new ArrayList<>();
            int average_value = target / k;
            if (start == arr.length) {return pairOfValue;}
            if  (arr[start] > average_value || average_value > arr[arr.length - 1]) {return pairOfValue;}
            if (k == 2) {return arrayPair2TargetSum(arr, target, start);}    
            for (int i = start; i <= arr.length-1; i++) {
                if (i == start || arr[i - 1] != arr[i]) {  
                    List<List<Integer>> pairs = arrayPairKTargetSum(arr, target - arr[i], i + 1, k - 1);
                    for (List<Integer> pair : arrayPairKTargetSum(arr, target - arr[i], i + 1, k - 1)) {
                        List<Integer> temp = new ArrayList<>();
                        temp.add(arr[i]);
                        for(var p:pair){temp.add(p);}                  
                        pairOfValue.add(temp);
                    }
                }
            }
            return pairOfValue;
        }

        public List<List<Integer>>    arrayPairKTargetSumI(int[] arr, int target,int k){
            return arrayPairKTargetSumI(arr,target,0,k);
        }



        */
    
           
        //USING HASHMAPS                                       -->Time:O(n^k) Spaxe:O(n)
        //                                                       Array duplicate:array can have duplicates4   
        //                                                       Pair of value,index :Pair of value can be found, pair of index can be found  
        /*
        Look in hashmaps
        */
   
    }
    public void    arraypair2TargetDifferenceI(int[] arr, int target) {
        /*
        [1,2,5,3] target = 7 --> given an arr find pairs of 2 whose  abs diff is target(abs diff beause pair can be taken in both dirs ie if pair is (a,b) then if a-b == target or b-a is target )
                                 return pairs,pairs ke index , pairs ke count
                                 
                                        
                                
        */
        
        //USING MULTIPTR SORT + SEARCH(ARRAY REQUIRES SORTING)-->Time:O(nlogn + n),space:O(n)
        //                                                        Array duplicate     :Array cannot have duplicate for non unique pairs, array can have duplicate for unique pairs
        //                                                        Pair of value,index :Pair of value can be found, pair of index cant be found  
        /*
        //PAIR
        SORT ARR
        [3,1,4,5] -- [1,3,4,5]
        
        SEARCH ARRAY
        [1,2,3,4]
         | |
         p1 p2    -- initialise ptr1 to 0 and ptr2 to 1
                    while (ptr1 <=arr.length-1 && ptr2 <= arr.length-1) {              --move ptr1 ptr2 to arr.length-1
                        if(ptr1 == ptr2){                                                if ptr overlap
                            ptr2++;}                                                         move ptr2 ahead
                        else if(arr[ptr2] - arr[ptr1] == target){                        else if ptr2 - ptr1 == taret
                            pairOfValue.add(new int[]{arr[ptr1],arr[ptr2]});                 pairOfValue ko add ptr1 ptr2
                            pairOfIndex.add(new int[]{-1,-1});                               pairOfIndex ko add -1 , -1
                            noOfPairs++;                                                     noOfPars++
                                                                                             [PAIR OF INDEX CANT BE FOUND AS YOU SORT ARRAY]    
                            ptr1++;                                                          move ptr1 ahead to reduce the range of dufference    
                        }
                        else if (arr[ptr2] - arr[ptr1] < target) {                        else if ptr2 - ptr2 < target
                            ptr2++;                                                            move ptr2 ahead to increase range of didderence
                        } 
                        else if (arr[ptr2] - arr[ptr1] > target) {                        else if ptr2 - ptr2 > target
                            ptr1++;                                                             move ptr1 ahead to reduce the range of difference
                        } 
                    }





        //UNIQUE PAIR
        ptr1++ 

        KE BADLE

        ptr1++;                                                               move ptr1 ahead
        while (ptr1 <= arr.length-1 && arr[ptr1] == arr[ptr1 - 1]){           move ptr1 ahead to skip duplicates
             ptr1++;                                                          [ARRAY CAN HAVE DUPLICATES AS WE SKIP DUPLICATES]
        }


        Time:O(logn + n)
        SDpace:O(1)
    
        */
        /*
        //PAIRS
        Arrays.sort(arr);

        int ptr1 = 0; 
        int ptr2 = 1;
        List<int[]> pairOfValue = new ArrayList<>();
        List<int[]> pairOfIndex = new ArrayList<>();
        int noOfPairs = 0;

        while (ptr1 <=arr.length-1 && ptr2 <= arr.length-1) {
            if(ptr1 == ptr2){
                ptr2++;}

            else if(arr[ptr2] - arr[ptr1] == target){  
                pairOfValue.add(new int[]{arr[ptr1],arr[ptr2]});
                pairOfIndex.add(new int[]{-1,-1});
                noOfPairs++;

                ptr1++;   
            }
            else if (arr[ptr2] - arr[ptr1] < target) {
                ptr2++;      
            } 
            else if (arr[ptr2] - arr[ptr1] > target) {
                ptr1++;       
            } 
        }

        return noOfPairs;


        //UNIQUE PAIRS
        Arrays.sort(arr);

        int ptr1 = 0; 
        int ptr2 = 1;
        List<int[]> pairOfValue = new ArrayList<>();
        List<int[]> pairOfIndex = new ArrayList<>();
        int noOfPairs = 0;

        while (ptr1 <=arr.length-1 && ptr2 <= arr.length-1) {
            if(ptr1 == ptr2){
                ptr2++;
            }
            else if(arr[ptr2] - arr[ptr1] == target){  
                pairOfValue.add(new int[]{arr[ptr1],arr[ptr2]});
                pairOfIndex.add(new int[]{-1,-1});
                noOfPairs++;
            
                ptr1++;
                while (ptr1 <= arr.length-1 && arr[ptr1] == arr[ptr1 - 1])
                    ptr1++;   
            }
            else if (arr[ptr2] - arr[ptr1] < target) {
                ptr2++;      
            } 
            else if (arr[ptr2] - arr[ptr1] > target) {
                ptr1++;       
            } 
        }
        
        return noOfPairs;

        */


        //USING   HASHMAP(ARRAY REQUIES STORING OF ELEMENTS ) -->Time:O(n),space:O(n)
        //                                                       Array duplicate     :Array can have duplicate 
        //                                                       Pair of value,index :Pair of value can be found, pair of index can be found  
        /*
        [Look in hashmap
        */
        


    }
    public int     arraykthSmallestElement(int[] arr , int k){
        //USING MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)  --> Time : O(n logn) ;Space: O(1)
        /*
        1.SORT ARRAY
        [7,10,4,3,20,15]  --- [3,4,7,10,15,20] -- sort array 

        2.SEARCH ARRAY
        [3,4,7,10,15,20] - return arr.length-k index

        Time : O(n logn)   as we reduce n(length of arr) by half and sort upto n
        Space: O(1)
                              
        */
        Arrays.sort(arr);
        return arr[arr.length-k];

        //USING BINARY MAX HEAP(ARRAY REQUIRES SORTING + K IS GIVEN )-->Time : O(n logk);Space: O(n)
        /*
        Look in Heaps
        */


    }
    public int     arraykthLargestElement(int[] arr , int k){

        //USING MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)  --> Time : O(n logn) ;Space: O(1)
        /*
        1.SORT ARRAY
        [7,10,4,3,20,15]  --- [3,4,7,10,15,20] -- sort array 

        2.SEARCH ARRAY
        [3,4,7,10,15,20] - return arr.length-k index
                              
        Time : O(n logn)   as we reduce n(length of arr) by half and sort upto n
        Space: O(1)
        */
        Arrays.sort(arr);
        return arr[k-1];

        //USING BINARY MIN HEAP(ARRAY REQUIRES SORTING + K IS GIVEN  )-->Time : O(n logk);Space: O(n)
        /*
        Look in Heaps
        */



    }
    public int[]   arrayKsmallestElement(int[] arr , int k){
        //USING MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)  --> Time : O(n logn) ;Space: O(1)
        /*
        1.SORT ARRAY
        [7,10,4,3,20,15]  --- [3,4,7,10,15,20] -- sort array 

        2.SEARCH ARRAY
        [3,4,7,10,15,20] - return from 0 to k-1 index


        Time : O(n logn)   as we reduce n(length of arr) by half and sort upto n
        Space: O(1) 
        */

        Arrays.sort(arr);

        int[] kSmallestArr = new int[k];
        for(int i = 0 ; i < k-1 ; i++){
            kSmallestArr[i] = arr[i];
        }
        return kSmallestArr;
        

        //USING BINARY MAX HEAP(ARRAY REQUIRES SORTING + K IS GIVEN )-->Time : O(n logk);Space: O(n)
        /*
        Look in Heaps
        */

    }
    public int[]   arraykLargestElement(int[] arr , int k){
        
        //USING MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)  --> Time : O(n logn) ;Space: O(1)
        /*
        1.SORT ARRAY
        [7,10,4,3,20,15]  --- [3,4,7,10,15,20] -- sort array 

        2.SEARCH ARRAY
        [3,4,7,10,15,20] -  return arr.length - 1 to k index

                              
        Time : O(n logn)   as we reduce n(length of arr) by half and sort upto n
        Space: O(1) 
        */
        Arrays.sort(arr);
        
        int[] kLargestArr = new int[k];
        for(int i = arr.length-1 ; i >=k ; i--){
            kLargestArr[i] = arr[i];
        }
        return kLargestArr;


        
        //USING BINARY MIN HEAP(Array sorting is req + K is given) -->Time : O(n logk);Space: O(n)
        /*
        [7,10,4,3,20,15]  --- 3X  -- add  the elements to min heap in asc order and  if size > k  pop the element so that minheap of size k is mantained
                              4X    return all the elements   in minheap which will be kth smallest  
                              7X
                              10
                              15
                              20 

        Time : O(n logk)   as we reduce n(length of arr) by half and sort upto k
        Space: O(n) as heap takes extra space

        */
        /*
        Look in Heaps
        */



        


    }
    public int     arrayK1K2smallestElementsSum(int[] arr , int k1 , int k2){
        /*
        QUESTION
        [1,2,3,4,5,6]  -- find the sum of elements between k1 and k2 smallest number exclluding k1 and k2th smallest elements
                          ie if k1 = 2 ; k2 = 5  then 2nd smallest = 2 and 5th smallest = 5 so sum of elements between 2nd and 5th smallest = 3+4 
                          
        */
        
        //USING MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)  --> Time : O(n logn) ;Space: O(1)
        /*
        1.SORT ARRAY
        [7,10,4,3,20,15]  --- [3,4,7,10,15,20] -- sort array 

        2.SEARCH ARRAY
        [3,4,7,10,15,20] -- find sum from k1-1 to k2-1 and remove k1-1 and k2-1 from sum


        Time : O(n logn)   as we reduce n(length of arr) by half and sort upto n
        Space: O(1) 
        */

        Arrays.sort(arr);
        
        int sum =0;
        for(int i = k1-1; i <= k2-1 ;i++){
        sum = sum + arr[i];
        }
        
        sum = sum - arr[k1-1] - arr[k2-1];
        
        return sum;

        //USING MINHEAP(Array sorting is req + K is given )-->Time : O(n logk);Space: O(n)
        /*
        Look in heaps

        */
        


        


    }
    public int[]   arrayKTopfrequentElements(int[] arr, int k){
        /*
        [5,6,5,6,10,5,8,8] -- find the top k elements with max frequency
         k=2                if 2 elements have same freq take smaller element 
                            Eg top 2 freq elements are [5,6]  
               
        */

        //USING MULTIPOINTERS SORT SEARCH + HASHMAP(ARRAY REQUIRES SORTING+ARRAY REQUIRES STORING ELEMENTS)  --> Time : O(n logn) ;Space: O(n)
        /*
        1.SORT ARRAY 
        [1,1,1,2,2,2,2,3,4,4] --->{1:3,  -->      -->populate hashmap with key as element and value as fequency
                                   2:4,              sort the arr in desc order based on value of hashmap and if value of hashmap is same sort in asc order based on key of hashmap
                                   3:1,              
                                   4:2}      
        2.SEARCH ARRAY
        [1,1,1,2,2,2,2,3,4,4]  
         ||
     ptr1 ptr2                   --> initialise ptr1 ptr2 to 0
                                    while(ptr1 <= list.size()-1){                                                 --move ptr1 till list.length(ptr1 at list.length,cb ptr1 enc till list.length-1,ca ptr1 enc till list.lengtg)
                                        result[index++] = list.get(ptr1);
                                        while(ptr2 <= list.size()-1 && (list.get(ptr1) == list.get(ptr2)) ){              move ptr2 till ptr1 == ptr2(ptr2 at ptr1 != ptr2 , cb ptr2 enc till ptr1 == ptr2 , ca ptr2 emc till ptr1 != ptr2)
                                            ptr2++;                                                                           move ptr2 ahead
                                        }                                                                                 reassign ptr1 to ptr2
                                        ptr1 = ptr2;
                                        
                                    }

                                    return Arrays.copyOfRange(result,0,k)                                                return result from 0 to k-1 inclusive
                                                            

        Time : O(n logn)   as we reduce n(length of arr) by half and sort upto n
        Space: O(n) 
        */

        Map<Integer , Integer> hashmapp = new HashMap<>();
        int cnt = 1;
        for (var i = 0; i < arr.length; i++) {
            if (!hashmapp.containsKey(arr[i])) {
                cnt = 1;
            } else {
                cnt = hashmapp.get(arr[i]) + 1;
            }
            hashmapp.put(arr[i], cnt);
        }
        List<Integer> list = new ArrayList<>();
        for(var i : arr){list.add(i);}

        Collections.sort(list , 
        (Integer a,Integer b)->{
            return (hashmapp.get(a) != hashmapp.get(b)) ? hashmapp.get(b) - hashmapp.get(a): a - b;
        });
        
        Collections.sort(list , 
        (Integer value1,Integer value2) -> { 
            
            return (hashmapp.get(value1) == hashmapp.get(value2)) ? hashmapp.get(value2) - hashmapp.get(value1): value2 - value1 ;}    ); 
        
    

        int[] result = new int[list.size()];int index =0;
        int ptr1 = 0;
        int ptr2 =0;
        while(ptr1 <= list.size()-1){
            result[index++] = list.get(ptr1);
            while(ptr2 <= list.size()-1 && (list.get(ptr1) == list.get(ptr2)) ){
                ptr2++;
            }
            ptr1 = ptr2;
            
        }

        
        return Arrays.copyOfRange(result,0,k); 
        
        
        
        //USING MINHEAP + HASHMAP(Array requires sorting + K is given )-->Time : O(n logk),Space O(n)
        /*
        Look in heaps

        */

     




    }
    public int[][] arraykClosestElementsToOrigin(int[][] arr , int k){
        /*
        [[1,2],[3,4],[8,8]] -- find the k closest pints to origin
         k=2                   Eg top 2 closest points to origin   are [[1,2],[3,4]]  
        */

        //USING MULTIPOINTERS SORT SEARCH + HASHMAP(ARRAY REQUIRES SORTING +ARRAY REQUIRES STORING ELEMENTS))  --> Time : O(n logn) ;Space: O(n)
        
       /*
        1.SORT ARRAY
        [[1,3] --->{0:10,  populate hashmap with key as index of element and value as distance
         [2,2]      1:8,   sort the list of index in asc order based on value of hashmap and if value is same sort in asc order  based on key 
         [5,8]      2:100, NOTE:  Insted of double distance = Math.sqrt((arr[i][0]*arr[i][0] + arr[i][1]*arr[i][1]));
         [0,1]      3:1}            as we are just comparing the distances           
        ]                   
                                   
        
        2.SEARCH ARRAY
        [3,1,0,2]   -->iterate over array and take the 1st k indexes and return thosw indexes of ip array
                               
        Time : O(n logn)   as we reduce n(length of arr) by half and sort upto n
        Space: O(1) 
        */  

        Map<Integer ,Integer> hashMapp = new HashMap<>();
        for(int i = 0 ; i <= arr.length-1 ; i++){
            int distance =arr[i][0]*arr[i][0] + arr[i][1]*arr[i][1];
            hashMapp.put(i , distance);
        }
        List<Integer> list = new ArrayList<>();
        for(var i =0 ; i <=arr.length- 1; i++){list.add(i);}

        Collections.sort(list ,        
            (Integer a,Integer b) -> 
            { return (hashMapp.get(a) != hashMapp.get(b)) ? hashMapp.get(a) - hashMapp.get(b): a - b ;} ); 
            
    
        int[][] result = new int[k][2];int index =0;
        for(int i = 0 ; i <= k-1;i++){
            result[index++] = arr[list.get(i)];
        }
        return result;



        

        //USING  MAXHEAP(Array requires sorting + K is given )-->Time : O(n logk),Space O(n)
        /*
        Look in heaps
        */




    }
    public int[]   arraykClosestElementsToPoint(int[] arr ,int k , int x){

        /*
        QUESTION
        [5,6,7,8,8,9] -- find k element closest x 
                       closest element has smallest difference and if difference bw 2 elements 
                       is same take the smaller element
                       Eg: 3 elements closest to 7 are 7,8,8       


        */

        //USING MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)  --> Time : O(n logn) ;Space: O(1)
        /*
        1.SORT ARRAY
        [5,6,7,8,8,9] x = 8 -->sort the array in asc order based on the diference between arr elemnt and x and if diff is same sort in asc order based on value of element
         3 2 1 0 1 1                                                

        2.SEARCH ARRAY
        [8,8,7,9,6,5]      -->iterate over array and take 1st k elements


        Time : O(n logn)   as we reduce n(length of arr) by half and sort upto n
        Space: O(1) 
        */

        List<Integer> list = new ArrayList<>();
        for(var i:arr){list.add(i);}
        Collections.sort(list, (Integer a,Integer b) ->{
            int diff1 = Math.abs(a-x);
            int diff2 =  Math.abs(b-x);
            
            return (diff1 != diff2)? diff1- diff2 : a-b;
            
        });
        
        
        
        int[] result = new int[k];int index = 0;
        for(int i=0 ; i <= k-1;i++){result[index++] = list.get(i);}

        
        return result;
        

        //USING MAXHEAP(Array requires sorting + K is given )-->Time : O(n logk);Space: O(n)
        /*
        Look in heaps
        */
   
    
        
    }
    public int[]   arrayKNearlySortedSort(int[] arr , int k){
        /*
        QUESTION 
        6,5,3,2,8,10,9 -- for each index the correct element can be in i - k to i-1 an i+1 to i+k inclusive 
                          ie for index 0 the correct element can be from 0 to 3
                          for index 1 the correct element can be  0 or 2 to 4
                          for index 4 correct element can be  1 or 3 to 5 to 7
        */                

        //USING MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)  --> Time : O(n logn) ;Space: O(1)
        /*
        1.SORT ARRAY
        [7,10,4,3,20,15]  --- [3,4,7,10,15,20] -- sort array 

        2.SEARCH ARRAY

        Time : O(n logn)   as we reduce n(length of arr) by half and sort upto n
        Space: O(1) 
        */

        Arrays.sort(arr);
        return arr;

        //USING BINARY MINHEAP(Array requires sorrting  + K is given  )-->Time : O(n logk);Space: O(n)
        /*
        Look in heaps       
        */




    }
    public int[]   arrayfrequencySort(int[] arr){
        /*
        Question
        [1,2,2,2,3,3,4,4,4] --  sort the array in increasing order based on the frequency of the values. 
                                If multiple values have the same frequency, sort them in ascending order.
        */

        //USING MULTIPOINTERS SORT SEARCH + HASHMAP(ARRAY REQUIRES SORTING +ARRAY REQUIRES STORING ELEMENTS)  --> Time : O(n logn) ;Space: O(n)
        /*
        1.SORT ARRAY
        [1,1,1,2,2,2,2,3,4,4] --->{1:3,  -->      -->populate hashmap with key as element and value as fequency
                                   2:4,              sort the array based on frequency of hashmap in descending order and if freq is same sort in asc order based on key
                                   3:1,              
                                   4:2} 
        2.SEARCH ARRAY
        [1,1,1,2,2,2,2,3,4,4]   -->return the arr
        
        
        Time : O(n logn)   as we reduce n(length of arr) by half and sort upto n
        Space: O(1) 
        */
        Map<Integer , Integer> hashmapp = new HashMap<>();
        int cnt = 1;
        for (var i = 0; i < arr.length; i++) {
            if (!hashmapp.containsKey(arr[i])) {
                cnt = 1;
            } else {
                cnt = hashmapp.get(arr[i]) + 1;
            }
            hashmapp.put(arr[i], cnt);
        }

     
        List<Integer> list = new ArrayList<>();
        for(var i : arr){list.add(i);}
        Collections.sort(list ,        
            (Integer a,Integer b) -> 
            { return (hashmapp.get(a) != hashmapp.get(b)) ? hashmapp.get(b) - hashmapp.get(a):a - b ;} ); 
        
        int[] result = new int[list.size()];int index =0;
        for(int i:list){result[index++] = i;}
        return result;
        

        //USING HASHMAP AND MAXHEAP(sorting is req + K is given )-->Time : O(n logk),Space O(n)
        /*
        Look in heaps
        */
        







   
   
   
   
   
   
   
   
    }
    public int[]   arraySetBitsFrequencySort(int[] arr){
        /*
        [5,2,3,9,4,6,7,15,32] -- given an array sort the array by number of set bits in desc order
                                 Eg  [5,2,3,9,4,6,7,15,32] --[15,7,5,3,9,6,2,4,32]
        
        */

        //USING MULTIPOINTERS SORT AND SEARCH (ARRAY REQUIRES SORTING) --Time:O(logn + n)  Space:O(n)
        /*
        SORT
        [5,2,3,9,4,6,7,15,32]  --sort the array based on number of set bits of each element oin descending order
                              
                             
        
        
        */

        int[] setBitArr = new int[arr.length];
        for(int i=0 ; i <= arr.length-1;i++){
            setBitArr[i] = numberBitsSetKaCount(arr[i]);
        }


        List<Integer> list = new ArrayList<>();
        for(var i:arr){list.add(i);}
        Collections.sort(list,
            (Integer val1, Integer val2)->{
                return numberBitsSetKaCount(val2) - numberBitsSetKaCount(val1);
            });
        for(int i=0;i<= list.size()-1;i++){arr[i] = list.get(i);}

        return arr;
        
        
        
      
      
        
    }
    public String  arrayLargestNumberOnRearrangingSort(int[] arr){
        /*
        
        [3,30,34,5,9] -- an array of non negative integers
                  sort them such that on conctenating them we get largets number
                  Eg:[3,30,34,5,9] -->"9534330"
                      [10,2] --> [210]
        */
   
       //USING MULTIPOINTERS SORT AND SEARCH (ARRAY REQUIRES SORTING) 
        /*
        //SORT
        [3,30,34,5,9]  -- convert to string[]  because you want to sort digits lexicographically
                          sort in desc order based on valu1 + value2 and value2 + value1
                          
        //SEARCH
        ["9","5","34","30","3"] -- iterate over arr and add to result
                           
                              
        
        Time:O(n logn + n)
        Space:O(n)
        
        */
        String[] arr2  = new String[arr.length];  
        for(int i=0 ; i <= arr.length-1;i++){
            arr2[i] = String.valueOf(arr[i]);
        }
        
        
        
      
        Arrays.sort(arr2, (String a, String  b) ->{
             String s1 = a + b;
             String s2 = b + a;
    
            
              return s2.compareTo(s1);
        });
        
        String res = "";
        for(int i = 0 ; i <= arr2.length-1 ; i++){
            res = res + arr2[i];
        }
    
        if(res.charAt(0) == '0'){
            return "0";
        }
        return res;
        
        
        
    }
    public int[]   arraySquareSort(int[] arr){
        /*
        [2,3,-7,-3,11]  --Square of each elements and sort them 
                          Eg:[2,3,-7,-3,11] -- [4,9,49,9,121]  -- [4,9,9,49,121]


        */

        //USING MULTIPOINTERS SORT AND SEARCH (ARRAY REQUIRES SORTING) --Time:O(logn + n)  Space:O(n)
        //                                                               (If We can square and sort then we will req n+nlogn ;If we sort search we req nlogn(not req if arr is already sorted) + n
        /*
        1.SORT ARRAY
        [2,3,-7,-3,11] --> [-7,-3,2,3,11]  -- sort aray

        2.SEARCH ARRAY
        [-7,-3,2,3,11] 
        |
        ptr             --  initialise ptr to 0
                            int ptr = 0;
                            while(ptr <= arr.length-1 && arr[ptr] < 0){  -- move ptr till arr.length-1 and till 1st +ve intee=ger
                                ptr++;                                     (ptr at arr.length, cb ptr enc till arr.length-1, ca ptr enc till arr.length)
                            }                                         
            ptr           
            |            
        [-7,-3,2,3,11] []
             |   |       |
            ptr1 ptr2  ptr3 --initialise ptr1 to ptr-1
                            initialise ptr2 to ptr
                            initialise ptr3 to 0
                            while(ptr1 >=0 && ptr2<= arr.length-1){                   -- move ptr1 till -1 and ptr2 till arr.length
                                if(Math.abs(arr[ptr1]) == Math.abs(arr[ptr2])){          (ptr1 at -1 , cb ptr1 enc till 0 , ca ptr1 enc till -1 ; ptr2 at arr.length , cb ptr2 enc till arr.length-1 , ca ptr enc till arr.length)
                                    result[ptr3] = arr[ptr1]*arr[ptr1];                        add ptr1*ptr1 in result
                                    ptr3++;                                                    move ptr3 ahead
                                    ptr1--;                                                    move ptr1 behing
                                    result[ptr3] = arr[ptr2]*arr[ptr2];                        add ptr2*ptr2 in result 
                                    ptr3++;                                                    move ptr3 ahead
                                    ptr2++;                                                    move ptr3 ahead
                                }
                                    
                                else if(Math.abs(arr[ptr1]) < Math.abs(arr[ptr2]) ){  if(Math.abs(arr[ptr1]) < Math.abs(arr[ptr2]) 
                                    result[ptr3] = arr[ptr1]*arr[ptr1];                     add ptr1*ptr1 in result
                                    ptr3++;                                                 move ptr3 ahead
                                    ptr1--;                                                 move ptr1 behing
                                 }
                                else if(Math.abs(arr[ptr2]) < Math.abs(arr[ptr1])  ){  if(Math.abs(arr[ptr2]) < Math.abs(arr[ptr1])  ){
                                    result[ptr3] = arr[ptr2]*arr[ptr2];                     add ptr2*ptr2 in result
                                    ptr3++;                                                 move ptr3 ahead
                                    ptr2++;                                                 move ptr1 ahead
                                |
                                else if because ptr1 , ptr2 , t=ptr3 modified and used in condition   
                            }
                                                                            //null check if(ptr1 >= 0){} for smaller right side
                            if(ptr1 >= 0 ){                                 move ptr1 till -1      
                                while(ptr1 >= 0){                           (ptr1 at -1 , cb ptr1 enc till 0; ca ptr enc till -1)
                                    result[ptr3] = arr[ptr1]*arr[ptr1];          add ptr1*ptr1 in result
                                    ptr1++;                                       move ptr3 ahead
                                    ptr1--;                                       move ptr1 behind
                                    
                                }
                            }
                            
                            if(ptr2 <= arr.length){                        //null check if(ptr2 <= arr.length-1){} for smaller left side
                                while(ptr2 <= arr.length-1){                move ptr2 till -1
                                                                            (ptr2 at arr.length , cb ptr2 enc till arr.length-1; ca ptr enc till arr.length)
                                    result[ptr3] = arr[ptr2]*arr[ptr2];         add ptr2*ptr2 in result 
                                    ptr3++;                                     move ptr3 ahead
                                    ptr2++;                                     move ptr ahead
                                                    
                                }
                            
                                
                            }  
    
                            
                            return result;
                                                                    
                                                                                        
        Time : O(logn + n)    
        Space: O(n)    


        

        */

        
        int[] result = new int[arr.length];
        
        int ptr = 0;
        while(ptr <= arr.length-1 && arr[ptr] < 0){
            ptr++;
        }
        
        int ptr1 = ptr-1;
        int ptr2 = ptr;
        int ptr3 = 0;
        while(ptr1 >=0 && ptr2<= arr.length-1){
            if(Math.abs(arr[ptr1]) == Math.abs(arr[ptr2])){
                result[ptr3] = arr[ptr1]*arr[ptr1];
                ptr1--;
                ptr3++;
                result[ptr3] = arr[ptr2]*arr[ptr2];
                ptr2++;
                ptr3++;
            }
            else if(Math.abs(arr[ptr1]) < Math.abs(arr[ptr2]) ){
                result[ptr3] = arr[ptr1]*arr[ptr1];
                ptr1--;
                ptr3++;
                
                
            }
            else if(Math.abs(arr[ptr2]) < Math.abs(arr[ptr1])  ){
                result[ptr3] = arr[ptr2]*arr[ptr2];
                ptr2++;
                ptr3++;
            }
                
        }
        
        if(ptr1 >= 0 ){
            while(ptr1 >= 0){
                result[ptr3] = arr[ptr1]*arr[ptr1];
                ptr1--;
                ptr3++;
                
            }
        }
        
        if(ptr2 <= arr.length){
            while(ptr2 <= arr.length-1){
                result[ptr3] = arr[ptr2]*arr[ptr2];
                ptr2++;
                ptr3++;
                
            }
        
            
        }  
        
        return result;

        //USING HASHMAP AND MAXHEAP(sorting is req + K is "not" given )-->Time : --,Space O--
        /*
        Skip as k is not given
        */
        

        
            
        }
    public int[]   arrayQuadraticSort(int[] arr , int a,int b,int c ){
        /*
        [-2,4,2,-4]           --find quadratic of each elements as ax^2 + bx + c  and sort them
        a = 1, b = 3, c = 5    Eg:[-2,4,2,-4]   a = 1, b = 3, c = 5  --[3,33,15,9] -- [3,9,15,33]


        */


        //USING MULTIPOINTERS SORT AND SEARCH (ARRAY REQUIRES SORTING) --Time:O(logn + n)  Space:O(n)
        //                                                               If We can find quadratic and sort then we will req n+logn ;If we sort search we req nlogn(not req if arr is already sorted) + n
        /*
        1.SORT ARRAY
        [-2,4,2,-4] --> [-4,-2,2,-4]  -- sort aray

        2.SEARCH ARRAY
        [-4,-2,2,-4]   []
         |         |   |
         ptr1     ptr2 ptr3   -initialise ptr1 ptr2 to 0 , ptr3 depending on a

                        if(a >=0){                                                                    --if a >0 means quad eq will be upward parabola so it has largest value at end and min value at centre
                            ptr3 = result.length-1;                                                     initialise ptr3 to arr.length-1 because we start from largest value at edged

                            while(ptr1 <= ptr2){                                                        move ptr1 , ptr2 till ptr1 <= ptr2
                                                                                                        (ptr1 right reach at node where ptr1=ptr2 ; code before moving ptr encounter till ptr1eft < ptr2; code after moving ptr encounter till ptr1 == ptr2)
                                if(quad(arr[ptr1],a,b,c) == quad(arr[ptr2],a,b,c) && ptr1 != ptr2 ){          if quad(ptr1) == quad(ptr2) && ptr1 != ptr2 means they have not colided but are same
                                        result[ptr3] = quad(arr[ptr1],a,b,c);                                        add quad(ptr1) in result    
                                        ptr3--;                                                                      move ptr3 behind
                                        ptr1++;                                                                      move ptr1 ahead
                                        result[ptr3] = quad(arr[ptr2],a,b,c);                                        add quad(ptr2) to result
                                        ptr3--;                                                                      move ptr3 behind
                                        ptr2--;                                                                      move ptr2 behing
                                }
                                else if(quad(arr[ptr1],a,b,c) == quad(arr[ptr2],a,b,c) && ptr1 == ptr2 ){    else if quad(ptr1) == quad(ptr2) && ptr1 == ptr2 means they are same due to pointing same element
                                        result[ptr3] = quad(arr[ptr1],a,b,c);                                     add quad(ptr1) to result
                                        ptr3--;                                                                   move ptr3 back
                                        ptr1++;                                                                   move ptr1 ahead


                                }
                                else if(quad(arr[ptr1],a,b,c) < quad(arr[ptr2],a,b,c)){                   else if quad(ptr1) <quad(ptr2) && ptr1 == ptr2 
                                    result[ptr3] = quad(arr[ptr2],a,b,c);                                        add quad(ptr2) to result
                                    ptr3--;                                                                      move ptr3 back
                                    ptr2--;                                                                      move ptr2 back


                                }
                                else if(quad(arr[ptr1],a,b,c) > quad(arr[ptr2],a,b,c)){                   else if quad(ptr1) > quad(ptr2) && ptr1 == ptr2 
                                    result[ptr3] = quad(arr[ptr1],a,b,c);                                      add quad(ptr2) to result
                                    ptr3--;                                                                    move ptr3 back
                                    ptr1++;                                                                   move ptr2 ahead
                                }

                            }       
                        }

                        else if(a < 0){                                                               --else if a < 0 means quad eq will be downward parabola so it has largest value at centre and min value at ends
                            ptr3 = 0;                                                                 initialise ptr3 to 0 because we start from smallest value at edges

                            while(ptr1 <= ptr2){                                                        move ptr1 , ptr2 till ptr1 <= ptr2
                                                                                                        (ptr1 right reach at node where ptr1=ptr2 ; code before moving ptr encounter till ptr1eft < ptr2; code after moving ptr encounter till ptr1 == ptr2)
                                if(quad(arr[ptr1],a,b,c) == quad(arr[ptr2],a,b,c) && ptr1 != ptr2 ){          if quad(ptr1) == quad(ptr2) && ptr1 != ptr2 means they have not colided but are same
                                        result[ptr3] = quad(arr[ptr1],a,b,c);                                        add quad(ptr1) in result    
                                        ptr3++;                                                                      move ptr3 ahead
                                        ptr1++;                                                                      move ptr1 ahead
                                        result[ptr3] = quad(arr[ptr2],a,b,c);                                        add quad(ptr2) to result
                                        ptr3++;                                                                      move ptr3 ahead
                                        ptr2--;                                                                      move ptr2 behing
                                }
                                else if(quad(arr[ptr1],a,b,c) == quad(arr[ptr2],a,b,c) && ptr1 == ptr2 ){    else if quad(ptr1) == quad(ptr2) && ptr1 == ptr2 means they are same due to pointing same element
                                        result[ptr3] = quad(arr[ptr1],a,b,c);                                     add quad(ptr1) to result
                                        ptr3++;                                                                   move ptr3 ahead
                                        ptr1++;                                                                   move ptr1 ahead


                                }
                                else if(quad(arr[ptr1],a,b,c) < quad(arr[ptr2],a,b,c)){                   else if quad(ptr1) <quad(ptr2) && ptr1 == ptr2 
                                    result[ptr3] = quad(arr[ptr1],a,b,c);                                        add quad(ptr1) to result
                                    ptr3++;                                                                      move ptr3 ahead
                                    ptr1++;                                                                      move ptr1 ahead
                                }
                                else if(quad(arr[ptr1],a,b,c) > quad(arr[ptr2],a,b,c)){                   else if quad(ptr1) > quad(ptr2) && ptr1 == ptr2 
                                    result[ptr3] = quad(arr[ptr2],a,b,c);                                      add quad(ptr2) to result
                                    ptr3++;                                                                    move ptr3 ahead
                                    ptr2--;                                                                    move ptr2 back
                                }

                            }       
                        }
            
                    return result                                                                     --return result arr
        
        
        */
        Arrays.sort(arr);

        int ptr1 =0;
        int ptr2 =arr.length-1;
        int ptr3 =0;
        int[] result = new int[arr.length];
        if(a >=0){
            ptr3 = result.length-1;
            
            while(ptr1 <= ptr2){
                //if(quad(arr[ptr1],a,b,c) == quad(arr[ptr2],a,b,c) && ptr1 != ptr2 ){
                //        result[ptr3] = quad(arr[ptr1],a,b,c);
                        ptr3--;
                        ptr1++;

                //        result[ptr3] = quad(arr[ptr2],a,b,c);
                        ptr3--;
                        ptr2--;
                //}
                //else if(quad(arr[ptr1],a,b,c) == quad(arr[ptr2],a,b,c) && ptr1 == ptr2 ){
                //        result[ptr3] = quad(arr[ptr1],a,b,c);
                        ptr3--;
                        ptr1++;
                //}
                //else if(quad(arr[ptr1],a,b,c) < quad(arr[ptr2],a,b,c)){
                //    result[ptr3] = quad(arr[ptr2],a,b,c);
                    ptr3--;
                    ptr2--;
                //}
                //else if(quad(arr[ptr1],a,b,c) > quad(arr[ptr2],a,b,c)){
                //    result[ptr3] = quad(arr[ptr1],a,b,c);
                    ptr3--;
                    ptr1++;
                //}

            }
            
   
                
            }
   
        else if(a< 0){
            ptr3 = 0;
            while(ptr1 <= ptr2){
                //if(quad(arr[ptr1],a,b,c) == quad(arr[ptr2],a,b,c) && ptr1 != ptr2 ){
                //        result[ptr3] = quad(arr[ptr1],a,b,c);
                        ptr3++;
                        ptr1++;

                //        result[ptr3] = quad(arr[ptr2],a,b,c);
                        ptr3++;
                        ptr2-- ;
                //}
                //else if(quad(arr[ptr1],a,b,c) == quad(arr[ptr2],a,b,c) && ptr1 == ptr2 ){
                //        result[ptr3] = quad(arr[ptr1],a,b,c);
                        ptr3++;
                        ptr1++;

                        // result[ptr3] = quad(arr[ptr2],a,b,c);
                        // ptr3--;
                        // ptr2--;



                //}
                //else if(quad(arr[ptr1],a,b,c) < quad(arr[ptr2],a,b,c)){
                //    result[ptr3] = quad(arr[ptr1],a,b,c);
                    ptr3++;
                    ptr1++;
                //}
                //else if(quad(arr[ptr1],a,b,c) > quad(arr[ptr2],a,b,c)){
                //    result[ptr3] = quad(arr[ptr2],a,b,c);
                    ptr3++;
                    ptr2--;
                //}

            }
            
   
            
        }
        
        return result;

        //USING HASHMAP AND MAXHEAP(sorting is req + K is "not" given )-->Time : --,Space O--
        /*
        Skip as k is not given
        */
        

        
        
        
    }
    public boolean arrayContainsDuplicate(int[] arr){
        /*
        [1,2,2,3,4] -- return true if array contains duplicate
                      if all unique return false

        */

        //USING MULTIPOINTERS SORT AND SEARCH (ARRAY REQUIRES SORTING) --Time:O(nlogn + n)  Space:O(1)
        /*
        //SORT
        [1,3,2,2,4] -- sort arr

        //SEARCH
        [1,2,2,3,4] 
         |
         ptr       --initialise ptr1 to 0
                    while(ptr1 <= arr.length-1){                                     --move ptr1 till arr1.length(ptr1 att arr1.length , cb ptr1 enc till arr.length-1 , ca ptr enc till arr.lenngth)
                        int ptr2 = ptr1;                                                  initialise ptr2 ti ptr1
                        while(ptr2 <= arr.length-1 && arr[ptr1] == arr[ptr2]){            move ptr2 till ptr1 != ptr2(ptr2 at ptr1 != ptr2 , cb moving enc till ptr1 == ptr2  , ca moving enc till ptr1 != ptr2)
                            ptr2++;}                                                            move ptr2 ahead
                        int count = ptr2 - ptr1;                                          find count of elements = ptr2 - ptr1
                        if(count >= 2){return true;}                                       if count >= 2 return true
                        ptr1 = ptr2;                                                        reasign pr1 to ptr2
                    }

        Time: O(logn + n)
        Space:O(1)


        
        */
        Arrays.sort(arr);
        int ptr1 = 0;
        while(ptr1 <= arr.length-1){
            int ptr2 = ptr1;
            while(ptr2 <= arr.length-1 && arr[ptr1] == arr[ptr2]){
                ptr2++;
            }
            int count = ptr2 - ptr1;
            if(count >= 2){
                return true;
            }
            
            ptr1 = ptr2;
        }
    
        
        return false;

        //USING HASHMAP(ARRAY REQUIRES STORING) -->--Time:O( n)  Space:O(1)
        /*
        Look in hashmap
        */
    
    }
    public int[]   arrayRemoveDuplicate(int[] arr){

        /*
        [0,1,2,2,3,0,4,2] -- in a  array remove duplicates in place so all  unique will be on left  in sorted manner
                            return array where remaining values doesnt matter-->return [0,1,2,3,4,_,_,_] 
                            return array with remaining elements 0           -->return [0,1,2,3,4,0,0,0] 
                            return array with only values                    -->return [0,1,2,3,4]
                            return count                                     -->return 5
                                    


        */

        //USING MULTIPOINTERS SORT SEARCH (ARRAY REQUIRES SORTING) -->Time:O(nlogn + n),Space:O(1)                                                
        /*
        1.SORT ARRAY
        [1,2,,2,3,5,4,5] --> [1,2,2,3,3,3,4,5,5] -- sort array 

        2.SEARCH ARRAY
        [1,2,2,3,3,3,4,5,5] 
        |
        ptr1,ptr2,ptr3      -- initialise ptr1 ptr2 to 0
                                while(ptr1 <= arr.length -1 && ptr2 <= arr.length -1){        --move ptr1 ptr2 till arr.length-1
                                                                                                (ptr1 ,ptr2 at arr.length , cb enc till arr.length-1, c enc til arr.length)
                                    while(ptr2 <= arr.length-1 && arr[ptr2] == arr[ptr1]){    --move  ptr2 till arr.length-1 and till duplicate ends
                                        ptr2++;                                                 (ptr2 at arr.length , cb enc till arr.length-1, c enc til arr.length)
                                    }
                                    if(ptr2==arr.length){}                                       //null check:ptr1,ptr3 doesnt reach arr.length but ptr2 may reach null(we use ptr1 not ptr2 as index in next line)  ; so no need for null check
                                    arr[ptr3] = arr[ptr1];ptr3++;                               --give ptr3 ptr1
                                    ptr1 = ptr2;                                                --reassign ptr1 tp ptr2
                                }
                                    
                                                                                                //null check if(ptr1<=arr1.length-1){} not req
                                                                                                //null check if(ptr2<=arr1.length-1){} not req

                                return ptr3;                                                       --require elements till ptr3-1; so return ptr1 we need count of element not index so    
                                for(int i = ptr3 ; i <= arr.length-1;i++ ){arr[i]=0;} return arr;    require elements till ptr3-1; so ptr3 to arr.length fill 0 and return arr
                                return Arrays.copyOfRange(arr,0,ptr3);                               require elements till ptr3-1;so return 0 to ptr3 exclusive

                            
        Time : O(nlogn + n)    
        Space: O(1) 
        */
        Arrays.sort(arr);

        int ptr1 = 0;
        int ptr2 = 0;
        int ptr3 = 0;
        while(ptr1 <= arr.length -1 && ptr2 <= arr.length -1){
            
            while(ptr2 <= arr.length-1 && arr[ptr2] == arr[ptr1]){
                ptr2++;
            }
            if(arr[ptr2] == arr.length){} 
            arr[ptr3] = arr[ptr1];
            ptr3++;
            ptr1 = ptr2;            
        }

        //return ptr3;
        //for(int i = ptr3 ; i <= arr.length-1;i++ ){arr[i]=0;} return arr;
        return Arrays.copyOfRange(arr,0, ptr3);

        //USING HASHSET(ARRAY REQUIRES STORING  ) ->Time:O(n + nlogn),Space:O(n)  
        /*
        Look in HASHMAP/HASHSET
        */
        
        
            
        }
    public int[]   arrayRemoveDuplicateII(int[] arr){
        /*
        [1,2,2,3,3,3,4,5,5]  -- remove duplicates in place so that it has at most 2 duplicates and all  elements will be on left in sorted manner and  elements after that doesnt matter
                                Eg: return array where remaining values doesnt matter                    return [1,2,3,3,4,5,5,_,_] retun 5
                                    return array with remaining elements 0                               return [0,1,2,3,4,0,0,0] 
                                    return array with only values                                         return [0,1,2,3,4]
                                    return count of elements                                             return 5
                                
                                
                                
                                
     

        */

        //USING MULTIPOINTERS SORT SEARCH (ARRAY REQUIRES SORTING) -->Time:O(nlogn + n),Space:O(1)
        //                                                             Manipulation:Array is Changed  
        /*
        1.SORT ARRAY
        [1,2,2,2,3,5,4,5] --> [1,2,2,3,3,3,4,5,5] -- sort array 

        2.SEARCH ARRAY
        [1,2,2,3,3,3,4,5,5] 
        |
        ptr1,ptr2,ptr3      -- initialise ptr1 ptr2 to 0
                                while(ptr1 <= arr.length -1 && ptr2 <= arr.length -1){     --move ptr1 ptr2 till arr.length-1
                                                                                            (ptr1 ,ptr2 at arr.length , cb enc till arr.length-1, c enc til arr.length)
                                    while(ptr2 <= arr.length-1 && arr[ptr2] == arr[ptr1]){ --move  ptr2 till arr.length-1 and till duplicate ends
                                        ptr2++;                                             (ptr2 at arr.length , cb enc till arr.length-1, c enc til arr.length)
                                    } 
                                    
                                    if(ptr2==arr.length){}                                  //null check:ptr1,ptr3 doesnt reach arr.length but ptr2 may reach null(we use ptr1 not ptr2 as index in next line)  ; so no need for null check
                                    if(ptr2 - ptr1 ==1 ){                                   --if no duplicates assign ptr1 to ptr3
                                        arr[ptr3] = arr[ptr1];ptr3++;}                       if 2 or more duplicates assig ptr3 ptr1 and ptr3 ka next ptr1
                                    if(ptr2 - ptr1 >=2){
                                        arr[ptr3] = arr[ptr1];ptr3++;
                                        arr[ptr3] = arr[ptr1];ptr3++;}
                                    
                                    ptr1 = ptr2;                                            --reassign ptr1 to ptr2
                                }
                                                                                            //null check if(ptr1<=arr1.length-1){} not req
                                                                                            //null check if(ptr2<=arr1.length-1){} not req
 
                                return arr;                                                         --return arr as it is 
                                for(int i = ptr3 ; i <= arr.length-1;i++ ){arr[i]=0;} return arr;    require elements till ptr3-1; so ptr3 to arr.length fill 0 and return arr
                                return Arrays.copyOfRange(arr,0,ptr3);                               require elements till ptr3-1;so return 0 to ptr3 exclusive
                                return ptr3                                                          require elements till ptr3-1; so return ptr1 we need count of element not index so    
        Time : O(n)    
        Space:0(1)

        

        */

        Arrays.sort(arr);

        int ptr1 = 0;
        int ptr2 = 0;
        int ptr3 = 0;
        while(ptr1 <= arr.length -1 && ptr2 <= arr.length -1){
            
            while(ptr2 <= arr.length-1 && arr[ptr2] == arr[ptr1]){
                ptr2++;
            }

            if(ptr2==arr.length){}
            if(ptr2 - ptr1 ==1 ){
                arr[ptr3] = arr[ptr1];
                ptr3++;
            }
            if(ptr2 - ptr1 >=2){
                arr[ptr3] = arr[ptr1];
                ptr3++;
                arr[ptr3] = arr[ptr1];
                ptr3++;
                
            }
            ptr1 = ptr2;            
        }
            
         return arr;
        //for(int i = ptr3 ; i <= arr.length-1;i++ ){arr[i]=0;} return arr;
        //return Arrays.copyOfRange(arr,0, ptr3);
        //return ptr3;



        //USING HASHMAP(ARRAY REQUIRES STORING AND ARRAY RETURN KA ORDER DOESNT MATTER ) ->Time:O(n + nlogn),Space:O(n)
        //                                                                                 Manipulation:Array is UnChanged    
        /*
        Look in HASHMAP/HASHSET
        */
        
        
            
        }
    public int[]   arrayRemoveElement(int[] arr, int val){
        /*
        [0,1,2,2,3,0,4,2] val =2  -- in a  array remove values in place so all remaining elements   will be on left  mantaining their relative order
                                    return array where remaining values doesnt matter(return count not array)  return [0,1,3,4,_,_,_] retun 4
                                    return array with remaining elements 0                                     return [0,1,3,4,0,0,0] 
                                    return array with only values                                              return [0,1,3,4]
                                    
                                    



        */


        //USING MULTIPOINTERS SORT SEARCH (ARRAY REQUIRES SORTING) -->Time:O(nlogn + n),Space:O(1)
        /*
        1,SORT ARRAY
        sorting is not required
        
        2.SEARCH ARRAY
        [1,2,2,3,3,3,4,5,5] 
        |
        ptr1,ptr2,     -- initialise ptr1 ptr2 to 0
                            while(ptr1 <= arr.length-1 && ptr2 <= arr.length-1){                   --move ptr1 ptr2 till arr.length-1
                                                                                                    (ptr1 ,ptr2 at arr.length , cb enc till arr.length-1, c enc til arr.length)     
                                if(arr[ptr2] == val){                                              --if ptr2 matches value 
                                    while(ptr2 <= arr.length-1 && arr[ptr2] == val){                  move  ptr2 till arr.length-1 and till it matches value
                                        ptr2++;                                                      (ptr2 at arr.length , cb enc till arr.length-1, c enc til arr.length)
                                    }
                                } 
                                if(ptr2 == arr.length){                                                //null check:ptr1 doesnt reach arr.len but ptr2 may reach arr.len(we use ptr1,ptr2 as index in next line)  ; so if ptr2 is at null seearch is complete return elements till ptr1-1
                                return ptr1;                                                        require elements till ptr1-1; so return ptr1 we need count of element not index so    
                                for(int i = ptr1 ; i <= arr.length-1;i++ ){arr[i]=0;} return arr;   require elements till ptr1-1; so ptr1 to arr.length fill 0 and return arr
                                return Arrays.copyOfRange(arr,0,ptr1);                              require elements till ptr1-1;so return 0 to ptr1 exclusive 
                                }   
                                arr[ptr1] = arr[ptr2];                                                --reassign ptr1 tp ptr2                      
                                ptr1++;                                                               --move ptr1,ptr2 ahead       
                                ptr2++;         
                                }

                                                                                                    //null check if(ptr1<=arr1.length-1){} not req
                                                                                                    //null check if(ptr2<=arr1.length-1){} not req

                                return ptr1;                                                        -require elements till ptr1-1; so return ptr1 we need count of element not index so    
                                for(int i = ptr1 ; i <= arr.length-1;i++ ){arr[i]=0;} return arr;    require elements till ptr1-1; so ptr1 to arr.length fill 0 and return arr
                                return Arrays.copyOfRange(arr,0,ptr1);                               require elements till ptr1-1;so return 0 to ptr1 exclusive
        Time : O(n)    
        Space:O(1)


        

        */

        
        int ptr1 = 0;
        int ptr2 = 0;        
        while(ptr1 <= arr.length-1 && ptr2 <= arr.length-1){
            
            if(arr[ptr2] == val){
                while(ptr2 <= arr.length-1 && arr[ptr2] == val){
                    ptr2++;
                }
            }
            if(ptr2 == arr.length){ 
                //return ptr1; 
                //for(int i = ptr1 ; i <= arr.length-1;i++ ){arr[i]=0;} return arr;
                return Arrays.copyOfRange(arr,0, ptr1);}
            arr[ptr1] = arr[ptr2];     
            ptr1++;
            ptr2++;
            
        
        }
        
        //return ptr1;
        //for(int i = ptr1 ; i <= arr.length-1;i++ ){arr[i]=0;} return arr;
        return Arrays.copyOfRange(arr,0, ptr1);
        
        //USING HASHMAP(ARRAY REQUIRES STORING AND ARRAY RETURN KA ORDER DOESNT MATTER ) ->Time:O(n + nlogn),Space:O(n)  
        /*
        Skip as hashmap doesnt guarantee order so we will not be able to get the same relative order
        */
        

            
            
        }
    public String  stringRemoveVowels(String s) {
        /*
        "welcome to india"  -- in a  string remove vowels  remaining elements   will be on left  mantaining their relative order
                            and return the string
                            Eg:"welcome to india" -- "wlcm t nd"


        */

        //USING MULTIPOINTERS SORT SEARCH (ARRAY REQUIRES SORTING)
        /*
        1.SORT ARRAY
        "welcome to india" 
        ['w','e','l','c','o','...]  -- convert string to array
                                       and sorting is not req

        2.SEARCH ARRAY
        "welcome to india" 
        ['w','e','l','c','o','...] -- char[] arrWithoutVowel = arrayRemoveElement(arrwithVowel);  -->Fn as char[] fnName(char[] arr) ; isVowel(arr[ptr2]) instead f arr[ptr2] == val ; return Arrays.copyOfRange(0,ptr1)
                                      iterate over array without vowel and append to sb
                                      convert sb to string and return string
        
        
        
        Time : O(n)    
        Space:O(1)


        

        */

        char[] arrwithVowel = s.toCharArray();
        char[] arrwithoutVowel = new char[0]; //char[] arrwithoutVowel = arrayRemoveElement(arrwithVowel);
        
        StringBuffer sb = new StringBuffer("");
        for(int i = 0 ; i <=arrwithoutVowel.length-1 ;i++){
            sb.append(arrwithoutVowel[i]);
        }
        
        return sb.toString();

        //isvowel
        /*
        public boolean isVowel(char c){
        return c== 'a'
            ||c== 'e'
            ||c== 'i'
            ||c== 'o'
            ||c== 'u'
            ||c== 'A'
            ||c== 'E'
            ||c== 'I'
            ||c== 'O'
            ||c== 'U';
            
        }        
        */
    
        //USING HASHMAP(ARRAY REQUIRES STORING AND ARRAY RETURN KA ORDER DOESNT MATTER ) ->Time:O(n + nlogn),Space:O(n)  
        /*
        Skip as hashmap doesnt guarantee order so we will not be able to get the same relative order
        */
        
        
        }
    public int[]   arrayMissingRanges(int[] arr, int lower , int upper){
            /*
            arr [0,1,3,50,75]    -- given a sorted array give return the missing rage between lower and upper bound 
            lower = 0;upper = 99    Eg: arr [0,1,3,50,75] lower = 0; upper = 99
                                    ["2","4->49","51->74","76->99"]
    
            */
    
            //USING ARRAY MULTIPTR(ARAY REQUIRES MULTIPTRE)
            /*
            0 [0,1,3,50,75] 99 
                                public int[]   arrayMissingDuplicate(int[] arr, int lower , int upper){
                                    //Null CHECK FOR 0 LENGTGH
                                    if (arr.length == 0){                            --if arr has 0 length                      
                                        result.add(formatRange(lower,upper));             means there is a missing range lower to upper 
                                        return result;                                    return res
                                    }
                                    //CHGECK LOWER AND arr[0]
                                    if (arr[0] > lower){                                 --if arr[0] > lower
                                        result.add(formatRange(lower,arr[0]-1));             means there is a missing range from lower to arr[0] -1 
                                    }
    
                                    //CHECK ALTERNATE ARRAY ELEMENTS
                                    int ptr1 = 0; int ptr2 = 1;                           --initialise ptr1 to 0 and ptr2 to 1                               
                                    while(ptr2 <= arr.length-1){                             move ptr2 till arr.length
                                        if(arr[ptr2] - arr[ptr1]>= 2){                          arr[ptr2] - arr[ptr1]>= 2
                                            result.add(formatRange(arr[ptr1]+1, arr[ptr2]-1));     means there is a missing range arr[ptr1]+1, arr[ptr2]-1
                                        }                                                      move ptr1 ptr2 ahead
                                        ptr1++;
                                        ptr2++;
                                    }
    
                                    //CHECK arr[arr.length-1] and upper                
                                    if (arr[arr.length-1] < upper){                         --if arr[arr.length-1] < upper
                                        result.add(formatRange(arr[arr.length-1]+1, upper));   means there is a missing range from arr[arr.length-1]+1 to arr[0] -1 
                                    }
                                }
                                private String formatRange(int missingStart, int missingEnd) {
                                    if (missingStart == missingEnd)                               --if missingStart and missingEnd are same
                                        return String.valueOf(missingStart);                             then there is only 1 missingElement          
                                    else{                                                          else
                                        return String.valueOf(missingStart) + "->"                        there is missing range from missingStart to missingEnd
                                               + String.valueOf(missingEnd);
                                
                                }
    
            Time:O(n)
            Space:O(1)
            */
            /*
            public int[]   arrayMissingDuplicate(int[] arr, int lower , int upper){
                List<String> result = new ArrayList<>();
                if (arr.length == 0){
                    result.add(formatRange(lower,upper));
                    return result;
                }
    
                if (arr[0] > lower){
                    result.add(formatRange(lower,arr[0]-1));
                }
    
                int ptr1 = 0;
                int ptr2 = 1;
                while(ptr2 <= arr.length-1){
                    if(arr[ptr2] - arr[ptr1]>= 2){
                        result.add(formatRange(arr[ptr1]+1, arr[ptr2]-1));
                    }
                    ptr1++;
                    ptr2++;
                }
    
                if (arr[arr.length-1] < upper){
                    result.add(formatRange(arr[arr.length-1]+1, upper));
                }
                return result;
            }
            
            private String formatRange(int missingStart, int missingEnd) {
                if (missingStart == missingEnd) {
                    return String.valueOf(missingStart);
                }
                else{
                    return String.valueOf(missingStart) + "->" + String.valueOf(missingEnd);
                }
            
            }
            */
    
            return null;
        }
    public void    arrayMissingDuplicate0ToN(int[] arr){
        /*
        QUESTION
            [0,2,2,3,4,5,6] --array has element in unsorted manner
                              array must have elements 0 to N=arr.length
                              return the missing and duplicate numbers
                              Eg: [0,2,2,3,4,4,6]  
                                missing  = [1,5,7]
                                duplicate = [2,4]
        */
    

        
        //USING MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)  -->Time:O(nlogn + n), Soace:O(1)
                                                                    // Multiple    :Array can have  multiple missing duplicates ; we can find multiple  missing,duplicates   
                                                                    // Manipulation :Array is changed
        /* 
        1.SORT ARRAY 
        [0,2,2,3,4,5,6] -->[0,2,2,3,4,5,6]

        2.SEARCH ARRAY WITH EXPECTED ARRAY
        [0,2,2,3,4,5,6]
            |
            ptr1
            0,1,2,3,4,5,6,7 (1 element will be extra)
            |
            ptr2     -- initilaise ptr1 to 0(arr ka ptr) ; initialise ptr2 to 1(expected nums ka ptr from 1 to arr.length)
                    int ptr1 = 0;
                    int ptr2 =0; 
                    while(ptr1 <= arr.length-1 && ptr2<= arr.length){ --move ptr1 till arr.length-1, ptr2 till arr.length
                                                                            (ptr1 at arr.lengh , cb ptr1 till arr.length-1,ca ptr1 till arr.length, ptr2 at arr.length+1,cb ptr2 till arr.length,ca ptr2 till arr.length )
                        if(arr[ptr1] < ptr2){                           if arr[ptr1] == ptr2                                       
                            duplicateList.add(arr[ptr1]);                   means element  is neither missing duplicate Eg::in above ptr1 at index 1 , ptr2 at index 1
                            ptr1++;                                        move ptr1 and ptr2 ahead
                        }
                        else if(arr[ptr1] >ptr2){                        else if arr[ptr1] < ptr2 
                            missingList.add(ptr2);                          means the element is duplicate Eg:in above eg ptr1 at index 2 , ptr2 at index 3       
                            ptr2++;                                         move ptr1 ahead                                                                       
                        }
                        else if(arr[ptr1] == ptr2){                     else if arr[ptr1] > ptr2 
                            ptr1++;                                           means the element is missing Eg:in above ptr1 at index 1 , ptr2 at index 1
                            ptr2++;                                           move ptr2 ahead
                        }                                               |
                                                                        else i because ptr1 [tr2 are modified inside and used as condition as well
                    }
                    
                    if(ptr1 <= arr.length-1){                         //null check if(ptr1<=arr1.length-1)  for ptr1 not reached end                                   
                        while(ptr1 <= arr.length-1){                   -->move ptr1 till arr.length
                                                                            (ptr1 at arr.lengt,cb ptr till arr.length-1,ca ptr till arr.length)
                            duplicateList.add(arr[ptr1]);                  ptr1 not reached end means it is duplicate number Eg consider [2,2] 0,1,2 then ptr1 at index 1 ptr2 at 2 then 2 is dplicate 
                            ptr1++;
                        }
                    }
                    if(ptr2 <= arr.length){                           //null check if(ptr1<=arr1.length-1)  for ptr2 not reached end
                        while(ptr2 <= arr.length){                      move ptr1 till arr.length for ptr2 not reached end 
                                                                        (ptr2 at arr.length+1,cb ptr till arr.length,ca ptr till arr.length+1)  
                            missingList.add(ptr2);                       ptr2++;  ptr2 not reached end means it is missing element Eg consider [0,2,2,3,4,5,6] 0,1,2,3,4,5,6,7 then ptr1 at index 7  ptr2 at index 7 then 7 is missing 
                        }   
                    }
        Time:O(nlogn + n) --nlogn for sort and n for search 
        Space:O(1)
        */
        /*
        List<Integer> missingList = new ArrayList<>();
        List<Integer> duplicateList = new ArrayList<>();
        int ptr1 = 0;
        int ptr2 =0; 
        while(ptr1 <= arr.length-1 && ptr2<= arr.length){
            if(arr[ptr1] == ptr2){
                ptr1++;
                ptr2++;
            }
            else if(arr[ptr1] < ptr2){
                duplicateList.add(arr[ptr1]);
                ptr1++;
            }
            else if(arr[ptr1] >ptr2){
                missingList.add(ptr2);
                ptr2++;
            }
            
            else if(arr[ptr1] == ptr2){
                ptr1++;
                ptr2++;
            }
        }
        if(ptr1 <= arr.length-1){
            while(ptr1 <= arr.length-1){
            duplicateList.add(arr[ptr1]);
            ptr1++;
            }  
        }
        if(ptr2 <= arr.length){
            while(ptr2 <= arr.length){
                missingList.add(ptr2);
                ptr2++;
            }   
        }
            
    
        return missingList;
        return duplicateList;
        
        */

    
        //USING MULTIPOINTER SWAPSORT SEARCH(ARRAY REQUIRES SORTING)   -->Time:O(n) , Space O(1)
        //                                                                 Multiple    :Array can have  multiple missing duplicates ; we can find multiple  missing,duplicates   
        //                                                                 Manipulation:Array is changed 
        /*
        SKIP
        int correctIndex = arr[ptr] -1 so the ip arr elements must be between [0 ,arr.length -1 
                                    Here the ip arr can have elements other than the range Eg [3,0,1] so for 0 correctIndex =1  is out of bounds
        */

        //USING HASHMAP(ARRAY REQUIRES STORING ELEMENTS)   -->Time:O(n);Space = O(n)
        //                                                    Multiple      :Array can have multiple missing and multiple duplicate ;we can find multiple missing and duplicates                  
        //                                                    Manipulation  :Array is unchanged
        /*
        LOOK IN HASHMAP HASHSET          
        */


                
        //USING  MATHS (ARRAY ELEMENTS HAVE PATTERN)                    -->Time:O(n) , Space O(1)
        //                                                                  Multiple      :Array can have multiple missing duplicate  ; we can find 1 missing and no duplicate so array must ave only 1 missing and no duplicate
        //                                                                   Manipulation  :Array is unchanged
        /*
        LOOK IN MATHS 
        */
        
        //USING  MATHS  BIT MANIPULATION(ARRAY ELEMENTS HAVE PATTERN)    -->Time:O(n) , Space O(1)
        //                                                                   Multiple     rray can have multiple missing duplicate  ; we can find 1 missing and no duplicate so array must ave only 1 missing and no duplicate
        //                                                                   Manipulation  :Array is unchanged
        /*
        LOOK IN MATHS 
        */

    
        }
    public void    arrayMissingDuplicate1ToN(int[] arr){
        /*
        QUESTION
        [1,2,3,4,4,4,7] --array has element in unsorted manner
                            array must have elements 1 to N=arr.length
                            return the missing and duplicate numbers
                            Eg: [1,2,3,4,4,4,7]  
                                missing  = [5,6]
                                duplicate = [4]
                            EG:[1,2,3,1,5,1,7,2]
                            missing = [4,6,8]
                            duplicate = [1,2]

        */
    
        //USING MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)  -->Time:O(nlogn + n), Soace:O(1)
                                                                    // Multiple    :Array can have  multiple missing duplicates ; we can find multiple  missing,duplicates   
                                                                    // Manipulation :Array is changed
        /* 
        1.SORT ARRAY 
        [1,2,4,3,7,4] -->[1,2,3,4,4,7]

        2.SEARCH ARRAY WITH EXPECTED ARRAY
        [1,2,3,4,4,7]
            |
            ptr1
            1,2,3,4,5,6
            |
            ptr2     -- initilaise ptr1 to 0(arr ka ptr) ; initialise ptr2 to 1(expected nums ka ptr from 1 to arr.length)
                    int ptr1 = 0;
                    int ptr2 =1; 
                    while(ptr1 <= arr.length-1 && ptr2<= arr.length){ --move ptr1 till arr.length-1, ptr2 till arr.length
                                                                            (ptr1 at arr.lengh , cb ptr1 till arr.length-1,ca ptr1 till arr.length, ptr2 at arr.length+1,cb ptr2 till arr.length,ca ptr2 till arr.length+1 )
                        if(arr[ptr1] == ptr2){                            if arr[ptr1] == ptr2 
                            ptr1++;                                         means element  is neither missing duplicate Eg::in above ptr1 at index 1 , ptr2 at index 1
                            ptr2++;                                         move ptr1 and ptr2 ahead
                        }    
                        else if arr[ptr1] < ptr2                                       
                            duplicateList.add(arr[ptr1]);                  means the element is duplicate Eg:in above eg ptr1 at index 4 , ptr2 at index 4
                            ptr1++;                                        move ptr1 ahead
                        }
                        else if(arr[ptr1] >ptr2){                        else if arr[ptr1] > ptr2 
                            missingList.add(ptr2);                          means the element is missing Eg:in above ptr1 at index 5 , ptr2 at index 4
                            ptr2++;                                         move ptr2 ahead
                        }
                                            |
                                                                        else i because ptr1 [tr2 are modified inside and used as condition as well
                    }
                    
                    if(ptr1 <= arr.length-1){                         //null check if(ptr1<=arr1.length-1)  for ptr1 not reached end                                   
                        while(ptr1 <= arr.length-1){                   -->move ptr1 till arr.length
                                                                            (ptr1 at arr.lengt,cb ptr till arr.length-1,ca ptr till arr.length)
                            duplicateList.add(arr[ptr1]);                  ptr1 not reached end means it is duplicate number Eg consider [2,2] 1,2 then ptr1 at index 1 ptr2 at index 3 then 2 is dplicate 
                            ptr1++;
                        }
                    }
                    if(ptr2 <= arr.length){                           //null check if(ptr1<=arr1.length-1)  for ptr1 not reached end
                        while(ptr2 <= arr.length){                      move ptr1 till arr.length for ptr2 not reached end 
                                                                        (ptr2 at arr.length+1,cb ptr till arr.length,ca ptr till arr.length+1)  
                            missingList.add(ptr2);                       ptr2++;  ptr2 not reached end means it is missing element Eg consider [1,2,3,4,4,4] 1,2,3,4,5,6 then ptr1 at index arr.length  ptr2 at index 4 then 5 ,6 is missing 
                        }   
                    }
        Time:O(nlogn + n) --nlogn for sort and n for search 
        Space:O(1)
        */
        /*
        List<Integer> missingList = new ArrayList<>();
        List<Integer> duplicateList = new ArrayList<>();
        int ptr1 = 0;
        int ptr2 =1; 
        while(ptr1 <= arr.length-1 && ptr2<= arr.length){
            if(arr[ptr1] == ptr2){
                ptr1++;
                ptr2++;
            }
            else if(arr[ptr1] < ptr2){
                duplicateList.add(arr[ptr1]);
                ptr1++;
            }
            else if(arr[ptr1] >ptr2){
                missingList.add(ptr2);
                ptr2++;
            }
            
        }
        if(ptr1 <= arr.length-1){
            while(ptr1 <= arr.length-1){
            duplicateList.add(arr[ptr1]);
            ptr1++;
            }  
        }
        if(ptr2 <= arr.length){
            while(ptr2 <= arr.length){
                missingList.add(ptr2);
                ptr2++;
            }   
        }
            
    
        return missingList;
        return duplicateList;
        
        */

        //USING MULTIPOINTER SWAPSORT SEARCH(ARRAY REQUIRES SORTING)   -->Time:O(n) , Space O(1)
        //                                                                 Multiple    :Array can have  multiple missing duplicates ; we can find multiple  missing,duplicates   
        //                                                                 Manipulation:Array is changed      
        /*

        1.SORT ARRAY USING SWAP SORT
        [2,3,5,1,5,]   -- [1,2,3,1,5]   -- while ptr <= arr.length-1   |--arr[ptr] -1
        0  1 2 3 4        0 1 2 3 4           if(arr[ptr] != arr[correctIndex ])
        ptr                                           swap ptr with correct index
                                                else 
                                                move ptr fwd-------------------------
                                                                                        |
        2.CHECK FOR MISSING AND DUPLICATES                                              |
        [1,2,3,1,5]                       -- iterate over array                         |
        0 1 2 3 4                            if arr[i] ! i+1                           |
                                                    duplicateList.add(arr[i])           |
                                                    missingList.add(i+1)                |
                                                                                        |
                                                                                    EXPLANATION   
                                                                                    if element not not on correct index we swap
                                                                                    else element on correct index we move fwd and here the duplicate causes wrong index to be correct  but we still move fwd
                                                                                                                                    
                                                                                    
                                                                                    [2,3,5,1,5]   -----------    [3,2,5,1,5]------------  [5,2,3,1,5]-------------------[5,2,3,1,5]------
                                                                                    0 1 2 3 4    a[0]!=a[1]     |0,1,2,3,4  a[0]!=a[2]   |0 1 2 3 4  a[0]=a[4] on         |      
                                                                                    |            swap           |           swap         |           move ptr ahead       ptr
                                                                                    ptr                         ptr                      ptr        (DUPLICATE CAUSES
                                                                                                                                                    WRONG INDEX AS CORRECT)
                                                                                

        Time:O(n)   where n = length of array--> 2nd step is O(n)
        Space:O(1)                               1st step is O(n) 
                                                Arguement:In while in if you swap and dont do i++  so the swappingng may lead to O(n^2)
                                                Reason: If you swap to swap barbaad nahi jaa raha element apni jagah pe pohch gaya to aage future me vaha swap
                                                        karna nahi padega aur else me jake i++ to O(n) se thoda jyada hoga par O(n^2) nahi
                                                        

        */    
        
        /*
        int ptr = 0;
        while(ptr <= arr.length-1){
            int correctIndex = arr[ptr] -1;
            if(arr[ptr] != arr[correctIndex]){
                //swap(arr , ptr , correctIndex);
            }
            else{
                ptr++;
            }
        }

        List<Integer> missingList = new ArrayList<>();
        List<Integer> duplicateList = new ArrayList<>();
        for(int i=0 ; i <= arr.length-1; i++){
            if(arr[i] != i+1){
            duplicateList.add(arr[i]);
                missingList.add(i+1);

            }
        }
    

    */


        //USING HASHMAP(ARRAY REQUIRES STORING ELEMENTS)      -->Time:O(n);Space = O(n)
        //                                                       Multiple      :Array can have multiple missing and multiple duplicate ;we can find multiple missing and duplicates                  
        //                                                       Manipulation  :Array is unchanged
        /*
        LOOK IN HASHMAP HASHSET          
        */


            
                
        //USING  MATHS(ARRAY ELEMENTS HAVE PATTERN)              -->Time:O(n) , Space O(1)
        //                                                          Multiple      :Array can have only multiple missing and multiple duplicate ;but we can find 1 missing and 1 duplicate(so array must have 1 missinga and 1 duplicate only)
        //                                                          Manipulation  :Array is unchanged
        /*
        LOOK IN MATHS
        
        */
        
        //USING  MATHS BIT MANIPULATION(ARRAY ELEMENTS HAVE PATTERN)    -->Time:O(n)  Space O(1) 
        //                                                                  Multiple      :Array can multiple missing duplicate; but we can use this only 1 missing 1 duplicate(so array must have 1 missinga and 1 duplicate only)
        //                                                                  Manipulation  :Array is unchanged
        /*
        LOOK IN MATHS
        */


    
        }
    public void    arrayMissingPositive1ToNPlus1(int[] arr){
        /*
        QUESTION
        [1,2,3,4,4,4,7] --array has element in unsorted manner
                            array must have elements 1 to N=arr.length[Question asks to find 1st missing +ve we made this conclusion looking at test cases like [1] -->1st missing +ve is 2 , [7,8,9,10] -->1st missing +ve is 1]
                            return the missing positives
                            Eg: [1,2,0]
                                missing positive  = [3,4]
                            EG:[3,4,-1,1]
                                missing positive  = [2,5]
                            EG:[7,8,9,10,11]
                                missingpositive = [1,2,3,4,5,6,7]

        */
        
        //USING MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)  -->Time:O(nlogn + n), Soace:O(1)
                                                                    // Multiple    :Array can have  multiple missing posotoves ; we can find multiple  missing positives
                                                                    // Manipulation :Array is changed
        /*
        
        1.SORT ARRAY 
        [3,4,-1,1] -->[-1,1,3,4]

        2.SEARCH ARRAY WITH EXPECTED ARRAY
        [-1,1,3,4]
            |
            ptr1
            1,2,3,4,5
            |
            ptr2     -- initilaise ptr1 to 0(arr ka ptr) ; initialise ptr2 to 1(expected nums ka ptr from 1 to arr.length+1)
    
                    while(ptr1 <= arr.length-1 && arr[ptr1] <=0){ --move ptr till arr.length and till 1st +ve value
                        ptr1++;                                     (ptr at arr.length , vb ptr till arr.length-1,ca ptr till arr.length) 
                    } 
                    
                    while(ptr1 <= arr.length-1 && ptr2<= arr.length+1){ --move ptr1 till arr.length , ptr2 till arr.length + 1
                                                                            (ptr1 at arr.length , cb ptr1 till arr.length-1,ca ptr1 till arr.length; ptr2 at arr.length+2,cb till arr.length+1,ca till arr.length+2)
                            if(arr[ptr1] == ptr2){                           if ptr1 == ptr2
                            ptr1++;                                         move ptr1 and ptr2 ahead Eg consider above Eg ptr1 at index 1 , ptr2 t index 0
                            ptr2++;
                        } 
                        else if(arr[ptr1] < ptr2){                        else if ptr1 < ptr2
                            //missingList.add(ptr2);                          means not missing
                            ptr1++;                                           move ptr1 ahead
                        }
                        else if(arr[ptr1] >ptr2){                         else if ptr1 >ptr2
                            missingList.add(ptr2);                            ptr2 is missing   Eg consider above  ptr1 at index 2 , ptr2 t index 1
                            ptr2++;                                           move ptr2 ahead
                        }

        
                    }
                    
                    if(ptr1 <= arr.length){                              //null check if(ptr1 < ptr2) for smaller arr 2
                        //do nothing                                      do nothing EG consider [1,7] [1,2,3] ptr1 at index 1 , ptr2 at index 3  
                    } 
                    if(ptr2 <= arr.length+1){                             //null check if(ptr1 < ptr2) for smaller arr 2
                        while(ptr2 <= arr.length+1){                        move ptr2 till arr.length+2
                            missingList.add(ptr2);                             ptr2 is missing EG consider [1,2] [1,2,3] ptr1 at index 3 ptr2 at index 3
                            ptr2++;                                            move ptr2 ahead
                            
                        }
                        
                    


        Time :O(nlogn + n), 
        Space:O(1)
        */
        /*
        Arrays.sort(arr);
        List<Integer> missingList = new ArrayList<>();
        
        //MOVE PTR1 TO 1ST +VE INT(NON 0)
        int ptr1 = 0; 
        int ptr2 = 1;    
        while(ptr1 <= arr.length-1 && arr[ptr1] <=0){
            ptr1++;
        } 
        
        while(ptr1 <= arr.length-1 && ptr2<= arr.length+1){
            if(arr[ptr1] == ptr2){
                ptr1++;
                ptr2++;
            } 
            else if(arr[ptr1] < ptr2){
                //missingList.add(ptr2);
                ptr1++;
            }
            else if(arr[ptr1] >ptr2){
                missingList.add(ptr2);
                ptr2++;
            }
                
        }
        
        if(ptr1 <= arr.length){
            //do nothing
        }
        if(ptr2 <= arr.length+1){
            while(ptr2 <= arr.length+1){
                missingList.add(ptr2);
                ptr2++;
                
            }
            
        }
    
        return missingList;
        */
        
                
        //                         __simiar to swap sort , instead of correct index we make corresponding index as -1
        //                        /     
        //USING MULTIPOINTER SWAP SORT(ARRAY REQUIRES SORTING)-->Time:O(n), Soace:O(1)
                                                                // Multiple    :Array can have  multiple missing positives ; we can find only 1st missing +ev 
                                                                    // Manipulation :Array is changed

                                                                                                                            
        /* 
        1.MAKE ALL 0 AND -VE AS +VE
        [3,4,-1,1] -->[3,4,5,1]
        |
        ptr        --initialise ptr to 0
                    while(ptr <= arr.length -1){          --move ptr till arr.length
                                                            (ptr at arr.length,cb ptr till arr.length-1,ca ptr till arr.length)
                        if(arr[ptr] <= 0){                 if arr[ptr] <= 0 
                            arr[ptr] = arr.length + 1;}        replace them with arr.length + 1 so that 0 and -ve numbers can be ignored in next pass ka condition
                        ptr++;
                    }



        2.MARK CORRESPONDING INDEX WITH -1
        [3,4,5,1]  -->[-3,-4,5-1]
            |
            ptr       --reanitilise ptr to 0
                    while(ptr <= arr.length -1){                                                  --move ptr till arr.length   
                                                                                                    (ptr at arr.length,cb ptr till arr.length-1,ca ptr till arr.length)
                        if(1 <= Math.abs(arr[ptr]) && Math.abs(arr[ptr]) <= arr.length){                if(1 <= arr[ptr]<= arr.length) make arr[ptr]-1 index as -ve
                            int correspondingIndex = Math.abs(arr[ptr]) - 1;                            Math.abs(arr[ptr])               :to prevent previous negation on next element EG because suppose you are at index 1 ie 4 hai ;so index 3 ko -ve karna hai ;so 1 will become -1 so when you reach -1 you will check arr[1] not arr[-1]
                            if(arr[correspondingIndex] >0){                                              if((arr[correspondingIndex] >0):To prevent double negation EG [1,1] -->[1,-1]-->[1,1] so 1 is negated twice when ptr at 0 and 1 shich we dont want
                                arr[correspondingIndex] = arr[correspondingIndex]*-1;}//[1,1]
                            }
                        ptr++;
                    }


        3.SEARCH ARRAY FOR INDEXES WITHOUT -VE NUMBER
        [-3,-4,5-1]    
            |
            ptr      --reanitilise ptr to 0
                    while(ptr <= arr.length-1){      --move ptr till arr.length   
                                                        (ptr at arr.length,cb ptr till arr.length-1,ca ptr till arr.length)
                        if(arr[ptr] >= 0){            if we find a find 0 or +ve number then the next index is missing number return it
                            missing = ptr+1;
                            return missing;
                        }
                        ptr++;
                    }
                    if(missing == -1){missing = arr.length+1;} -- if we do not find a missing number the arr.length+1 is missing because we have not checked this number as this number is out of bounds so we dont check in loop 
                                                                    



        Time:O(n)
        Space:O(1)
        */
        /*
        int ptr = 0;
        while(ptr <= arr.length -1){
            if(arr[ptr] <= 0){
                arr[ptr] = arr.length + 1;}
            ptr++;
        }
                
        ptr =0;
        while(ptr <= arr.length -1){        
            if(1 <= Math.abs(arr[ptr]) && Math.abs(arr[ptr]) <= arr.length){
                int correspondingIndex = Math.abs(arr[ptr]) - 1;
                if(arr[correspondingIndex] >0){arr[correspondingIndex] = arr[correspondingIndex]*-1;}//[1,1]
            }
            ptr++;
        }

        int missing = -1;
        ptr = 0;
        while(ptr <= arr.length-1){
            if(arr[ptr] >= 0){
                missing = ptr+1;
                return missing;
            }
            ptr++;
        }
        if(missing == -1){missing = arr.length+1;}
                
        return missing;
        
        */
    
    

        //USING HASHMAP(ARRAY REQUIRES STORING ELEMENTS)   -->Time:O(n);Space = O(n)
        //                                                     Multiple      :Array can have multiple missing positives ;we can find multiple missing positives                 
        //                                                     Manipulation  :Array is unchanged
        /*
        LOOK IN HASHMAP HASHSET          
        */

        //USING  MATHS BIT MANIPULATION(ARRAY ELEMENTS HAVE PATTERN)    -->Time:O(n)  Space O(1) 
        //                                                                  Multiple      :Array can multiple missing duplicate; but we can use this only 1 missing 1 duplicate(so array must have 1 missinga and 1 duplicate only)
        //                                                                  Manipulation  :Array is unchanged
        /*
        Skip
        */

    

    
    }
    public void    arrayNelementsPtimesOtherKtimes(int[] arr){
            /*
            Question
            [2,2,3,2] -- array has elements where  n elements appear p times and N-n elements appear k times, 
                        return element that appears p times
                        EG
                        [2,2,3,2] n=1,p = 1,k = 3         --means 1 element appears 1 time and other elements appear 3 times ; so return 3
                        [2,2,3,2,3,1,1,1] n=1,p = 2,k = 3 --means 1 element appears 2 time and other elements appear 3 times ; so return 3
                        [1,2,1,3,2,5]  n=2,p = 1,k = 2    --means 2 element appears 1 time and other elements appear 2 times ; so return [3,5] 

            
        */
        
        //USING MULTIPTR SORT AND SEARCH(ARRAY REQUIRES SORTING) -->Time:O(logn + n), Soace:O(1)
        //                                                           Multiple    :Array can have  multiple missing duplicates ; we can find multiple  missing,duplicates   
        //                                                           Manipulation :Array is changed
        /*
        1.SORT ARRAY
        [1,2,4,1,4] -->[1,1,2,4,4]

        2.SEARCH ARRAY
        [1,1,2,4,4]
        | |
        ptr1 ptr2       --initialise ptr1 , ptr2 to 0 
                        while(ptr1 <= arr.length-1){                                  --mpve ptr1 till arr.length
                                                                                        (ptr1 at arr.length,cb till arr.length-1 , ca till arr.length)
                            while(ptr2 <= arr.length-1 && arr[ptr1] == arr[ptr2]){   --move ptr till arr.length and till ptr1 == ptre
                                ptr2++;                                                (ptr1 at arr.length,cb till arr.length-1 , ca till arr.length)
                            }
                            if(ptr2 - ptr1 == p){                                      if ptr2 - ptr1 == p 
                                ptimes.add(arr[ptr1]);                                    means element is repeated p times
                            }
                            if(ptr2 - ptr1 == k){                                       if ptr2 - ptr1 == p      
                                ktimes.add(arr[ptr1]);                                     means element is repeated k times  
                            }
                            ptr1 = ptr2;                                                reassign ptr1 to ptr2
                            
                        } 
                                                                                        //null check if(ptr1<=arr1.length-1){} not req
                                                                                        //null check if(ptr2<=arr1.length-1){} not req
                    
                    return ptimes
                    return ktimes;
        
        
                                                                                                    


        */
        /*
        Arrays.sort(arr);
        
        List<Integer> ptimes = new ArrayList<>();
        List<Integer> ktimes = new ArrayList<>();
        
        
        int ptr1 =0;
        int ptr2 = 0;
        while(ptr1 <= arr.length-1){
            while(ptr2 <= arr.length-1 && arr[ptr1] == arr[ptr2]){
                ptr2++;
            }
            if(ptr2 - ptr1 == p){
                ptimes.add(arr[ptr1]);
            }
            else if(ptr2 - ptr1 == k){
                ktimes.add(arr[ptr1]);
            }
            
            ptr1 = ptr2;
            
        } 
        
        return ptimes/ktimes;
        
    }
    
    
        
        
        */
        
        //USING ARRAY SWAPSORT AND SEARCH(ARRAY REQUIRES SORTINH) -->Time:O(n) , Space O(1)
        //                                                           Multiple    :Array can have  multiple missing duplicates ; we can find multiple  missing,duplicates   
        //                                                           Manipulation:Array is changed 
        /*
        SKIP
        int correctIndex = arr[ptr] -1 so the ip arr elements must be between [0 ,arr.length -1 
                                    Here the ip arr can have elements other than the range Eg [3,7,7] so for 7 correctIndex =6  is out of bounds
        
        */

    
        //USING  HASHMAP(ARRAY REQUIRES STORING ELEMENTS)       -->Time:O(n)  Space O(n) 
        //                                                        Multiple      :Array can have n=anything,p=anything,k=anything; we can use this only for n=anything,p=anything,k=anything
        //                                                        Manipulation  :Array is unchanged
        /*
        LOOK IN HASHMAP HASHSET          
        */


        
                
        //USING  MATHS BIT MANIPULATION(ARRAY ELEMENTS HAVE PATTERN)     -->Time:O(n)  Space O(1) 
        //                                                                  Multiple      :AArray can have n=anything,p=anything,k=anything; but we can use this only for n=2,p=1,k=2.
        //                                                                  Manipulation  :Array is unchanged
        /*
        LOOK IN MATHS
        */ 
    
        //USING  MATHS BIT MANIPULATION(ARRAY ELEMENTS HAVE PATTERN)     -->Time:O(n)  Space O(1)   
        //                                                                   Multiple      :Array can have n=anything,p=anything,k=anything; but we can use this only for n=1,p=anything,k=anything
        //                                                                   Manipulation  :Array is unchanged  
        /*
        LOOK IN MATHS
        */
    
    }
    public int[]   arrayCompare2ArraysForIntersection(int[] arr1,int[] arr2){
        /*
        [3,3,1,2,4]  -->[3]   --find the intersection of array(intersection is common without any duplicates) in sorted manner
        [4,5,3,3,6]                                            
        */

        //USING MULTIPOINTERS SORT SEARCH (ARRAY REQUIRES SORTING) -->Time:O(n1logn1 + n2logn2 + n1 + n2) , Space:O(1)
        /*
        1.SORT ARRAYS
        [1,2,3,3,4] 
        [3,3,4,5,6] -- sort arrays
                                

        2.SEARCH ARRAY
         [1,2,3,3,4] [3,3,4,5,6]
         |            |
         ptr1         ptr2    --initialise ptr1 and ptr2 to 0
                                while(ptr1 <= arr1.length-1 && ptr2 <= arr2.length-1){          -- move ptr1 and ptr2 till arr.length
                                                                                                   (ptr1 at arr.length,cb till arr.length-1, ca till arr.length ; ptr2 at ...)
                                    if(arr1[ptr1] == arr2[ptr2]){                                     if ptr1 == ptr2
                                        result[ptr3] = arr1[ptr1];                                        add ptr1 to result
                                        ptr3++;                                                           move ptr3 ahead
                                                                                                          move ptr1 ahead till you have duplicates(intersection should not have duplicae)
                                        int tempptr1 = ptr1;              
                                        while(tempptr1 <= arr1.length-1 && arr1[tempptr1] == arr1[ptr1]){ add ptr2 to result
                                            tempptr1++;                                                    move ptr3 ahead
                                        }                                                                  move ptr2 ahead till you have duplicates(intersection should not have duplicae)
                                        ptr1 = tempptr1;                         
                                
                                        int tempptr2 = ptr2;     
                                        while(tempptr2 <= arr2.length-1 && arr2[tempptr2] == arr2[ptr2]){
                                            tempptr2++;
                                        }
                                        ptr2 = tempptr2;
                                    }
                                    else if(arr1[ptr1] < arr2[ptr2]){                                     else if ptr1 < ptr2                                                              
                                        int tempptr1 = ptr1;                                                   move ptr1 ahead till you have duplicates(intersection should not have duplicae)
                                        while(tempptr1 <= arr1.length-1 && arr1[tempptr1] == arr1[ptr1]){
                                            tempptr1++;
                                        }
                                        ptr1 = tempptr1;
                                    }
                                    else if(arr1[ptr1] > arr2[ptr2]){                                    else if ptr1 < ptr2          
                                        int tempptr2 = ptr2;                                                   move ptr2 ahead till you have duplicates(intersectio  should not have duplicae)
                                        while(tempptr2<= arr2.length-1 && arr2[tempptr2] == arr2[ptr2]){
                                            tempptr2++;
                                        }
                                        ptr2 = tempptr2;       
                                    }   
                                }
                                                                                                   
                                if(ptr1 <= arr1.length-1){                                            //null check if(ptr1<=arr1.length-1){} for smaller arr2                                                                         
                                    //do nothing                                                       do nothing as we are finding intersection
                                }
                                if(ptr2<= arr2.length-2){                                            //null check if(ptr2<=arr2.length-1){} for smaller arr1                             
                                    //do nothing                                                     do nothing as we are finding intersection
                                }
                                
                                return Arrays.copyOfRange(result,0,ptr3);                            //return arr from 0 to ptr3

        
        
        
        Time:O(logn1 + logn2 + n1 + n2) 
        Space:O(1)


        

        */
        Arrays.sort(arr1);
        Arrays.sort(arr2);
        
        int[] result = new int[arr1.length+arr2.length];
        int ptr1 = 0;
        int ptr2 = 0;
        int ptr3 =0;
        while(ptr1 <= arr1.length-1 && ptr2 <= arr2.length-1){
            
            if(arr1[ptr1] == arr2[ptr2]){
                result[ptr3] = arr1[ptr1]; 
                ptr3++;
                
                int tempptr1 = ptr1;  
                while(tempptr1 <= arr1.length-1 && arr1[tempptr1] == arr1[ptr1]){
                    tempptr1++;
                }
                ptr1 = tempptr1;
                
                
                int tempptr2 = ptr2;
                while(tempptr2 <= arr2.length-1 && arr2[tempptr2] == arr2[ptr2]){
                    tempptr2++;
                }
                ptr2 = tempptr2;
            }
            else if(arr1[ptr1] < arr2[ptr2]){
                int tempptr1 = ptr1;
                while(tempptr1 <= arr1.length-1 && arr1[tempptr1] == arr1[ptr1]){
                    tempptr1++;
                }
                ptr1 = tempptr1;
            }
            else if(arr1[ptr1] > arr2[ptr2]){
                int tempptr2 = ptr2;
                while(tempptr2<= arr2.length-1 && arr2[tempptr2] == arr2[ptr2]){
                    tempptr2++;
                }
                ptr2 = tempptr2;
                
            }
            
            
        }
        
        if(ptr1 <= arr1.length-1){
            //do nothing
        }
        if(ptr2 <= arr2.length-1){
            //do nothing
        }
        
        return Arrays.copyOfRange(result,0,ptr3);

        
        
        
        //USING HASHMAP -->Time:O(n1+n2 + n1logn1 + n2logn2),Space:O(n) 
        /*
        LOOK IN HASHMAP
         */
        
        
        
    }
    public int[]   arrayCompare2ArraysForCommon(int[] arr1,int[] arr2){
        /*
        [3,3,1,2,4]  -->[3,3,6]   --find the common of array(common is common with duplicates) in sorted manner
        [4,5,3,3,6]  
        */

        //USING MULTIPOINTERS SORT SEARCH (ARRAY REQUIRES SORTING) -->Time:O(n1logn1 + n2logn2 + n1 + n2) , Space:O(1)
        /*
        1.SORT ARRAYS
        [1,2,3,3,4] 
        [3,3,4,5,6] -- sort arrays
                                

        2.SEARCH ARRAY
         [1,2,3,3,4] [3,3,4,5,6]
         |            |
         ptr1         ptr2    --initialise ptr1 and ptr2 to 0
                                while(ptr1 <= arr1.length-1 && ptr2 <= arr2.length-1){          -- move ptr1 and ptr2 till arr.length
                                                                                                   (ptr1 at arr.length,cb till arr.length-1, ca till arr.length ; ptr2 at ...)
                                    if(arr1[ptr1] == arr2[ptr2]){                                     if ptr1 == ptr2
                                        result[ptr3] = arr1[ptr1];                                        add ptr1 to result
                                        ptr3++;                                                           move ptr3 ahead
                                        ptr1++;                                                           move ptr1 (common can have duplicate)
                                
                                        result[ptr3] = arr1[ptr2];                                        add ptr2 to result
                                        ptr3++;                                                           move ptr3 ahead
                                        ptr1++;                                                           move ptr2 (common can have duplicae)
                                
                                    }
                                    else if(arr1[ptr1] < arr2[ptr2]){                                     else if ptr1 < ptr2
                                        ptr1 ++;                                                             move ptr1 ahead (common can have duplicae)
                                    }
                                    else if(arr1[ptr1] > arr2[ptr2]){                                    else if ptr1 < ptr2
                                        ptr2 ++;                                                               move ptr1 ahead (common can have duplicae)   
                                    }   
                                }
                                                                                                   
                                if(ptr1 <= arr1.length-1){                                            //null check if(ptr1<=arr1.length-1){} for smaller arr2                                                                         
                                    //do nothing                                                       do nothing as we are finding intersection
                                }
                                if(ptr2<= arr2.length-2){                                            //null check if(ptr2<=arr2.length-1){} for smaller arr1                             
                                    //do nothing                                                     do nothing as we are finding intersection
                                }
                                
                                return Arrays.copyOfRange(result,0,ptr3);                            //return arr from 0 to ptr3
        
        
        
        Time:O(logn1 + logn2 + n1 + n2) 
        Space:O(1)


        

        */


        Arrays.sort(arr1);
        Arrays.sort(arr2);
        
        int ptr1 = 0;
        int ptr2 = 0;
        int ptr3 = 0;
        int[] result = new int[arr1.length+arr2.length];
        
        while(ptr1 <= arr1.length-1 && ptr2 <= arr2.length-1){
            
            if(arr1[ptr1] == arr2[ptr2]){
                result[ptr3] = arr1[ptr1];
                ptr3++;


                ptr1++;
                ptr2++;
            }
            else if(arr1[ptr1] < arr2[ptr2] ){
                ptr1++;  
                
                
            }
            else if(arr1[ptr1] > arr2[ptr2]){
                ptr2++; 
                
            }
            
            
            
        }
        
        if(ptr1 <= arr1.length-1){
            //do nothing
        }
        if(ptr2 <= arr2.length-1){
            //do nothing
        }
        
        return Arrays.copyOfRange(result,0,ptr3);
        
        //USING HASHMAP -->TTime:O(n1+n2 + n1logn1 + n2logn2),Space:O(n) 
        /*
        Look in hashmap
        */

        
        
    }
    public int[]   arrayCompare2ArraysForUnion(int[] arr1,int[] arr2){
        /*
        [3,3,1,2,4]  -->[1,2,3,4,5,6]   --find the union of array(union is merging without any duplicates) in sorted manner
        [4,5,3,3,6]     
        */

        //USING MULTIPOINTERS SORT SEARCH (ARRAY REQUIRES SORTING) -->Time:O(n1logn1 + n2logn2 + n1 + n2) , Space:O(1)
        /*
        1.SORT ARRAYS
        [1,2,3,3,4] 
        [3,3,4,5,6] -- sort arrays
                                

        2.SEARCH ARRAY
         [1,2,3,3,4] [3,3,4,5,6]
         |            |
         ptr1         ptr2    --initialise ptr1 and ptr2 to 0
                                while(ptr1 <= arr1.length-1 && ptr2 <= arr2.length-1){          -- move ptr1 and ptr2 till arr.length
                                                                                                   (ptr1 at arr.length,cb till arr.length-1, ca till arr.length ; ptr2 at ...)
                                    if(arr1[ptr1] == arr2[ptr2]){                                     if ptr1 == ptr2
                                        result[ptr3] = arr1[ptr1];                                        add ptr1 to result
                                        ptr3++;                                                           move ptr3 ahead
                                                                                                          move ptr1 ahead till you have duplicates(union should not have duplicae)
                                        int tempptr1 = ptr1;              
                                        while(tempptr1 <= arr1.length-1 && arr1[tempptr1] == arr1[ptr1]){ add ptr2 to result
                                            tempptr1++;                                                    move ptr3 ahead
                                        }                                                                  move ptr2 ahead till you have duplicates(union should not have duplicae)
                                        ptr1 = tempptr1;                         
                                
                                        int tempptr2 = ptr2;   
                                        while(tempptr2 <= arr2.length-1 && arr2[tempptr2] == arr2[ptr2]){
                                            tempptr2++;
                                        }
                                        ptr2 = tempptr2;
                                    }
                                    else if(arr1[ptr1] < arr2[ptr2]){                                     else if ptr1 < ptr2
                                        result[ptr3] = arr1[ptr1];                                           add ptr1 to result
                                        ptr3++;                                                              move ptr3 ahead
                                                                                                             move ptr1 ahead till you have duplicates(union should not have duplicae)
                                        int tempptr1 = ptr1;
                                        while(tempptr1 <= arr1.length-1 && arr1[tempptr1] == arr1[ptr1]){
                                            tempptr1++;
                                        }
                                        ptr1 = tempptr1;
                                    }
                                    else if(arr1[ptr1] > arr2[ptr2]){                                    else if ptr1 < ptr2
                                        result[ptr3]  = arr2[ptr2];                                        add ptr1 to result
                                        ptr3++;                                                            move ptr3 ahead
                                                                                                           move ptr2 ahead till you have duplicates(union should not have duplicae)
                                        int tempptr2 = ptr2; 
                                        while(tempptr2<= arr2.length-1 && arr2[tempptr2] == arr2[ptr2]){
                                            tempptr2++;
                                        }
                                        ptr2 = tempptr2;       
                                    }   
                                }
                                                                                                   
                                if(ptr1 <= arr1.length-1){                                            //null check if(ptr1<=arr1.length-1){} for smaller arr2                                                                         
                                    while(ptr1 <= arr1.length-1){                                    move ptr1 till arr1.length
                                                                                                     (ptr1 at arr1.length , cb ptr1 till arr1.length-1,ca ptr till arr1.length)
                                        result[ptr3] = arr1[ptr1];                                          add ptr1 to result
                                        ptr3++;                                                             move ptr3
                                                                                                             move ptr1 ahead till you have duplicates(union should not have duplicae)
                                        int tempptr1 = ptr1;
                                        while(tempptr1 <= arr1.length-1 && arr1[tempptr1] == arr1[ptr1]){
                                            tempptr1++;
                                        }
                                        ptr1 = tempptr1;
                                    }
                                }
                                if(ptr2<= arr2.length-2){                                            //null check if(ptr2<=arr2.length-1){} for smaller arr1                             
                                    while(ptr1 <= arr1.length-1){                                    move ptr2 till arr2.length
                                                                                                     (ptr2 at arr,length , cb ptr1 till arr.length-1,ca ptr till arr.length)
                                        result[ptr3] = arr2[ptr2];                                          add ptr1 to result
                                        ptr3++;                                                             move ptr3
                                                                                                             move ptr1 ahead till you have duplicates(union should not have duplicae)
                                        int tempptr2 = ptr2;
                                        while(tempptr2 <= arr2.length-1 && arr2[tempptr2] == arr1[ptr1]){
                                            tempptr2++;
                                        }
                                        ptr2 = tempptr2;
                                    }
                                }
                                
                                return Arrays.copyOfRange(result,0,ptr3);                            //return arr from 0 to ptr3

        
        
        
        Time:O(logn1 + logn2 + n1 + n2) 
        Space:O(1)


        

        */

        Arrays.sort(arr1);
        Arrays.sort(arr2);
        
        int[] result = new int[arr1.length+arr2.length];
        int ptr1 = 0;
        int ptr2 = 0;
        int ptr3 =0;
        while(ptr1 <= arr1.length-1 && ptr2 <= arr2.length-1){
            
            if(arr1[ptr1] == arr2[ptr2]){
                result[ptr3] = arr1[ptr1]; 
                ptr3++;
                
                int tempptr1 = ptr1; 
                while(tempptr1 <= arr1.length-1 && arr1[tempptr1] == arr1[ptr1]){
                    tempptr1++;
                }
                ptr1 = tempptr1;
                
                
                int tempptr2 = ptr2;  
                while(tempptr2 <= arr2.length-1 && arr2[tempptr2] == arr2[ptr2]){
                    tempptr2++;
                }
                ptr2 = tempptr2;
            }
            else if(arr1[ptr1] < arr2[ptr2]){
                result[ptr3] = arr1[ptr1];
                ptr3++;
                
                int tempptr1 = ptr1; //union doesnt have  duplicate
                while(tempptr1 <= arr1.length-1 && arr1[tempptr1] == arr1[ptr1]){
                    tempptr1++;
                }
                ptr1 = tempptr1;
            }
            else if(arr1[ptr1] > arr2[ptr2]){
                result[ptr3]  = arr2[ptr2];
                ptr3++;
                
                int tempptr2 = ptr2; //union doesnt have  duplicate
                while(tempptr2<= arr2.length-1 && arr2[tempptr2] == arr2[ptr2]){
                    tempptr2++;
                }
                ptr2 = tempptr2;
                
            }
            
            
        }
        
        if(ptr1 <= arr1.length-1){
            while(ptr1 <= arr1.length-1){
                result[ptr3] = arr1[ptr1];
                ptr3++;
                
                int tempptr1 = ptr1;
                while(tempptr1 <= arr1.length-1 && arr1[tempptr1] == arr1[ptr1]){
                    tempptr1++;
                }
                ptr1 = tempptr1;
            }
        }
        if(ptr2 <= arr2.length-1){
            
            while(ptr2 <= arr2.length-1){
                result[ptr3] = arr2[ptr2];
                ptr3++;
                
                int tempptr2= ptr2;
                while(tempptr2 <= arr2.length-1 && arr2[tempptr2] == arr2[ptr2]){
                    tempptr2++;
                }
                ptr2 = tempptr2;
            }
        }
        
        return Arrays.copyOfRange(result,0,ptr3);

        //USING HASHMAP(ARRAY REQUIRES STORING  ) ->Time:O(n1+n2 + n1logn1 + n2logn2),Space:O(n)  
        /*
        LOOK IN HASHMAP
         */
        

        
    }
    public int[]   arrayCompare2ArrayForMergingI(int[] arr1, int[] arr2) {
        /*
        [3,3,1,2,4]  -->[1,2,3,3,3,3,4,5,6]   --find the merge of array(merge is merging with duplicates) in sorted manner
        [4,5,3,3,6]                             merge the arrays in result arr
        */

     
        //USING MULTIPOINTERS SORT SEARCH (ARRAY REQUIRES SORTING) -->Time:O(n1logn1 + n2logn2 + n1 + n2) , Space:O(1)
        /*
        1.SORT ARRAYS
        [1,2,3,3,4] 
        [3,3,4,5,6] -- sort arrays
                                

        2.SEARCH ARRAY
         [1,2,3,3,4] [3,3,4,5,6]
         |            |
         ptr1         ptr2    --initialise ptr1 and ptr2 to 0
                                while(ptr1 <= arr1.length-1 && ptr2 <= arr2.length-1){          -- move ptr1 and ptr2 till arr.length
                                                                                                   (ptr1 at arr.length,cb till arr.length-1, ca till arr.length ; ptr2 at ...)
                                    if(arr1[ptr1] == arr2[ptr2]){                                     if ptr1 == ptr2
                                        result[ptr3] = arr1[ptr1];                                        add ptr1 to result
                                        ptr3++;                                                            move ptr3 ahead
                                        ptr1++;                                                            move ptr1 ahead(merging can have duplicate)
                                        
                                        result[ptr3] = arr1[ptr1];                                        add ptr2 to result
                                        ptr3++;                                                           move ptr3 ahead
                                        ptr2++;                                                           move ptr2 ahead(merging can have duplicate)
     
                                    }
                                    else if(arr1[ptr1] < arr2[ptr2]){                                     else if ptr1 < ptr2
                                        result[ptr3] = arr1[ptr1];                                           add ptr1 to result
                                        ptr3++;                                                              move ptr3 ahead
                                        ptr1++;                                                              move ptr2 ahead(merging can have duplicate)
                                    }
                                    else if(arr1[ptr1] > arr2[ptr2]){                                    else if ptr1 < ptr2
                                        result[ptr3]  = arr2[ptr2];                                        add ptr1 to result
                                        ptr3++;                                                            move ptr3 ahead
                                        ptr2++;                                                            move ptr2 ahead(merging can have duplicate)   
                                    }   
                                }
                                                                                                   
                                if(ptr1 <= arr1.length-1){                                           //null check if(ptr1<=arr1.length-1){} for smaller arr2                                                                         
                                    while(ptr1 <= arr1.length-1){                                    move ptr1 till arr1.length
                                                                                                     (ptr1 at arr1.length , cb ptr1 till arr1.length-1,ca ptr till arr1.length)
                                        result[ptr3] = arr1[ptr1];                                          add ptr1 to result
                                        ptr3++;                                                             move ptr3
                                        ptr1++;                                                             move ptr1 ahead(merging can have duplicate)
                                }
                                if(ptr2<= arr2.length-2){                                            //null check if(ptr2<=arr2.length-1){} for smaller arr1                             
                                    while(ptr1 <= arr1.length-1){                                    move ptr2 till arr2.length
                                                                                                     (ptr2 at arr,length , cb ptr1 till arr.length-1,ca ptr till arr.length)
                                        result[ptr3] = arr2[ptr2];                                          add ptr1 to result
                                        ptr3++;                                                             move ptr3
                                        ptr2++;                                                             move ptr2 ahead(merging can have duplicate)
                                    }
                                }
                                
                                return Arrays.copyOfRange(result,0,ptr3);                              return arr from 0 to ptr3 exclusive

        
        
        
        Time:O(logn1 + logn2 + n1 + n2) 
        Space:O(1)


        

        */
        Arrays.sort(arr1);
        Arrays.sort(arr2);         

        int ptr1 = 0; 
        int ptr2 =0;
        int ptr3 = 0;
        int[] result = new int[arr1.length+arr2.length];
        while (ptr1 <= arr1.length-1 && ptr2 <= arr2.length-1) {
            if(arr1[ptr1 ] == arr2[ptr2]){
                result[ptr3] = arr1[ptr1];
                ptr3++;
                result[ptr3] = arr2[ptr2];
                ptr3++;
                
                ptr1++;
                ptr2++;
            }
            else if (arr1[ptr1] < arr2[ptr2]){
                result[ptr3] = arr1[ptr1];
                ptr3++;
                
                ptr1++; 
            
            }
            else if (arr2[ptr2] < arr1[ptr1]){
                result[ptr3] = arr2[ptr2];
                ptr3++;
                
                ptr2++;
            }
        }
        if(ptr1 <= arr1.length-1){                 
            while (ptr1 <= arr1.length-1){
                result[ptr3] = arr1[ptr1];
                ptr3++;
                
                ptr1++;
            }
        }
        if( ptr2 <= arr2.length-1){      
            while (ptr2 <=arr2.length-1){
                result[ptr3] = arr2[ptr2];
                ptr3++;
                
                ptr2++;
            }
        }
         
         return Arrays.copyOfRange(result,0, ptr3);
   
        
        //USING HASHMAP-->Time:O(n1 + n2 + n1logn1 + n2logn2 ) , Space:O(n)
        /*
        Look in hashmap
        */

    }
    public int[]   arrayCompare2ArrayForMergingII(int[] arr1, int[] arr2,int m ,int n) {
        /*
        [1,2,3,0,0,0]  -->[1,2,2,3,5,6]   --find the merge of array(merge is merging with duplicates) in sorted manner
        [2,5,6]                              merge the result in arr1; arr1 has m elements of arr1 and n zeros to accomodate n elements of arr2
        */

     
        //USING MULTIPOINTERS SORT SEARCH (ARRAY REQUIRES SORTING) -->Time:O(n1logn1 + n2logn2 + n1 + n2) , Space:O(1)
        /*
        1.SORT ARRAYS
        [1,2,3,0,0,0]     --sort  arr1 0 to m exclusive because if you sort entire arr1 you will get 0's at beginning which isnt desired 
        [2,5,6]             sort arr2 entirely
                                

        2.SEARCH ARRAY
         [1,2,3,0,0,0] [2,5,6]
                |   |       |
              ptr1  ptr3    ptr2   
                               --initialise ptr1 to m-1 , ptr2 to n-1 ptr3 to arr1.length-1 (FOR IN PLACE ARRAY REPLACEMENT ALWAYS THINK STARTING PTR FROM BEHIND)
                                while(ptr1 >=0 && ptr2 >=0){                      --move ptr1 and ptr2 till 0
                                                                                    (ptr1 at 1; cb ptr1 enc ill 0 ca ptr1 enc till -1; ptr2....)
                                    if(arr1[ptr1] == arr2[ptr2]){                     if ptr1 == ptr2
                                        arr1[ptr3] = arr1[ptr1];                        add ptr1 at ptr3
                                        ptr3--;                                         move ptr3 behind           
                                        ptr1--;                                         move ptr1 behing(merging allows duplicate)

                                        arr1[ptr3] = arr2[ptr2];                        add ptr1 at ptr3
                                        ptr3--;                                         move ptr3 behind  
                                        ptr2--;                                         move ptr2 behing(merging allows duplicate)       
                                    }
                                    else if(arr1[ptr1] < arr2[ptr2]){                 else if ptr1 < ptr2
                                        arr1[ptr3] = arr2[ptr2];                         add ptr2 to ptr3
                                        ptr3--;                                          move ptr3 behind
                                        ptr2--;                                          move ptr1 behing(merging allows duplicate)
                                    }
                                    else if(arr1[ptr1]> arr2[ptr2] ){                else if ptr1 < ptr2
                                        arr1[ptr3] = arr1[ptr1];                       add ptr1 to ptr3
                                        ptr3--;                                        move ptr3 behind
                                        ptr1--;                                        move ptr1 behind(merging allows duplicate)
                                    }
                                }

                                if(ptr1 >= 0){                                   //null check if(ptr1>=0) as ptr1 has not reahced -1 and ptr2 has  reached -1  EG [1,2,3,0,0,0]  [4,5,6]  --> [1,2,3,4,5,6] [4,5,6]                                                                                
                                    //do nothing                                   do nothing as elements of arr2 will be added after elements of arr1                 p1           p2             p1      p2  
                                }
                                if (ptr2 >=0){                                 //null check if(ptr2>=0) as ptr1 has  reahced -1 and ptr2 has not reached -1  EG  [4,5,6,0,0,0]  [1,2,4]    --> [4,5,6,4,5,6] [1,2,3]                                                                                                                                                                                     
                                    while(ptr2 >=0){                                move ptr2 till -1                                                                  p1            p2       p1                  p2                  
                                        arr1[ptr3] = arr2[ptr2];                    add ptr2 to ptr3
                                        ptr3--;                                     move ptr3 behind
                                        ptr2--;                                    move ptr1 behind(merging allows duplicate)
                                    }
                                }
       
                              return arr1                                      return arr1

        
        
        
        Time:O(logn1 + logn2 + n1 + n2) 
        Space:O(1)


        

        */
        Arrays.sort(arr1,0,m);
        Arrays.sort(arr2); 
        

       int ptr1 = m-1; 
       int ptr2 =n-1;
       int ptr3 = arr1.length-1;
    
       
       while(ptr1 >=0 && ptr2 >=0){
           if(arr1[ptr1] == arr2[ptr2]){                
               arr1[ptr3] = arr1[ptr1];
               ptr3--;
               ptr1--;

               arr1[ptr3] = arr2[ptr2];
               ptr3--;
               ptr2--;   
           }
           else if(arr1[ptr1] < arr2[ptr2]){
               arr1[ptr3] = arr2[ptr2];
               ptr3--;
               ptr2--;
           }
           else if(arr1[ptr1]> arr2[ptr2] ){
               arr1[ptr3] = arr1[ptr1];
               ptr3--;
               ptr1--; 
           }
           
           
           
       }
       if(ptr1 >= 0){
           //do nothing
       }
       if (ptr2 >=0){
           while(ptr2 >=0){
               arr1[ptr3] = arr2[ptr2];
               ptr3--;
               ptr2--;
           }
       }
       
       return arr1;

       //USING HASHMAP-->Time:O(n1 + n2 + n1logn1 + n2logn2 ) , Space:O(1)
       /*
       Look in hashmap
       */

   

   }
    public double  arrayCompare2ArrayForMedian(int[] arr1 , int[] arr2){
        /*
        Question
        [1,3]  -- merge the 2 arrays and find the median(mid = (int)l+r/2   For odd: median = arr[mid] or even median = arr[mid] + arr[mid+1]/2 )
        [2]
        */

        //USING MULTIPOINTERS SORT + SEARCH (ARRAY REQUIRES SORTING) -->Time:O(n1logn1 + n2logn2 + n1 + n2) , Space:O(1)
        /*
        [1,3]   --[1,2,3] -- merge arrays
        [2]                  if even 
                                median = mid1+ mid2/2
                             if odd
                                 median = mid
                            return median

        
        Time:O(n1logn1 + n2logn2 + n1 + n2) 
        Space:O(1)                           
        
        */
        int[] res = arrayCompare2ArrayForMergingI(arr1,arr2);
        
        double median = (double)0.0;
        if(res.length %2 == 0){
            int mid1 = (int)((res.length -1)/2); 
            int mid2 = (int)((res.length -1)/2) + 1; 
            
            median = ((double)(res[mid1]) + (double)(res[mid2]))/2.0;
            
        }
        else{
            int mid1 = (int)((res.length -1)/2); 
            median = (double)res[mid1];
        }
        
        return median;



        //USING ARRAY --MULTIPTR SORT + BINARY SEARCH(ARRAY IS SORTED) --> Time: O(lonn1 + log n2 + log(min of m,n) ), Space:O(1)
        //                                                                 IF WE HAVE 2 SORTED ARRAYS IN SORT + SEARCH WE DO NOT TAKE ADV OF FACT THAT ARR ARE SORTED SO WE USE BS ;BS IS HEPFUL AS TIME COMPLEXITY WILL CHANGE FROM O(n+m ) to (log(min of m,n))

        /*
        
        Look in multiptr sort + BS
        */
        



    }
    public boolean stringCompare2StringForIsomorphic(String s1, String s2) {
        /*
        "egg"  -- check if s1 s2 are isomporphic
        "add"     all characters in s1 can be mapped to characters in s2 preserving the order
                  no 2 characters can be mapped to same characters
        
                  EG: "egg", "add"           -- true
                      "egcd"  "adfd"         -- false
                      "bbbaaaba" "aaabbbba"  --false
                      
        */
        
        //USING MULTIPTR SORT SEARCH
        /*
        Not applicable
        */
        return true;
        
        //USING HASHMAP
        /*
        Look in HashMap
         */

    }
    public boolean stringCompare2StringsForAnagram(String s1 , String s2){
        /*
        Question
        s1 = "abcde" -- compare s1 and s2
        s2 = "dbace"    and find if s2 is a anagram of s1((anagram means same characters in hjumbled sequence)

                 
        */
        
        //USING -MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES COMPARISION FOR  2 ARRAYS) -->Time: O(nlogn + n); Space:O(1)
        /*
        1.SORT ARRAY
        "abc"   --['a','b','c']    --convert to array and  sort array    
        "cba"     ['a','b','c'] 

        2.SEARCH ARRAY
        ['a','b','c']      
        ['a','b','c'] 
         |           
        ptr1 ,ptr2    --while(ptr1 <= arr1.length()-1 &&  ptr2 <= arr2.length()-1){  -->move ptr1 ptr2 till  arr1.length , arr2.length which is null
                            if(arr1[ptr1] != arr2[ptr2]){                   (ptr1,ptr2 reach at arr1.length,equivalent char and exit; code before moving ptr encounter till arr1.length-1,equivalent char ; code after moving ptr encounter arr1.length,eq char [arr1 small; vice versa arr2 is small] )
                                return false;}                               
                            ptr1++;
                            ptr2++;
                        }

                        if(ptr1<=arr1.length-1){              //null check if(ptr1<=arr1.length-1){}  for smaller arr2
                                return false;}  
                        if(ptr2<=arr2.length-1){              //null check if(ptr2<=arr1.length-1){}  for smaller arr1
                            return false;}   

                        return true;
 

        
        Time :O(nlog n + n)
        Space:O(1)
        */ 
        char[] arr1 = s1.toCharArray();
        char[] arr2 = s2.toCharArray();
        
        Arrays.sort(arr1);
        Arrays.sort(arr2);
        
        
        int ptr1 = 0;
        int ptr2 = 0;
        
        while(ptr1 <= arr1.length-1 && ptr2 <= arr2.length -1){
            if(arr1[ptr1] != arr2[ptr2]){
                  return false;
            }
            
            ptr1++;
            ptr2++;
        }
        

        
        if(ptr1 <= arr1.length-1){
                return false;
        }
        if(ptr2 <= arr2.length-1){
                return false;
        }
        
        return true;

        //USING HASHMAP -->Time: O(n); Space:O(n)
        /*
        Look in hashmap
        
        
        */


        
        
        //USING MATHS BIT MANIPULATION(ARRAY ELEMENTS HAVE PATTERN) -->Time: O(n); Space:O(1)  XXX CANT USE 
        /*
        LOOK IN MATHS
        */
        
    }
    public char    stringCompare2StringsForAnagramWithOneExtraCharacter(String s1 , String s2){
        /*
        Question
        s1 = "abcde" -- compare s1 and s2 which are anagram with 1 extra characrer
        s2 = "dbafce"   find and return extra character                 
                 
        */
        
        
        //USING -MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)-->Time: O(nlogn + n); Space:O(1)
        /*
        1.SORT ARRAY
        "abc"   --['a','b','c']    --convert to array and  sort array    
        "cba"     ['a','b','c'] 

        2.SEARCH ARRAY
        ['a','b','c']      
        ['a','b','c','l'] 
         |           
        ptr1 ,ptr2    - while(ptr1 <= arr1.length()-1 &&  ptr2 <= arr2.length()-1){  -->move ptr1 ptr2 till  arr1.length , arr2.length which is null
                            if(arr1[ptr1] != arr2[ptr2]){                              (ptr1,ptr2 reach at arr1.length,equivalent char and exit; code before moving ptr encounter till arr1.length-1,equivalent char ; code after moving ptr encounter arr1.length,eq char [arr1 small; vice versa arr2 is small] )
                                int largerArray = (arr1.length > arr2.length) ? 1:2;
                                if(largerArray == 1)
                                        return arr1[ptr2];
                                if(largerArray == 2)
                                        return arr2[ptr2];
                                                                 
                            ptr1++;
                            ptr2++;
                        }

                        if(ptr1<=arr1.length-1){              //null check if(ptr1<=arr1.length-1){}  for smaller arr2
                            return arr1[ptr1];;}  
                        if(ptr2<=arr2.length-1){              //null check if(ptr2<=arr1.length-1){}  for smaller arr1
                            return arr2[ptr2]}   

                        return Character.MIN_VALUE;
 

        
        Time :O(nlog n + n)
        Space:O(1)
        */ 
        char[] arr1 = s1.toCharArray();
        char[] arr2 = s2.toCharArray();
        Arrays.sort(arr1);
        Arrays.sort(arr2);
        
        
        int ptr1 = 0;
        int ptr2 = 0;
        
        while(ptr1 <= arr1.length-1 && ptr2 <= arr2.length -1){
            if(arr1[ptr1] != arr2[ptr2]){
                  int largerArray = (arr1.length > arr2.length) ? 1:2;
                  if(largerArray == 1)
                        return arr1[ptr2];
                  if(largerArray == 2)
                        return arr2[ptr2];
                      
                
            }
            
            ptr1++;
            ptr2++;
            
                   
            
            
            
        }
        

        
        if(ptr1 <= arr1.length-1){
                return arr1[ptr1];
            }
        if(ptr2 <= arr2.length-1){
                return arr2[ptr2];
            }
        
        return Character.MIN_VALUE;
            
        
        
        

        //USING MATHS BIT MANIPULATION(ARRAY ELEMENTS HAVE PATTERN) -->Time: O(n); Space:O(1)
        /*
        LOOK IN MATHS
        */
        
        
        
    }
    
   


    //ARRAY - MULTIPOINTERS SORT+SEARH(BS)
    /*
    IDENTIFY
    ARRAY IS SORTED                                -->: Binary search will be used as you dont want to do linear search
    ARRAY IS UNSORTED AND MAXIMISE MINIMUM ETC    --> Binary search will be used on result space

    MIDDLE ,PREVIOUS ,NEXT
    mid = (int)(l + r)/2  = (int)(l + (r-l)/2)    //null check: (int)l + (r-l)/2 will prevent overflow   Eg consider int size to be 5 not 10^9  ;(l+r)/2  = (3+5)/2  8/2    8 >5 so overfof ;l + (r-l)/2  = 3 + (2)/2   no overflow her
    previous = mid-1                              //null check :mid-1, mid+1 may go out of bounds so check for mid = 0 and arr.length-1 
    next     = mid+1                                   
                                                    
 

    

    */
    public int    arraySortedAscendingFindElement(int[] arr , int item){
        /*
        QUESTION
        [1,2,3,4,5,6,7,8] -- SORTED ARRAY : array with elements in  ascending order
                             FIND: Find the element in it
        */
        
        //USING MULTIPOINTERS BINARY SEARCH(Array is sorted) -->TIME:O(logn),Space:O(1)
        //                                                      Array has duplicate elements : Will give any occurence mid first encounters  
        /*
        [1,2,3,4,5,6,7,8,9]  
            |       |       |
            left   middle  right   --> while left <= right    (left , right at left > right , cb left right enc till left == right ;ca enc till left >right)
                = (l+r)/2            middle = l + (r-l)/2  
                                        if item == middle     
                                            ret middle
                                        if item < middle
                                        check on left by reassign right = middle-1
                                    if item > middle
                                        check on right by reassign left = middle+1
                                        return -1

                                   

            Time : O(logn) as we reduce n(length of array ) by half
            Space: O(1)
            */

        int left = 0;
        int right = arr.length-1;

        while (left<= right){
            int middle = left + (right-left)/2;  ;
            if(arr[middle] == item)
                return middle;

            else if(item > arr[middle] ){
                left = middle+1; }

            else if(item < arr[middle] ){
                right = middle-1;}
        }
        return -1;
        }
    public int    arraySortedDescendingFindElement(int[] arr , int item){
        /*
    QUESTION
    [8,7,6,5,4,3,2,1] -- DESCENDING SORTED ARRAY : array with elements sorted in  descending  order
                            FIND: Find the element in it
    */
    
        //USING MULTIPOINTERS BINARY SEARCH(Array is sorted) -->TIME:O(logn),Space:O(1)
        //                                                    Array has duplicate elements : Will give any occurence mid first encounters  
        /*
        [9,8,7,6,5,4,3,2,1]
            |       |       |
            left   middle  right   --> while left <= right     (left , right at left > right , cb left right enc till left == right ;ca enc till left >right)
                = (l+r)/2               middle = l + (r-l)/2  
                                        if item == middle     
                                            ret middle
                                        if item < middle
                                            check on right by reassign left = middle+1
                                         if item > middle
                                            check on right by reassign right = middle-1
                                        return -1


            Time : O(logn) as we reduce n(length of array ) by half
            Space: O(1)
            */
        
        int left = 0;
        int right = arr.length-1;
        

        while (left<= right){
            int middle = left + (right-left)/2;  
            if(arr[middle] == item)
                return middle;

            if(item < arr[middle] ){
                left = middle+1;}

            else if(item > arr[middle] ){
                right = middle-1;}
        }
        return -1;



    }
    public int    arraySortedUnknownFindElement(int[] arr , int item){
        /*
        QUESTION
        [1,2,3,4,5,6,7,8] -- UNKNOWN SORTED ARRAY : array with elements sorted in ascending or maybe descending we dont know
                                FIND: Find the element in it
        */
        
        //USING MULTIPOINTERS BINARY SEARCH(Array is sorted) -->TIME:O(logn),Space:O(1)
        //                                                    Array has duplicate elements : Will give any occurence mid first encounters  
        /*
        [1,2,3,4]   ----         if arr[0] < arr[arr.length-1]     //arr[0] < arr[arr.length-1] not a[0] < a[1] as 1st and secind element might be same    
                                    binarysearch for  asc sorted       
                                else if arr[0] > arr[arr.length-1]                                    
                                    binary search for desc sorted  
                                elseif  arr[0] == arr[arr.length-1]
                                    binary search for any  sorted array will work as all elements are same
                                return -1



            Time : O(logn) as we reduce n(length of array ) by half
            Space: O(1)
        */

            

        if(arr[0] < arr[arr.length-1]){
            return arraySortedAscendingFindElement(arr,item);
        }
        else if(arr[0] > arr[arr.length-1]){
            return arraySortedDescendingFindElement(arr, item);
        }
        else if(arr[0] == arr[arr.length-1]){
            return arraySortedAscendingFindElement(arr,item);
        }

        return -1;


    }
    public int    arraySortedFirstLastOccurence(int[] arr , int item){
        /*
        QUESTION
        [1,2,3,4,5,6,6,6,7,8] -- SORTED ARRAY : array with elements in  ascending order
                                 FIND: Find 1st occurence of item and last occurence of item
        */
    
        //USING MULTIPOINTERS BINARY SEARCH(Array is sorted) -->TIME:O(logn),Space:O(1)
        //                                                     Array has duplicate elements : Will give 1st and last occurence
        /*
        [1,2,3,4,4,4,5,6,7]
            |       |       |           result = -1
            left   middle  right   --> while left <= right         (left , right at left > right , cb left right enc till left == right ;ca enc till left >right)
                = (l+r)/2              middle = l + (r-l)/2  
                                        if item == middle     
                                            for 1st occurence do not return middle ;but store it in result which you will return at end and continue continue check on left by reassign right = middle-1
                                            for last occurence do not return middle; but store it in result which you will return at end and continue continue check on right by reassign left = middle-1
                                        if item < middle
                                            check on left by reassign right = middle-1
                                        else if item > middle
                                            check on right by reassign left = middle+1

                                        return result
                                    //EDGE CASES:
                                        LEFT ,RIGHT  GO OUT OF BOUND
                                        left = mid +1 go out of bond: Handled as while(left <=right) wont allow to enter as left will go ahead of right
                                        right = mid -1 go out of bind:  Handled as while(left <=right) wont allow to enter as right will go behind of left 
                                        

                                    
                                    ARRAY EDGE CASE
                                    Array has 0,1  element       : Handled as l<=r = allows to enter loop if there is 1 element also
                                    Array has duplicate elements : Handled as it will search required item as per required occurence
                                    Array does not have req item : Handled by return -1 
        
            Time : O(logn) as we reduce n(length of array ) by half
            Space: O(1)
        */

        int left = 0;
        int right = arr.length-1;

        

        int result = -1;
        while (left<= right){
            int middle = left + (right-left)/2;  ;
            if(arr[middle] == item){
                result =  middle;
                right = middle -1;  // 1st occurence
                //left = middle + 1; //last occurence
            }
        
            else if(item > arr[middle] ){
                left = middle+1; }

            else if(item < arr[middle] ){
                right = middle-1;}
        }
        return result;

    }
    public int    arraySortedFindInsertionIndex(int[] arr , int item){
        /*
           QUESTION
           [1,2,3,4,5,6,7,8] -- SORTED ARRAY : array with elements in  ascending order
                                FIND: Find the element in it and if element not present find
                                      the index where it must be inserted 
                                      Eg:[1,3,5,6], item = 7 -->4
                                         [1,3,5,6], item = 0 -->0
           */
           
           //USING MULTIPOINTERS BINARY SEARCH(Array is sorted) -->TIME:O(logn),Space:O(1)
           //                                                      Array has duplicate elements : Will give any occurence mid first encounters  
   
           //USING MULTIPOINTERS BINARY SEARCH(Array is sorted) -->TIME:O(logn),Space:O(1)
           //                                                      Array has duplicate elements : Will give any occurence mid first encounters  
           /*
           [1,2,3,4,5,6,7,8,9]  
               |       |       |
               left   middle  right   --> while left <= right    (left , right at left > right , cb left right enc till left == right ;ca enc till left >right)
                   = (l+r)/2            middle = l + (r-l)/2  
                                           if item == middle     
                                               ret middle
                                           if item < middle
                                               check on left by reassign right = middle-1
                                           if item > middle
                                               check on right by reassign left = middle+1
                                           
                                           return left -->"IF ELEMENT NOT FOUND THEN LEFT WILL BE ON POS WHERE IT MUST BE INSERTED "
                                                          Explanation
                                                          If element is not present then l,r,m will be on same element at last step
                                                          If mid < target then left moves to mid+1  right stays at mid ; In this case  mid+1 is the index where insertion must take place
                                                          If mid > target then right moves to mid-1 left stays at mid; in this case mid is the index where insertion takes place 
                                                          Hence left holds the index where insertion takes place
                                                          
                                                          Eg:
                                                          [1,3,4,5,5]  target = 2 -- right moves to mid-1 left stays at mid; In this case  mid is the index where insertion must take place
                                                             |
                                                             l,m,r

                                                          [1,2,4,5,6]  target = 3 -- left moves to mid+1 right stays at mid; In this case  mid+1  is the index where insertion must take place
                                                             |
                                                             l,m,r
   
                                      
   
               Time : O(logn) as we reduce n(length of array ) by half
               Space: O(1)
               */
   
           int left = 0;
           int right = arr.length-1;
   
           while (left<= right){
               int middle = left + (right-left)/2;  ;
               if(arr[middle] == item)
                   return middle;
   
               else if(item > arr[middle] ){
                   left = middle+1; }
   
               else if(item < arr[middle] ){
                   right = middle-1;}
           }
           return left;
           
           
           
       }
    public int    arraySortedFrequencyCountOfItem(int[] arr , int item){
        /*
        QUESTION
        [1,2,3,4,5,6,6,6,7,8] -- SORTED ARRAY : array with elements in  ascending order
                                 FIND: Find no of  occurence of item
        */


        //USING MULTIPOINTERS BINARY SEARCH(Array is sorted) -->TIME:O(logn),Space:O(1)
        //                                                     Array has duplicate elements : Will find no of occuremce
        /*
        [1,2,3,4,4,4,7,8,9]
        |        |       |           
        left    middle   right   -->firstOccurence = findElementOccurenceInAcsendingSortedArray() 
            = (l+r)/2               lastOccurence = findElementOccurenceInAcsendingSortedArray()
                                    if lastoccurence and firstoccurence ret -1 
                                         element does notexist then count =0
                                    else
                                        count =  lastOccurence - firstOccurence + 1



        Time : O(logn) as we reduce n(length of array ) by half
        Space: O(1)
        */

        var firstOccurence = arraySortedFirstLastOccurence(arr, item);
        var lastOccurence = arraySortedFirstLastOccurence(arr, item);
        var count =0;
        if(firstOccurence == -1 || lastOccurence == -1){
            count =0;}
        else{
            count = lastOccurence - firstOccurence + 1;
        }

        return count;







    }
    public int    arraySortedFloorCeilOfItem(int[] arr , int item){

        /*
        QUESTION
        [1,2,3,4,8,10,12,15]-- SORTED ARRAY : array with elements in  ascending order
                               FIND: floor : greatest element in arr smaller than or equal to item  Eg item = 13 floor  = 12
                                     ceil  :smallest element in arr  greater than or equal to item  Eg item = 13 ceil = 15
                                
        */
        
        //USING MULTIPOINTERS BINARY SEARCH(Array is sorted) -->TIME:O(logn),Space:O(1)
        //                                                     Array has duplicate elements : Will find  the occurence mid encounters 1st 
        /*
        [1,2,4,5,9,10,12,19,21]  
        |       |          |
        left   middle    right --> while left <= right          (left , right at left > right , cb left right enc till left == right ;ca enc till left >right)
                = (l+r)/2            middle = l + (r-l)/2  
                                    if item == middle     
                                        ret middle
                                    if item < middle
                                        check on left by reassign right = middle-1
                                        while moving on left(smallest element) every mid > item(greater than item) is a candidate for ceil so store in result
                                    if item > middle
                                        check on right by reassign left = middle+1
                                        while moving on right(greatest  element) every mid < item(smaller than item) is a candidate for floor so store in result
                                    return -1

        
        
        Time : O(logn) as we reduce n(length of array ) by half
        Space: O(1)
        */

        int left = 0;
        int right = arr.length-1;
        int storerForFloor = -1;
        int storerForCeil = -1;

        while (left<= right){
            int middle = left + (right-left)/2;  ;
            if(arr[middle] == item)
                return middle;

            else if(item > arr[middle] ){
                //storerForFloor = middle;
                left = middle+1; }

            else if(item < arr[middle] ){
                storerForCeil = middle;
                right = middle-1;}
        }
        //return storerForFloor;
        return storerForCeil;
        }
    public int    arraySortedPreviousNextOfItem(char[] arr ,char item){
        /*
        QUESTION
        [a,b,c,d,f,h,j,l,o]-- SORTED ARRAY : array with elements in  ascending order
                              FIND: previous:greatest element "strictly smaller than and not equal to" item Eg for f prev  =d
                                    next    :smallest element "strictly greater than and not equal to" item  Eg for f next = h

                                
        */
        
        //USING MULTIPOINTERS BINARY SEARCH(Array is sorted) -->TIME:O(logn),Space:O(1)
        //                                                     Array has duplicate elements : Will find  the occurence mid encounters 1st 
        /*
        [a,b,c,d,h,j,l,o]  
        |     |       |
        left  middle   right--> while left <= right        (left , right at left > right , cb left right enc till left == right ;ca enc till left >right) 
            = (l+r)/2            middle = l + (r-l)/2  
                                    if item == middle     
                                        do not return middle as next prev are char only "greater/smaller" and not "greater/smaller than or equal to"  like floor ceil 
                                        for previous  check on left by reassign right = middle-1
                                        for next check on check on right by reassign left = middle+1
                                    if item < middle
                                        check on left by reassign right = middle-1
                                        while moving on left(smallest element) every mid > item(greater than item) is a candidate for next  so store in result
                                    if item > middle
                                        check on right by reassign left = middle+1
                                        while moving on right(greatest  element) every mid < item(smaller than item) is a candidate for previous so store in result
                                    return -1

        
        
        Time : O(logn) as we reduce n(length of array ) by half
        Space: O(1)
        */


        int left = 0;
        int right = arr.length-1;
        int storerForPrevious = -1;
        int storerForNext = -1;

        while (left<= right){
        int middle = left + (right-left)/2;  ;
        if(arr[middle] == item)
            //left = middle + 1;
            right = middle -1;

        else if(item > arr[middle] ){
            //storerForPrevious = middle;
            left = middle+1; }

        else if(item < arr[middle] ){
            storerForNext = middle;
            right = middle-1;}
        }
        //return storerForPrevious;
        return storerForNext;
    }
    public int    arraySortedMinimumDifferenceWithItem(int[] arr, int item){ 
        /*
        QUESTION
        [1,2,3,4,5,6,9] -- SORTED ARRAY : array with elements in  ascending order
                            FIND: find the element index that give minimum absolute difference with item
                                  Eg 1-7 = 6 ; 2-7 = 5 ; 3-7 = 4 ; 4-7 = 3 ; 5-7 = 2; 6-7 = 1 7-7 = 8 8 - 7 = 1  so 7 
        
         */  

        //USING MULTIPOINTERS BINARY SEARCH(Array is sorted) -->TIME:O(logn),Space:O(1)
        //                                                     Array has duplicate elements : Will find  the occurence mid encounters 1st 
        /*
        [1,2,3,4,5,6,9]  
        |       |          |
        left   middle    right --> find the floor of item ie for 7 it is 6    
                = (l+r)/2          find the ceil of item ie for 7 it is 9
                                   return floor or ceil depending on which gives min difference  

    

        Time : O(logn) as we reduce n(length of array ) by half
        Space: O(1)*/


        int floor = arraySortedFloorCeilOfItem(arr , item);
        int ceil = arraySortedFloorCeilOfItem(arr, item);

        int diff1 = Math.abs(item - arr[floor]);
        int diff2 = Math.abs(item - arr[ceil]);
        return diff1 <=  diff2 ? floor: ceil;

    
    }
    public int    arraySortedInfiniteFindElement(int[] arr , int item){
        /*
        QUESTION
        [1,2,3,4,5,6,9...] -- INFINITE SORTED ARRAY : array with elements in  ascending order and infinite elements
                              FIND:  element in array
        */  

        //USING MULTIPOINTERS BINARY SEARCH(Array is sorted) -->TIME:O(logn),Space:O(1)
        //                                                     Array has duplicate elements : Will find  the occurence mid encounters 1st 
        /*
        [1,2,3,4,5,6,7,8,........] 
        |  |
    left right                     -- left = 0 ; right = 1
                                        while(arr[right] <=item){              (right at rght > item , cb right enc till right = item, ca right enc till right > item) 
                                            place left bound at rightbound  
                                            double right bound
                                        }

                                        Binary search from left to right

    
            Time : O(logn) as we reduce n(length of array ) by half
            Space: O(1)
            */

        int left = 0;
        int right = 1;

        while(arr[right] >= item){
            left = right;
            right = right*2;
        }


        return arraySortedAscendingFindElement(Arrays.copyOfRange(arr, left , right+1), item);

    }
    public int    arraySortedInfiniteBinaryFirstLastOccurenceOf1(int[] arr){
        /*
        QUESTION
        [0,0,0,0,0,0,1,1,1,1,.....] -- INFINITE SORTED BINART ARRAY : array with elements in  ascending order and infinite elements and 0 1 only
                                      FIND:  first and last occurence of 1
        */  

        //USING MULTIPOINTERS BINARY SEARCH(Array is sorted) -->TIME:O(logn),Space:O(1)
        //                                                     Array has duplicate elements : Will find  the occurence mid encounters 1st 
        /*
        [0,0,0,0,0,0,1,1,1,1,.....]
        |  |
        left right                     -- left = 0 ; right = 1
                                        while(arr[right] != 1){
                                            place left bound at rightbound  
                                            double rightbound
                                        }

                                        FirstOccurence and LastOccurence  Binary  search from left to right

                
    
        Time : O(logn) as we reduce n(length of array ) by half
        Space: O(1)
        */


        int left = 0;
        int right = 1;

        while(arr[right] != 1){
            left = right;
            right = right *2;
        }


        return arraySortedFirstLastOccurence(Arrays.copyOfRange(arr,left , right +1 ), 1);
        }
    public int    arrayNearlySortedFindElement(int[] arr , int item){
        /*
        QUESTION
        [5,10,30,20,40] -- NEARLY SORTED ARRAY :correct element might be at index i ; i+ 1 or i-1 ie 5 must be at 0 is at 0 ;30 must be at 3 but is at 3-1 = 2
                          FIND: Element 
        */

        

        //USING MULTIPOINTERS BINARY SEARCH(Array is almost sorted) -->TIME:O(logn),Space:O(1)
        //                                                             Array has duplicate elements : Will find  the occurence mid encounters 1st 
        /*  
        [5,10,30,20,40]  
        |     |       |
        left  middle  right   --> while left <= right                                 (left , right at left > right , cb left right enc till left == right ;ca enc till left >right) 
                = (l+r)/2           middle = l + (r-l)/2                 
                                    previous = mid-1                               
                                    next = mid + 1   
                                    if(mid == 0)                                  //null check :mid-1, mid+1 may go out of bounds so check for mid = 0 and arr.length-1 
                                        return arr[0] == item ?0:-1;
                                    if(mid == arr.length-1)
                                        return arr[arr.length-1] == item ?arr.length-1:-1;
    
                                    
                                    if item == middle    
                                        ret middle
                                    if item = next
                                        ret next
                                    if item = previous
                                        ret previous
                                    else if item < middle
                                        check on left by reassign right = middle-2
                                    else if item > middle
                                        check on right by reassign left = middle+2
                                    return -1

                                    
            Time : O(logn) as we reduce n(length of array ) by half
            Space: O(1)
            */
        int left = 0;
        int right = arr.length -1;
        while(left <= right ){
            int mid = left + (right - left)/2;
            int previous =mid-1;
            int next = mid+1;
            if(mid == 0)
                return arr[0] == item ?0:-1;
            if(mid == arr.length-1)
                return arr[arr.length-1] == item ?arr.length-1:-1;


            if(arr[mid] == item){
                return mid;
            }
            if(arr[previous] == item){
                return previous;
            }
            if(arr[next] == item){
                return next;
            }

            else if(arr[mid] < item){
                left = mid + 2;
            }
            else if(arr[mid] > item){
                right = mid -2;
            }

        }

        return -1;





    }
    public int    arrayMountainBitonicPeakElement(int[] arr){
        /*
        QUESTION
        [1,3,8,12,4,2] -- MOUNTAIN BITONIC ARRAY: array that has strictly increasing elements upto max and then strictly decreasing elements after that 
                          FIND : peak element is an element that is strictly  greater than all elemnts on its left and right                                
                                 for index 0 to be peak arr[0] > arr[1] and arr.length-1 to be peak arr[length-1] > arr[length-2]  
        */

        //USING MULTIPOINTERS BINARY SEARCH(Array is almost sorted) -->TIME:O(logn),Space:O(1)
        //                                                             Array has duplicate elements :Will give the 1st peak  element mid finds
        /*
        [1,3,8,12,4,2]
        |   |       | 
    left   mid   right --         while(left<=right){                                  (left , right at left > right , cb left right enc till left == right ;ca enc till left >right) 
                                    int mid = left + (right-left)/2;
                                    previous = mid-1                                  
                                    next = mid + 1   
                                    if(mid == 0){                                   //null check :mid-1, mid+1 may go out of bounds so check for mid = 0 and arr.length-1 
                                        if(arr.length == 1){return 0;}
                                            return arr[0] >= arr[1] ? 0:1;
                                    }
                                    if(mid == arr.length-1){
                                        if(arr.length == 1){return 0;}
                                        return arr[arr.length-1] >= arr[arr.length-2] ? arr.length-1:arr.length-2;
                                    }
            

                                    if(arr[mid] >= arr[prev] && arr[mid] >= arr[next]){  
                                        means mid is the max element 
                                        return mid;
                                    }
                                    else if(arr[mid] >= arr[prev] && arr[mid] <= arr[next]){
                                        means arr is rising so 
                                        check on right by reassigning left = mid+1;
                                    }
                                    else if(arr[mid] <= arr[prev] && arr[mid] >= arr[next] ){
                                        means arr is declining
                                        check on left by reassigning right = mid-1;
                                    }
                                    else if(arr[mid] >= arr[prev] && arr[mid] <= arr[next]){
                                        //not possible
                                    }
                            
                                    
                                
                                }



        
        Time : O(logn) as we reduce n(length of array ) by half
        Space: O(1)

        
        */
            
        int left = 0;
        int right = arr.length-1;
        
        while(left<=right){
            int mid = left + (right-left)/2;
            int prev = mid-1 ;                                
            int next = mid + 1   ;
            if(mid == 0){                                   
                if(arr.length == 1){return 0;}
                    return arr[0] >= arr[1] ? 0:1;
            }
            if(mid == arr.length-1){
                if(arr.length == 1){return 0;}
                return arr[arr.length-1] >= arr[arr.length-2] ? arr.length-1:arr.length-2;
            }


            if(arr[mid] >= arr[prev] && arr[mid] >= arr[next]){
                return mid;
            }
            else if(arr[mid] >= arr[prev] && arr[mid] <= arr[next]){
                left = mid+1;
            }
            else if(arr[mid] <= arr[prev] && arr[mid] >= arr[next] ){
                right = mid-1;
            }
            else if(arr[mid] >= arr[prev] && arr[mid] <= arr[next]){
                //not possible
            }
    
            
           
        }
        
        
        return -1;
    }
    public int    arrayMountainBitonicFindElement(int[] arr, int item){
        /*
        QUESTION
        [1,3,8,12,4,2] --  MOUNTAIN BITONIC ARRAY: array that has strictly increasing elements upto max and then strictly  decreasing elements after that 
                            FIND : element
        */


        //USING MULTIPOINTERS BINARY SEARCH(Array is almost sorted) -->TIME:O(logn),Space:O(1)
        //                                                             Array has duplicate elements :Will give the 1st element mid finds
        /*
        [1,3,8,12,4,2]      -- maxIndex = arrayMountainBitonicPeakElement(arr);   
        |    |    |           index1 = arraySortedAscendingFindElement(0 to maxIndex)        
        left mid  right       index2 =  arraySortedAscendingFindElement(maxIndex to arr.length-1 )   
                              if  indexOfArr1 != -1 && indexOfArr2 !=-2
                                   means  found in both arr return any index
                               if indexOfArr1 != -1 && indexOfArr2 == -1
                                   means found in 1st array retuen index1
                                if indexOfArr1 == -1 && indexOfArr2 != -1
                                   means found in 1st array retuen index1
                                indexOfArr1 == -1 && indexOfArr2 == -1
                                        means found in none of the array return -1


                


        Time : O(logn) as we reduce n(length of array ) by half
        Space: O(1)
        */
    


        int maxIndex = arrayMountainBitonicPeakElement(arr);
        int indexOfArr1 = arraySortedAscendingFindElement(Arrays.copyOfRange(arr, 0, maxIndex+1),item);
        int indexOfArr2 = arraySortedDescendingFindElement(Arrays.copyOfRange(arr, maxIndex+1, arr.length),item);

        int index = -1;
        if(indexOfArr1 != -1 && indexOfArr2 != -1){
            index =  indexOfArr1;
        }
        if(indexOfArr1 != -1 && indexOfArr2 == -1){
            index =  indexOfArr1;
        }
        else if(indexOfArr1 == -1 && indexOfArr2 != -1){
            index =  indexOfArr2;
        }
        else if(indexOfArr1 == -1 && indexOfArr2 == -1){
            index = -1;
        }

        return index;



    }
    public int    arrayRotatedSortedMinElement(int[] arr){

        /*
        QUESTION
        [3,4,5,6,1,2] -- Array can be left rotated 2 times [3,4,5,6,1,2]  OR  right rotated 2 [5,6,1,2,3,4] 
                         find min element
        */

        //USING MULTIPOINTERS BINARY SEARCH(Array is almost sorted) -->TIME:O(logn),Space:O(1)
        //                                                             Array has duplicate elements :Will give the 1st element mid finds
        //                                                            (doing with duplicates is HARD PROBLEM)
        /*                                                                      
                                                                                
        [3,4,5,6,1,2]          -- while left <=right                                         (left , right at left > right , cb left right enc till left == right ;ca enc till left >right)                 
        |    |    |                 mid = left + (right - left)/2;                              
        left mid  right             int prev = mid-1 ;
                                    int next = mid+1;
                                    if(mid == 0){                                            //null check :mid-1, mid+1 may go out of bounds so check for mid = 0 and arr.length-1 
                                        if(arr.length == 1){return 0;}
                                        return arr[0] >= arr[1] ? 1:0;
                                    }
                                    if(mid == arr.length-1){
                                        if(arr.length == 1){return 0;}
                                        return arr[arr.length-1] >= arr[arr.length-2] ? arr.length-2:arr.length-1;
                                    }
                                    if left <= right
                                        means left ptr is at min  break here              
                                    if mid <= previous && mid <= next
                                        means mid is at  min element 
                                        return min
                                    else if  mid >= left(left not prev)
                                        means unsorted part of array is on right of mid and min element is always in unsorted array
                                         move on right by left = mid + 1;
                                    else if  mid <= right(right not next)
                                        means unsorted part of array is on left of mid and min element is always in unsorted array
                                         move on left by right = mid - 1;



                                            
                                
            Time : O(logn) as we reduce n(length of array ) by half
            Space: O(1)
        */
        int left =0;
        int right =arr.length-1;
        int minIndex = -1;

        while(left <= right){
            int mid = left + (right - left)/2;
            int prev = mid-1;
            int next =mid+1;
            if(mid == 0){
                if(arr.length == 1){return 0;}
                return arr[0] >= arr[1] ? 1:0;
            }
            if(mid == arr.length-1){
                if(arr.length == 1){return 0;}
                return arr[arr.length-1] >= arr[arr.length-2] ? arr.length-2:arr.length-1;
            }
            
            
            if(arr[left] <= arr[right]){
                return left;
            }
         
            if(arr[mid] <= arr[prev] && arr[mid] <= arr[next]){
                return mid;
            }
            else if(arr[mid]>=arr[left]){
                left = mid+1;
            }
            else if(arr[mid] <= arr[right] ){
                right = mid-1;
            }
           
        }

        return minIndex;




    }
    public int    arrayRotatedSortedNoOfRotations(int[] arr){
        /*
        QUESTION
        [3,4,5,6,1,2] -- Array can be left rotated 2 times [3,4,5,6,1,2]  OR  right rotated 2 [5,6,1,2,3,4] 
                         find no of rotations 
            */
    

        //USING MULTIPOINTERS BINARY SEARCH(Array is almost sorted) -->TIME:O(logn),Space:O(1)
        //                                                             Array has duplicate elements :Will give the 1st element mid finds
        /*
        [3,4,5,6,1,2]          --  if arr[left] <= arr[arr.length]
        |    |    |                    means array not rotated  minIndex = 0;noOfRotation = minIndex
        left mid  right            if arr[0] <= arr[arr.length-1] 
                                        means array is right rotated[5,6,1,2,3,4] noOfRotation = minIndex
                                    if arr[0] >= arr[arr.length-1] 
                                        means array is left rotated[3,4,5,6,1,2] noOfRotation =arr.length - minIndex   
                                                


                                

        Time : O(logn) as we reduce n(length of array ) by half
        Space: O(1)
        
        */
        int left = 0;
        int right = arr.length;
        int noOfRotations = 0;
        int minIndex = arrayRotatedSortedMinElement(arr);
        if(arr[left] <= arr[arr.length]){  
            noOfRotations = 0;
        }

        else if(arr[0] <= arr[arr.length-1]){ 
        noOfRotations =minIndex;
        }
        else{                                 
            minIndex = (arr.length - minIndex)%arr.length;
        }

        return noOfRotations;
    }
    public int    arrayRotatedSortedFindElements(int[] arr , int item){
        /*
        QUESTION
        [3,4,5,6,1,2] -- Array can be left rotated 2 times [3,4,5,6,1,2]  OR  right rotated 2 [5,6,1,2,3,4] 
                         find element 
        */


        //USING MULTIPOINTERS BINARY SEARCH(Array is almost sorted) -->TIME:O(logn),Space:O(1)
        //                                                             Array has duplicate elements :Will give the 1st element mid finds
        /*
        [3,4,5,6,1,2]      -- minIndex = arrayRotatedSortedMinElement(arr);   
        |    |    |           index1 = arraySortedAscendingFindElement(0 to minIndex)         
        left mid  right       index2 = arraySortedAscendingFindElement(minIndex to arr.length-1)   
                                if   indexOfArr1 != -1 && indexOfArr2 != -1
                                    means found in both arr return any index
                                if indexOfArr1 != -1 && indexOfArr2 == -1
                                        means found in 1st array retuen index1
                                if indexOfArr1 == -1 && indexOfArr2 != -1
                                        means found in 2md array retuen minIndex + index2
                                if indexOfArr1 == -1 && indexOfArr2 == -1
                                        means found in none of the array return -1


                    

        Time : O(logn) as we reduce n(length of array ) by half
        Space: O(1)
        */

        int minIndex = arrayRotatedSortedMinElement (arr);
        int indexOfArr1 = arraySortedAscendingFindElement(Arrays.copyOfRange(arr,0,minIndex), item);
        int indexOfArr2 = arraySortedAscendingFindElement(Arrays.copyOfRange(arr,minIndex,arr.length), item);
        int index = -1;
        if(indexOfArr1 != -1 && indexOfArr1 != -1){
            index= indexOfArr1;
        }
        if(indexOfArr1 != -1 && indexOfArr2 == -1){
            index =  indexOfArr1;
        }
        else if(indexOfArr1 == -1 && indexOfArr2 != -1){
            index =  minIndex + indexOfArr2;
        }
        else if(indexOfArr1 == -1 && indexOfArr2 == -1){
            index = -1;
        }

        return index;






        }  
    public int    arrayKdiffSortedFindElement(int[] arr, int k , int item){
    
        /*
        [4, 5, 6, 7, 6] -- in array each element defers from previous by at the most k
        k=1 , item - 6     find the item in array and return its index if not found retiurn -1
        
        */
        
        

        //USING MULTIPOINTERS BINARY SEARCH(Array is almost sorted) -->TIME:O(n),Space:O(1)
        //                                                             Array has duplicate elements :Will give the 1st element mid finds
        /*
        [4, 5, 6, 7, 6]
            |
            ptr    -- initialise ptr to 0 
                    while(ptr <= arr.length-1){                               --move ptr till arr.length
                        if(arr[ptr] == item){return ptr;}                           if arr[ptr] == item then retur ptr
                            
                        int req = Math.abs(arr[ptr] - item) ;                        abs(ptr - item) will tell you how much you req   
                        ptr =  ptr+ (int)Math.ceil((double)((double)req/(double)k)); ceil(req/k) will tell you positions to jum to next
                    }
                    return -1;
            
        
        */
        
        int ptr = 0;
        while(ptr <= arr.length-1){
            if(arr[ptr] == item){
                return ptr;
            }
            
            
            int req = Math.abs(arr[ptr] - item) ; 
            ptr =  ptr+ (int)Math.ceil((double)((double)req/(double)k));
        }
        
        
        return -1;
        
        
    }
    public double arrayCompare2ArrayForMediann(int[] arr1 , int[] arr2){
        /*
        Question
        [1,3]  -- merge the 2 arrays and find the median(mid = (int)l+r/2   For odd: median = arr[mid] or even median = arr[mid] + arr[mid+1]/2 )
        [2]
        */

        //USING MULTIPOINTERS SORT + SEARCH (ARRAY REQUIRES SORTING) -->Time:O(n1logn1 + n2logn2 + n1 + n2) , Space:O(1)
        /*
        Look in multiptr sort + search                       
        
        */
   

        //USING ARRAY --MULTIPTR SORT + BINARY SEARCH(ARRAY IS SORTED) --> Time: O(lonn1 + log n2 + log(min of m,n) ), Space:O(1)
        //                                                                 IF WE HAVE 2 SORTED ARRAYS IN SORT + SEARCH WE DO NOT TAKE ADV OF FACT THAT ARR ARE SORTED SO WE USE BS ;BS IS HEPFUL AS TIME COMPLEXITY WILL CHANGE FROM O(n+m ) to (log(min of m,n))

        /*
               
        [x1,x2,| x3,x4,x5,x6]            --initialise mid1 mid2 partition such that elements of arr1 on left of mid1 + elements of arr2 on left of mid2 =elements of arr1 on right of mid1 + elements of arr2 on right of mid2 
               mid1                        find mid1 mid2 partition such that  x2 <= y6 and x3 >= y5
                                           if odd elements median = max(x2,x6) if even elemnts median = (max(x2,x6) + min(x3,y6))/2
        [y1,y2,y3.y4.y5|,y6,y7,y8]
                       mid2


        [1,2,3,4,5]
        [3,4,5]        --initialise smaller arr as arr1 and larger arr as arr2
                         Binary search on arr1 for finding the paritioning
                         initialise l=0 r = arr.length (?? why not arr.lengt-1)
                         while (left <= right) {                                                 --move while l >r (l r at l>r , cb moving enc till l<= r , ca moving enc till l >r)
                            int mid1 = left + (right - left) / 2;                                       initialise mid1 for arr1   
                            int mid2 = (arr1.length + arr2.length + 1) / 2 - mid1;                      initialise mid2 for arr2 such that elements on left of mid1+ elements on left of mid2 = elements on right of mod1 + elements on right of mid2
                            int mid1Left  = mid1 == 0 ? Integer.MIN_VALUE : arr1[mid1 - 1];             initialise mid1Left on left of mid1 partition                 //null check: if(mid1 ==0) then assign min value 
                            int mid1Right = mid1 == arr1.length ? Integer.MAX_VALUE : arr1[mid1];       initialise mid1Right on right of mid1 partition ie mid1 itself //null check: if(mid1 ==arr.length) then assign max value 
                            int mid2Left  = mid2 == 0 ? Integer.MIN_VALUE : arr2[mid2 - 1];             initialise mid2Left on left of mid2 partition                 //null check: if(mid2 ==0) then assign min value 
                            int mid2Right = mid2 == arr2.length ? Integer.MAX_VALUE : arr2[mid2];       initialise mid2Right on right of mid1 partition ie mid2 itself //null check: if(mid1 ==arr.length) then assign max value 
                            
                            if (mid1Right < mid2Left) {                                                if mid1Right < mid2Left(opposite  cond of  cond required for median)
                                left = mid1 + 1; }                                                          move to right by reassigning left
                            else if ( mid1Left > mid2Right) {                                          else if mid1Left > mid2Right(opposite  cond of  cond required for median)
                                right = mid1 - 1;}                                                          move to left by reassigning right
                            else if(mid1Left <= mid2Right && mid1Right >= mid2Left){                  else if mid1Left <= mid2Right && mid1Right >= mid2Left(condition for median)
                                if ((arr1.length + arr2.length) % 2 != 0){                                  if odd elements 
                                    int max_left = Math.max( mid1Left,mid2Left);                                median = max(mid1Left,mid2Left)
                                    int min_right = Math.min( mid1Right,mid2Right);                          else if even elements
                                    double median = (double)max_left;                                            median = (max(mid1Left,mid2Left) + min(mid1Right,mid2Right))/2
                                    return median;}
                                else {
                                    int max_left = Math.max( mid1Left,mid2Left);                               
                                    int min_right = Math.min( mid1Right,mid2Right);  
                                    double median =  ( (double)max_left + (double)min_right )/2.0 ;
                                    return median;
                                }
                                    
                            }
                        }
                        return -1.0;
                         
        Time: O(lonn1 + log n2 + log(min of m,n) )
        Space:O(1)
        */

         if(arr1.length > arr2.length){
             int[] temp = arr2;
             arr2 = arr1;
             arr1 = temp;
         }

         
   
        
        int left = 0, right = arr1.length;
        while (left <= right) {
            int mid1 = left + (right - left) / 2;
            int mid2 = (arr1.length + arr2.length + 1) / 2 - mid1;
            
            int arr1Left  = mid1 == 0 ? Integer.MIN_VALUE : arr1[mid1 - 1];
            int arr1Right = mid1 == arr1.length ? Integer.MAX_VALUE : arr1[mid1];
            int arr2Left  = mid2 == 0 ? Integer.MIN_VALUE : arr2[mid2 - 1];
            int arr2Right = mid2 == arr2.length ? Integer.MAX_VALUE : arr2[mid2];
            
            if (arr1Right < arr2Left) {
                left = mid1 + 1; 
            } 
            else if ( arr1Left > arr2Right) {
                right = mid1 - 1;
            } 
            else if(arr1Left <= arr2Right && arr1Right >= arr2Left){
                int max_left = Math.max( arr1Left,arr2Left);  
                int min_right = Math.min( arr1Right,arr2Right);  
                if ((arr1.length + arr2.length) % 2 != 0){
                    double median = (double)max_left;
                    return median;}
                else {
                    double median =  ( (double)max_left + (double)min_right )/2.0 ;
                    return median;
                }
                    
            }
        }
        return -1.0;
        



    }
    public int    arrayUnSortedPeakElement(int[] arr){
        /*
        QUESTION
        [5,10,20,15,22]--  UNSORTED ARRAY: array is not sorted
                           FIND : peak element is an element that is strictly  greater than its left and right neighbouring elements
                                      for index 0 to be peak arr[0] > arr[1] and arr.length-1 to be peak arr[length-1] > arr[length-2]
                                        
        */
        

        //USING MULTIPOINTERS BINARY SEARCH(Array is unorted but still use BS) -->Time:O(log n) Space:O(n)
        //                                                                     Array has duplicate elements :Will give the 1st peak  element mid finds
        /*
        [5,10,20,15,22]
        |     |     |
        left   mid  right --  while(left <= right)  
                                mid = left + (right-left)/2
                                previous = mid-1                                  
                                next = mid + 1   
                                if(mid == 0){                                   //null check :mid-1, mid+1 may go out of bounds so check for mid = 0 and arr.length-1 
                                    if(arr.length == 1){return 0;}
                                        return arr[0] >= arr[1] ? 1:0;
                                }
                                if(mid == arr.length-1){
                                    if(arr.length == 1){return 0;}
                                    return arr[arr.length-1] >= arr[arr.length-2] ? arr.length-2:arr.length-1;
                                }
            

                                if (mid >= previous && mid >= next)
                                    means mid is peak 
                                    return mid
                                else if mid >= previous && mid <= next
                                    means we have a rising slope on right  side and rising slope promises peak so 
                                    move on right by reassigning left = mid + 1  
                                else if mid <= next
                                    means we have a rising slope on left side and rising slope promises peak so
                                    move on left by reassigning right = mid - 1 
                                else if mid <= prev && mod <= next
                                    means we have falling slope on both sides so move either left or right 

                            return -1;     




            Time : O(logn) as we reduce n(length of array ) by half
            Space: O(1)
            
            */
            
        /*
        int left = 0;
        int right = arr.length - 1;
    
        while(left <= right){
            int mid = left + (right-left)/2; 
            int previous = mid -1;
            int next = mid + 1;
            if(mid == 0){                                   
                if(arr.length == 1){return 0;}
                return arr[0] >= arr[1] ? 1:0;
            }
            if(mid == arr.length-1){
                if(arr.length == 1){return 0;}
                return arr[arr.length-1] >= arr[arr.length-2] ? arr.length-2:arr.length-1;
            }

            
           
            if(arr[mid] > arr[mid-1] && arr[mid] > arr[mid+1])
                return mid;
            else if(arr[mid] < arr[mid-1])
                right = mid -1;
            else if(arr[mid] < arr[mid+ 1])
                left = mid + 1;
            else
                left = mid + 1;  
    
        }
        
        return -1;
        */
        return 0;

    }
    public void   arrayUnSortedBinarySearchOnSolutionSpace(int[] arr , int n){
        //USING MULTIPOINTERS BINARY SEARCH ON SOLUTION SPACE
        /*
            We do not perform BS  on arr itself but rather the range of solutions henceit is called as binary search on 
            solutionnspace
            SOLUTION SPACE
            --------------          
            |             |          
            left         right   -- left = 0/min(arr) ; right = 1/max(arr)/sum(arr)  --> acc to question
                                    left = minValueOfArr;right = maxValueOfARr(ie if 0<a[i]<10^9 right = ie9)  -->   if you dont understand what range to take

            Time : O(n logn)   as we perform BS(O(logn))  and if condition inside each BS(O(n))
            Space: O(1)

        */

        //ARRAY SUBARRAY KA PARTITION KA SUM MINIMISE MAXIMUM  
        //  |--MINIMISE MAXIMUM SUM IN ARRAY PARTITION(ARRAY PARTITION) -- https://leetcode.com/problems/split-array-largest-sum/
        //  |--MINIMISE MAX SUM OF WEIGHTS IN  PARTITIONS OF DAYS(SHIP PARTITION) - https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/
        //  |--MINIMISE TIME OF MAX SUMS OF TIME IN PARTITION OF PAINTERS(PAINTER PARTITION) - https://www.geeksforgeeks.org/painters-partition-problem/
        //  |--MINIMISE PAGES OF MAX OF SUM PAGES IN PARTITION OF STUDENTS(PAGES PARTITION -- https://www.geeksforgeeks.org/allocate-minimum-number-pages/  
        /*
        arr = [10,20,30,40] ; noOfdivion= n(consider 2)
        Divide arr into given 2 subarrays 
        and "mimimize" the "maximum sum" among subarrays 
        Eg: scheme1 : [10]      ;[20,30,40] - max(10,90) = 90
            scheme2 : [10,20]   ;[30,40]    - max(50,70) = 70  ---- min = 60 
            scheme3 : [10,20,30];[40]       - max(60,40) = 60                         
        

        //USING MULTIPOINTERS SLIDING WINDOW -- FIXED SIZE(Array ka Subarray of size k)
        //                                      Array division:No of divisions = 2
        LOOK IN MULTIPTR SLIDING WINDOW

        //USING MULTIPOINTERS BINARY SEARCH ON SOLUTION SPACE
        //                                      Array division:No of divisions = any


            RANGE OF SUMS                                                                                                        
            -----------------                                            
            |    |           |                            
        left    mid          right  --left = max(arr) as we need atleast 1 element  
                                    right = sum(arr) as that can be max sum  
                                    result = -1 in case reault is never replaed
                                    while(left <= right)                                  
                                        if(midIsValidSum(arr , mid , noOfdivion))               
                                            move to left to minimise sum r = m-1                
                                            mid is a possible minsum so result = mid          
                                        else                                                     
                                            move to right to increase sum  l = m+1                       
                                        return result;   
                                                                                                
                                    public boolean midIsValidSum(int[] arr , int mid , int noOfdivion){  
                                        int noOfSubArray = 1 "NOT 0 "";
                                        int noOfSubArray = 1 "NOT 0 "";
                                        for(i = 0 ; i < arr.length ; i++){
                                            sum = sum + arr[i];
                                            if(sum > mid){
                                                sum = arr[i];
                                                noOfSubArray ++;
                                            }
                                    [10,20 30 , 40 X(at 40 sum exceeds min=70 go in another arr)]                                      
                                    [40]                                                                                               
                                    noofsubarray = 2 noofsubarray <= noOfdivion so min is valid
                                    EG [10,20,30,40] mid = 55 noOfdivion = 2
                                    [10,20,30X(at 30 sum exceeds min = 55 so 30 has to go in another arr)]
                                    [30 , 40X(at 40 sum exceeds min = 55 so 40 has to go in another arr) ]
                                    [40]   
                                    noofsubarray = 3 noofsubarray !<= noOfdivion so min is invalid
                           [10,20 30 , 40 X(at 40 sum exceeds min=70 go in another arr)]                                      
                                    [40]                                                                                               
                                    noofsubarray = 2 noofsubarray <= noOfdivion so min is valid
                                    EG [10,20,30,40] mid = 55 noOfdivion = 2
                                    [10,20,30X(at 30 sum exceeds min = 55 so 30 has to go in another arr)]
                                    [30 , 40X(at 40 sum exceeds min = 55 so 40 has to go in another arr) ]
                                    [40]   
                                    noofsubarray = 3 noofsubarray !<= noOfdivion so min is invalid

        */                   

        //ARRAY SUBARRAY KA PARTITION KA SUM MAXIMISE MINIMUM 
        //   |--MAXIMISE MINIMUM SUM IN CHOCOLATE PARTITION(CHOCOLATE PARTITION) -- https://leetcode.com/problems/divide-chocolate/submissions/
        /*
        arr = [10,20,30,40] ; noOfdivion= 2
        Divide arr into given 2 continuous subarrays 
        and "maximise" the "minimum sum" among subarrays 
        Eg: scheme1 : [10]      ;[20,30,40] - min(10,90) = 10
            scheme2 : [10,20]   ;[30,40]    - min(30,70) = 30  ---- max = 40 
            scheme3 : [10,20,30];[40]       - min(60,40) = 40                         
            
        //USING MULTIPOINTERS SLIDING WINDOW -- FIXED SIZE(Array ka Subarray of size k)
        //                                      Array division:No of divisions = 2
        LOOK IN MULTIPTR SLIDING WINDOW

        //MULTIPOINTERS BINARY SEARCH ON SOLUTION SPACE
        //                                      Array division:No of divisions = any

         ?????
         isValidMId() is not similar to 1st 
         1. when is valid is true we must move to right to maximise sum but they moved left
         2. they have done sum = 0 not arr[i]
         

        */                   


        //MINIMISE MAXIMUM DISTANCE - https://leetcode.com/problems/minimize-max-distance-to-gas-station/submissions/
        /*
        arr = [10,20,30,40] ; noOfpeople = 2
        people are standing at positions 10,20,30,40 add 2 people such that
        "minimise" the "maximum distance" between people .The minimum distance will be accepted in range 10^-6
        scheme 1: [10,15(p),20,25(p),30]         -- max(5,5,5,5) = 5            
        scheme 2 :[10,13.33(p) , 16.66(p),25,30] -- max(3.33,3.33,3,33,5) = 3.33  -- min = 3.33
        scheme 3 :... so on 

                    RANGE OF DISTANCE
            -----------------------------------                                                          
            |                     |            |                                                
        left                  mid           right   --left = 0  -- double left = 0.0       as min distance can be 0
                                                                   double right = max(arr) as max distance an be max of array
                                                                   double result = -1 .0   in case reault is never replaed  
                                                                    while (right - left > 1e-6) {                      --as answer is a double we cant do l = m+1 r = m-1 ;hece we move right to mid and left to mid and do condition right - left >= 10^-6
                                                                        double mid = left + (right - left) / 2;
                                                                        if (isValidMid(arr,mid,noOfPeople)){
                                                                            mid may be a result add mid to result result = mid;
                                                                            move to left to minimise distance right = mid
                                                                        }
                                                                        else {
                                                                            move to right to increase distance let = mid
                                                                        }
                                                                    }
                                                                    return result;

                                                                    public boolean isValidMid(int[] arr, double mid, int noOfPeople) {
                                                                        int sumOPeopleInserted = 0; 
                                                                        for (int i = 0; i <= arr.length -2; ++i) {
                                                                            int noOfPeopleInserted = (int)((arr[i+1] - arr[i])/mid);
                                                                            sumOPeopleInserted = sumOPeopleInserted + noOfPeopleInserted; 
                                                                        }
                                                                        return sumOPeopleInserted <= noOfPeople;
                                                                    }
                                                                                 |
                                                                                 |
                                                                    Eg
                                                                    [10,20,30,40] mid = 2 ; noOfPeople = 9
                                                                    10            20                35              42      
                                                                    ---------       ------------       -----------
                                                                    pI= (int)20-10/2  pI = (int)35-20/2   pI =  (int)42-35/2                                                                                                   
                                                                    SumOfPeopleInserted  = 10 + 7 + 2  = 19
                                                            
                                                                    SumOfPeoplenserted  !<= noOfPeople so mid is invalid
                                                                    
                                                                    EG
                                                                    [10,20,30,40] mid = 10 ; noOfPeople = 9
                                                                    10            20                35              42      
                                                                    ---------       ------------       -----------
                                                                    pI= (int)20-10/10  pI = (int)35-20/10   pI =  (int)42-35/10                                                                                                   
                                                                    SumOfPeopleInserted  = 1 + 1 + 1  = 3
                                                                    
                                                                    SumOfPeoplenserted  <= noOfPeople so mid is valid


        */


        //MAXIMISE MINIMUM DISTANCE BY PLACING APPROPRIATELY(ARRAY MUST BE SORTED FOR PLACEMENTS) - https://www.spoj.com/problems/AGGRCOW/
        /*
        arr = [1,2,4,8] ; noOfCows = 3   *** ARR MUST BE SORTED HERE AS SORTED ARR WILL BE REQUIRED TO CHECK PLACEMENTS
        barns  are standing at positions 1,2,4,8 place 3 people such that
        "minimise" the "maximum distance" between cows  
        scheme 1: [1,  2, 4, 8]         -- min(1,2) = 2  
                    c1 c2  c3                               --- max = 3
        scheme 1: [1,  2, 4, 8]        -- min(3,4) = 3  
                    c1      c2 c3    
                    
                    


                    RANGE OF DISTANCE
            -----------------------------------                                                          
            |                     |            |                                                
        left                  mid           right   --left = 0  -- left = 1   minimum d can 0  but 2 cows cant   so left =1           
                                                                   right =arr[arr.length] - a[0]  maximum d when cows  on extreme corners
                                                                    result = -1    in case reault is never replaed  
                                                                    while (left <= righ) {                     
                                                                        mid = left + (right - left) / 2;
                                                                        if (midIsValidDistance(arr,mid,noOfCows)){
                                                                            mid may be a result add mid to result result = mid;
                                                                            move to right to maximise distance  l = m+1  
                                                                        }
                                                                        else {
                                                                            move to left to decrease distance  r= m-1
                                                                        }
                                                                    }
                                                                    return result;

                                                                    public boolean midIsValidDistance(int[] arr,int mid ,int noOfCows ){
                                                                        int noOfCowsPlaced = 1;
                                                                        int prev = 0 ; int next = 1;
                                                                        while(next < arr.length){
                                                                            if(arr[next] -arr[prev]  >=mid){
                                                                                 prev = next;
                                                                                 noOfCowsPlaced++;
                                                                            next++;  

                                                                        }
                                                                        return noOfCowsPlaced >= noOfCows
                                                                    }
                                                                                 |
                                                                                 |
                                                                    Eg
                                                                    1       2       4      8   noOfCowsPlaced = 1                   //place 1 cow at left 
                                                                    |        |                 prev = 0  next = 1                  //move next across  barns and while moving 
                                                                    |        |                 while(next < arr.length){             if distance next - prev exceeds mid then place cow in barn
                                                                    prev    next                     if(arr[next] - arr[prev] >= mid) and bring prev ahead for calculating next distance
                                                                                                        prev = next;
                                                                                                        noOfCowsPlaced++;
                                                                                                    next++;                                                   
                                                                    EG
                                                                    [1  2   4   8  9 12 16 ] mid = 7 ; noCows = 4
                                                                    
                                                                    1  2  4  8 9 12  16
                                                                    C1           C2  C3
                                                                    noOfCowsPlaced  = 3 noOfCows = 4   3 !>=4 so invalid mid

                                                                    EG
                                                                    [1  2   4   8  9 12 16 ] mid = 3 ; noCows = 3
                                                                    
                                                                    1   2  4  8 9 12  16
                                                                    C1    C2  C3  C4  C5
                                                                    noOfCowsPlaced =5 ; noOfCows = 3 5 >= 3 so valid mid





        */


        //MINIMISE DIVISOR--https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/
        /*
        arr = [1,2,5,9] ; threshold = 6 
        Find the smallest divisor 
        such that sum of element/divisor(each one is ceiled)  <= threshold
        Eg: scheme1: divisor = 1-- 1 + 2 + 5 + 9 =17 !<16 
            scheme2: divisor = 5 --1 + 1 + 1 + 2 = 5 <=6       -- min of all
            scheme 3 : so on
            

              RANGE OF DIVISORE                                                                                                        
            -----------------                                            
            |    |           |                            
        left    mid          right --left = 1 as 1 can be the smallest divisor
                                    right = max(arr) as largest divisor can be max of arr
                                    result = -1 in case reault is never replaed
                                    while(left <= right)                                  
                                        if(midIsValidDivisor(arr , mid , threshold))               
                                            move to left to minimise divisor r = m-1                
                                            mid is a possible minsum so result = mid          
                                        else                                                     
                                            move to right to increase divisor  l = m+1                       
                                        return result;   
                                                                                                
                                    public boolean midIsValidDivisor(int[] arr , int mid , int threshold){
                                        int sumOfDividedElement =0;
                                        for(int i = 0 ; i< arr.length ; i++){
                                            int dividedElement = (int)Math.ceil((float)arr[i]/mid) ;
                                            sumOfDividedElement = sumOfDividedElement + dividedElement;
                                            
                                        }
                                        
                                        return sumOfDividedElement <= threshold;
                                    }              |
                                                   |
                                                   |
                                    EG
                                    [  1,                      2,                              5,      9] mid = 1 ; threshold = 6                                                        
                                        |                       |                              |
                                    dE= Math.ceil((double)1/1)  dE= Math.ceil((double)2/1)     so on                                                     
                                    sumOfDividedElement = 1 + 2 + 5 + 9 = 18                    
                                    
                                    sumOfDividedElement !<= threshold so mid is invalid
                                    
                                    EG
                                    [  1,                      2,                              5,      9] mid = 5 ; threshold = 6                                                        
                                        |                       |                              |
                                    dE= Math.ceil((double)1/5)  dE= Math.ceil((double)2/5)     so on                                                     
                                    sumOfDividedElement = 1 + 1 + 1 + 1 = 4                    
                                    
                                    sumOfDividedElement <= threshold so mid is valid
            
        */
        

        //MINIMISE NUMBER OF BANANA -- https://leetcode.com/problems/koko-eating-bananas/
        /*
        arr = [30,11,23,4,20] ; noOfhours = 5
        Find the smallest noofbananas per hr to be eaten such that it can be eaten in noOfhours
        and if  there are less banana in a pile than noofbananas then do not eat more in that hr
        Eg: scheme1: noOfBananas = 20-- 20 + 10(2hr) 11(1hr) 20 + 3(2hr)  4(1hr) 20(1hr) =7 !<= 5   
            scheme2: noOfBananas = 30-- 30(1hr) 11(1hr) 23(1hr)  4(1hr) 20(1hr) =5 <= 5            -- min of all
            scheme 3: so on  
            

            RANGE OF BANANAS                                                                                                     
            -----------------                                            
            |    |           |                            
        left    mid          right --left = 1 as atleast 1 banana per hour must be eaten  
                                    right = max(arr) as max banana that can be eaten is max of arr
                                    result = -1 in case reault is never replaed
                                    while(left <= right)                                  
                                        if(midIsValidBananaCount(arr , mid , noOfHrs))               
                                            move to left to minimise banana r = m-1                
                                            mid is a possible minsum so result = mid          
                                        else                                                     
                                            move to right to increase banana  l = m+1                       
                                        return result;   
                                                                                                
                                    public boolean midIsValidBananaCount(int[] arr , int mid,int noOfHrs){
                                        
                                        int sumOfHrs   = 0;
                                        int hrs = 0;
                                        for(int i = 0 ; i < arr.length ; i ++){
                                            if(arr[i]%mid == 0){
                                                hrs =  (int)arr[i]/mid;
                                            }
                                            else{
                                                hrs =  (int)arr[i]/mid + 1;
                                                
                                            }
                                            sumOfHrs = sumOfHrs + hrs;
                                        
                                        }
                                        
                                        return (sumOfHrs <= noOfHrs);
                                    }
                                                        |                                         
                                                        |                                         
                                    EG
                                    [   30          ,11                  ,23,    4, 20] mid = 5 ; sumOfHrs = 5                                                     
                                        |           |                    |               |
                                    hrs= int(30/5)  hrs= int(11/5) + 1   so on                                                     
                                    sumOfDividedElement = (6) + (2 + 1) + (4 + 1) + (1) + (4) = 19
                                    sumOfHrs >= sumOfHrs so mid is invalid
                                    
                                                            

        */
        
    
        //MAXIMISE HT OF SAW - https://www.spoj.com/problems/EKO/
        /*
        arr = [20,15,10,17] ; htrequired = 7
        Find the largesr ht of saw  required to cut trees of given height such that tree abve saw ht is collected and collected wood >= htrequired
        and if  there are tree less than ht of  saw  no wood accumulated 
        Eg: scheme1: htOfsaw = 10 --10 + 5 + 0 +  7  =22 >= 7  -- max = 15  
            scheme2: htOfsaw = 15 = 5 + 0 + 0 + 2 = 7 >= 7  
            

        RANGE OF HT OF SAW                                                                                                        
            -----------------                                            
            |    |           |                            
        left    mid          right --left = 0 which is the minimum ht of te saw
                                    right = max(arr) which can be the max ht of the saw
                                    result = -1 in case reault is never replaed
                                    while(left <= right)                                  
                                        if(midIsValidHeight(arr , mid , htRequired))               
                                            move to right to maximise ht l = m+1                
                                            mid is a possible minsum so result = mid          
                                        else                                                     
                                            move to left to decrease ht  r = m-1                       
                                        return result;   
                                                                                                
                                    public boolean midIsValidSum(int[] arr , int mid , int noOfdivion){  
                                        int noOfSubArray = 1 "NOT 0 "";
                                        int noOfSubArray = 1 "NOT 0 "";
                                        for(i = 0 ; i < arr.length ; i++){
                                            sum = sum + arr[i];
                                            if(sum > mid){
                                                sum = arr[i];
                                                noOfSubArray ++;
                                            }

                                      public boolean midIsValidHeight(int[] arr , int mid , int htrequired){       
                                        int sumOfhtOfWood = 0; int htOfWood = 0;                         
                                        for(i = 0 ; i < arr.length ; i++){  
                                            if(arr[i] > mid ) {
                                                 htOfWood = arr[i] - mid
                                            }         
                                            else {
                                                  htOfWood = arr[i] - mid
                                            }  
                                            sumOfhtOfWood = sumOfhtOfWood + htOfWood;
                                            return sumOfhtOfWood >= htrequired  
                                            |
                                            |     
                                        EG
                                        [            20          15          10         17] mid = 15 ; htrequired = 7                                                     
                                                    |           |           |           |
                                        htOfWood=20 - 15  htOfWood= 0       htOfWood= 0  htOfWood=17 - 15                                                           
                                        sumOfhtOfWood = 5 + 0 + 0 + 2 = 7
                                        
                                        sumOfhtOfWood >= htrequired so mid is invalid
                                        




        */

    
        //MINIMISE NUMBER OF HOURS -- https://www.spoj.com/problems/PRATA/
        /*
        arr = [1 2 3 4] ; noOfParathas  = 10
        Array contaisn rating of chef ie 1st chef makes 1 paratha in 1*1 min 2nd in 1*2 min ; 2nd makes 1 par in 2*1 min 2nd in 2*2 min so on
        Find the minimum time required to make 10 parathas
        Eg: scheme1: time = 12 -- 1                   2                    3                4
                                    |                   |                    |               |
                                    1*1 -> 1 paraths    2*1  -> 1 paratha   
                                    1*2 ->1 paratha     2*2  -> 1 paratha
                                    1*3 -> 1 paraths    2*3  ->1 paratha 
                                    1*4 ->1 paratha     2*4(X sum exceds 12)
                                    1*5 X(sum exceed 12)
                                    = 4 paratha           = 3 paratha     = 2 paratha   = 2 paratha  -- total = 11 >=10   ----------\
                                                                                                                                min 12 
            scheme 2 : time = 14  --1               2                3                4                                        /
                                    = 4 paratha     = 2 paratha     = 2 paratha       = 2 paraths  -- total = 11>=12 ---------/
            

            RANGE OF SUM OF TIME                                                                                                       
            -----------------                                            
            |    |           |                            
        left    mid          right  left = 0 minimum time can BE 0 
                                    right = ie9    ant think of max time
                                    result = -1 in case reault is never replaed
                                    while(left <= right)                                  
                                        if(midIsValidTims(arr , mid , noOfParatha))          
                                            move to left to minimise tine r = m-1                
                                            mid is a possible minsum so result = mid          
                                        else                                                     
                                            move to right to increase time  l = m+1                       
                                        return result;   
                                                                                                
                                    ublic boolean midIsValidTims(int[] arr , int mid , int noOfParatha){   
                                        int sumOfParatha = 0; 
                                        for(i = 0 ; i < arr.length ; i++){
                                            sumOftime = 0  sumOfParathas = 0  incrementingmultiplier = 1
                                            while(sumOftime <= mid){
                                                time = (a[i]*incrementingmultiplier)
                                                sumOftime = sumOftime + time
                                                incrementingmultiplier++;
                                                sumOfParathas++;
                                            return sumOfParatha >=  noOfParath

                                        }       
                                        
                                                                                                            
                                        EG
                                        [1                   2                 3           4 ]  mid = 12 no of parathas = 10
                                        |                   |                 |           |
                                        1*1 -> 1 paraths    2*1  -> 1 paratha   
                                        1*2 ->1 paratha     2*2  -> 1 paratha
                                        1*3 -> 1 paraths    2*3  ->1 paratha 
                                        1*4 ->1 paratha     2*4(X sum exceds 12)
                                        1*5 X(sum exceed 12)
                                        = 4 paratha           = 3 paratha     = 2 paratha   = 2 paratha  -- 
                                        sumOfParathas = 11  ; noOfParathas =10  11 > 10 so mid is valie  

                                        We keep on  adding multiples of time till time reaches mid
                                        and each time we create 1 paratha so sumOfParathas



                            


        */







    }



    //ARRAY MULTIPOINTER GREEDY    
    /*
    IDENTIFY
    ARRAY REQUIRES DECISION AT EACH STEP
    */ 
    public int    arrayConvertToIncreasingWithMinIncrementOperation(int[] arr){
        /*
        [1,5,2,4,1] -- conert to strictly increasing array w
                       with minimum increment(+1) operations
        
        */

        //USING ARRAY --  MULTIPOINTERS GREEDY(DECISION AT EACH STEP)
        /*
        [1,5,2,4,1] 
         | |
        p1 p2  -initialise ptr1 to 0 ptr2 to 1
                while(ptr1 <= arr.length-1 && ptr2 <= arr.length-1){  --move ptr1 ptr2 till..
                    if(arr[ptr1] == arr[ptr2]){                           if ptr1 = ptr2
                        incrementCount = 1;                                  inrement ptr2 by 1  
                        arr[ptr2] = arr[ptr2] + incrementCount;}
                    else if(arr[ptr1] > arr[ptr2]){                       else if ptr1 >ptr2
                        incrementCount = arr[ptr1] - arr[ptr2] +1;            increment ptr2 by ptr1-ptr2+1
                        arr[ptr2] = arr[ptr2] + incrementCount;}
                    else if(arr[ptr1] < arr[ptr2]){                       else if ptr1 < ptr2
                        incrementCount = 0;                                   increment ptr2 by 0
                        arr[ptr2] = arr[ptr2] + incrementCount;}
                    
                    count = count + incrementCount;                        add incremeted count to count

                    ptr1++;                                                move ptr1 ahead
                    ptr2++;                                                move ptr2 ahead
                }
                
                return count;
        */
        
        
        int ptr1 = 0;
        int ptr2 = 1;
        int count = 0;
        int incrementCount =0;
        while(ptr1 <= arr.length-1 && ptr2 <= arr.length-1){  
            if(arr[ptr1] == arr[ptr2]){
                incrementCount = 1;
                arr[ptr2] = arr[ptr2] + incrementCount;
                
            }
            else if(arr[ptr1] > arr[ptr2]){
                incrementCount = arr[ptr1] - arr[ptr2] +1;
                 arr[ptr2] = arr[ptr2] + incrementCount;
                
            }
            else if(arr[ptr1] < arr[ptr2]){
                incrementCount = 0;
                arr[ptr2] = arr[ptr2] + incrementCount;
            }
            
            count = count + incrementCount;

            ptr1++;
            ptr2++;
        }
        
        return count;
        
    }
    public int    arrayConvertToMinRangeWithIncDecOpertionsI(int[] arr,int k){
        /*
        [1,4,3,2] -- You can increment or decrment each element by k(decrement can lead to -ve number/cannot lead to -ve number)
                     such a way that range is minimum ie maxElement - minElement is minimum
        
        */

        //USING ARRAY --  MULTIPOINTERS GREEDY(DECISION AT EACH STEP)
        /*
        SORT 
        [1,2,3,4]  -- sort array

        SEARCH 
        a[0+k],arr[1]+k...a[i]+k,a[i+1]-k,a[i+2]-k..a[n-1]-k      
        we inc   till ith element  and dec from there on so that i is the point where we get min diff 
        to find this ith element  we loop through array and inc and dec consecutive elements(and whild doing so also check them with last element-k 1st element +k so that they dont exceed max min)
        and find their min diff

        [1,2,3,4]
         | |                                                                         
        p1 p2     --int max = arr[arr.length - 1] - k;                               maxElement will be last element -k    (range will be min when max element(last element) lowered by k and min element(0th element) increased by k )
                    int min = arr[0] + k;                                            minElement will be 1st element + k
                    int res = arr[arr.length-arr[0]+k                                res holds the max possible range as you want to find min so res must hold max value
                    while(ptr1 <= arr.length-1 && ptr2 <= arr.length-1){           --move ptr1 ptr2 till  arr.length(..)
                        max = Math.max(arr[ptr1] + k, arr[arr.length - 1] - k);        increment 1st element and check it does not exceed last element -k
                        min = Math.min(arr[ptr2] - k,arr[0] + k);                      decrement 2nd element and check it does not go below 2st elemet +k
                        
                                                                                       //if negative diff allowed
                        res = Math.min(res, max - min);                                find the min differences                                                                                           
                        ptr1++;                                                        move ptr1,ptr2 ahead ahead
                        ptr2++;                                                          
                                                                                      //if negative diff not  allowed
                        if(min <0){                                                    if min <0
                            ptr1++;                                                      ignore the diff
                            ptr2++; }                                                    move ptr1 and ptr2 ahead
                        else{                                                          else
                            res = Math.min(res, max - min);                                find min diff
                            ptr1++;                                                        move ptr1 ptr2 ahead
                            ptr2++
                        }
                    }

                    return res
                    
            


        
        */

        Arrays.sort(arr);
        int max = arr[arr.length - 1] - k;
        int min =  arr[0] + k;
        int res = arr[arr.length - 1] - arr[0];
        int ptr1 = 0;
        int ptr2 = 1;
        while(ptr1 <= arr.length-1 && ptr2 <= arr.length-1){
            
            max = Math.max(arr[ptr1] + k, arr[arr.length - 1] - k);
            min = Math.min(arr[ptr2] - k,arr[0] + k);
            res = Math.min(res, max - min);
            
            ptr1++;
            ptr2++;
        }
        
        
   
        return res;
    }
    public int    arrayConvertToMinRangeWithIncDecOpertionsII(int[] arr,int k){
        /*
        [1,4,3,2] -- You can incremen or decrment in range [-k to k]
                     such a way that range is minimum ie maxElement - minElement is minimum
        
        */

        //USING ARRAY --  MULTIPOINTERS GREEDY(DECISION AT EACH STEP)
        /*
   

        SEARCH 
             4
            /  \
           /     3
          /        \
         /          2
       1          
          
       inc min by k and dec max by k 
       if min +k exceeds max - k then you will take k such that min + somethingSmallaeThanK and max - somethingSmallerk such that diff is 0
       if min +k cant exceed max - k then you will have to take min + k and max -k such that diff is min 



        [1,2,3,4]
         | |                                                                         
        p1 p2     --iterate arr and find max and min element
                    if(min +k >= max-k){
                        res  = 0;}
                    else{
                        res = (max-k)-(min+k);} 
                    returnn res;
                    
            


        
        */

        int min = Integer.MAX_VALUE;
        int max =  Integer.MIN_VALUE;
        int res = -1;
        for(int i= 0 ;  i<= arr.length-1;i++){
            min = Math.min(arr[i],min);
            max = Math.max(arr[i],max);
        }
           
        if(min +k >= max-k){
            res=0;}
         else{
             res = (max-k)-(min+k);}
           
        return res;
           
    }
    public int    arrayGroupByEvenTogetherMinSwapss(int arr[], int k){

        /*
        Question
        [1,3,5,7,9,2,4,6,3,5,10] k=4-- move all elements such that even elements are together
                                       and order doesnt matter
                                       return min no of swaps req
                                       Eg:[1,3,5,7,9,2,4,6,3,5,10] --swap 3 and 10 so min 1 swap rea
        */

        //USING ARRAY --  MULTIPOINTERS GREEDY(DECISION AT EACH STEP)
        /*
        [1,3,5,7,9,2,4,6,3,5,10]  -iterate the array and count no of even elements
                                   min no of swaps = subarray with size k=noOfEvenElemnts 
                                                     un subarrays ka odd elements ka min count
                                   
        Time:O(n)
        Space:O(1)
        
        */
        int evenCount = 0;
        for (int i = 0; i <= arr.length-1;i++){
            if (arr[i] %2== 0){evenCount++;}
        }
                
        if(evenCount == 0){return 0;}
        //return arraySubarrayKaSizekaOddElementKaMinCount(arr,evenCount); //fn in recursion sliding window
        return 0;
        
    }
    public int    arrayGroupByNegativeTogetherMinSwapss(int arr[], int k){

        /*
        Question
        [1,3,5,7,9,-2,-4,-6,3,5,-10] k=4-- move all elements such that -ve elements are together
                                           and order doesnt matter
                                           return min no of swaps req
                                          Eg: [1,3,5,7,9,-2,-4,-6,3,5,-10] -swap 3 and -10 so min 1 swap rea
        */

        //USING ARRAY --  MULTIPOINTERS GREEDY(DECISION AT EACH STEP)
        /*
        Same as arrayGroupByEvenTogetherMinSwaps() replace 
        arr[i] %2== 0                               by arr[i] <0
        arraySubarrayKaSizekaOddElementKaMinCount()   by arraySubarrayOfSizePositiveElementsMinCount 
                                   
        Time:O(n)
        Space:O(1)
        
        */
        return 0;
    }
    public int    arrayGroupByLessThanKTogetherMinSwapss(int arr[], int k){

        /*
        Question
        [9,10,11,12,1,2,3,5,4] k=4-- move all elements such that elements<=k  are together
                                      and order doesnt matter
                                     return min no of swaps req
                                     Eg: [9,10,11,12,1,2,3,5,4] -swap 5 and 4 so min 1 swap rea
        */
        //USING ARRAY --  MULTIPOINTERS GREEDY(DECISION AT EACH STEP)
        /*
        Same as arrayGroupByEvenTogetherMinSwaps() replace 
        arr[i] %2== 0                               by arr[i] <= k
        arraySubarrayKaSizekaOddElementKaMinCount()   by arraySubarrayOfSizeKLessThanNMInCount(arr,k,n)
                                   
        Time:O(n)
        Space:O(1)
        
        */
        return 0;
    }
    public int    arrayGroupBy01AlternateMinSwapss(char[] arr){
        /*
        ["1","1","1","0","0","0"] -- given an array of "0" and "1"
                                     return min swaps to make it alternating "0" and "1"
                                     order doesnt matter
        */

        //USING ARRAY --  MULTIPOINTERS GREEDY(DECISION AT EACH STEP)
        /*
          ["1","1","1","0","0","0"]  -- iterate array and count noOfZeros and noOfOnes
                                        noOfMiss = if(Math.abs(noOfZeros-noOOnes)>1)
                                                    return -1 as impossible to make alternate
                                                   if noOfZeros > noOfOnes
                                                      miss =  arrayAlternateMissCount(arr,'0'); 
                                                   if noOfZeros < noOfOnes
                                                      miss =  arrayAlternateMissCount(arr,'1');
                                                   if noOfZeros == noOfOnes
                                                      miss =  Math.min(arrayAlternateMissCount(arr,'1'),arrayAlternateMissCount(arr,'1'));
                                        minNoOfSwaps = (int)noOfMiss/2

        //arrayAlternateMissCount(char[] arr,char ch) -- considering arr starts from ch no of misses for being alternate
         ["1","1","1","0","0","0"] -- start with given ch
                                      iterate through array
                                      if ch does not match 
                                         increment noOfMiss
                                      swap ch   
        }
        */

        int noOfZeros = 0;
        int noOfOnes = 0;
        for(int i=0 ; i<= arr.length-1;i++){
            if(arr[i] == '0')
                noOfZeros++;
            if(arr[i] == '1')
                noOfOnes++;
        }
        
                int miss = 0;
        if(Math.abs(noOfZeros-noOfOnes)>1){
            return -1;
        }
        if(noOfZeros>noOfOnes){
             //miss = arrayAlternateMissCount(arr,'0'); 
        }
        if(noOfZeros <noOfOnes){
             //miss = arrayAlternateMissCount(arr,'1'); 
        }
        if(noOfZeros == noOfOnes){
             //miss =  Math.min(arrayAlternateMissCount(arr,'0'),
             //                   arrayAlternateMissCount(arr,'1')
             //                   ); 
        }
        
        return (int)(miss/2);

        //arrayAlternateMissCount()
        /*
        public int arrayAlternateMissCount(char[] arr, char ch){
            int noOfMiss = 0;
            ch = ch;
            for(int i=0 ; i <= arr.length-1;i++){
                if(arr[i] != ch){
                    count++;
                }
                ch = (ch == '0'?'1':'0');
            }
            return count;
        }
    
        */
    }
    public int    arrayContinuousSumEqualsMinCost_RopesJoining(int[] arr){

        /*
        Question
        arr = [1,2,3,4,5] -- these are the sizes of rope and the cost of joining them = addition of size of ropes
                            Join the ropes in such a way that you get min cost
                            RESULT: So the min cost is when ypu join 2 ropes with min length at any given time
                            EG 1   2   3   4    5   Total cost = 3 + 6 + 15 = 24
                                \   / /    /    /
                                3   /     /    /
                                 \ /     /    /
                                  6     /    /
                                    \  /    /
                                    10     /
                                     \    /
                                        15


                                1   2   3   4   5  Total cost = 3 + 6 + 9 = 18
                                \    /  /   \  /  
                                 \  /  /      9 
                                   3  /        /
                                   \ /       /
                                    6       /
                                    \      /
                                        15
                                    */ 

 
                            
      //USING ARRAY --  MULTIPOINTERS GREEDY(DECISION AT EACH STEP)  --> Time : O(n logn) ;Space: O(1)
      /*
       1.SORT ARRAY
       [1,2,3,4,5]  -- [1,2,3,4,5] -- while arrayList size >= 2   
                        \ /              sort the array add 1st 2 elements and replace them with sum
                         3             

        2.SEARCH ARRAY
        -


        Time : O(n*nlogn)   as we reduce n(length of arr) by half and sort upto n; do this for entire array
        Space: O(1) 
      */

      List<Integer> arrayList = new ArrayList<>();
      for(var i : arr){arrayList.add(i);}

      int sum = 0;
      while(arrayList.size() >= 2){
          Collections.sort(arrayList);
          var first = arrayList.remove(0);
          var second = arrayList.remove(1);
          arrayList.add(0,first+ second);
          sum = sum + first + second;

      }
      return sum;

      //USNNG MINHEAP(Array requires sorting  + K is given  ; and we req max elements at bottom and min at top)--> Time : O(n logn) ;Space: O(n)
      /*
      Look in heaps
      */
      





    }
    public int[]  arraySubarrayKaIncreasingTripletKaPossibleAndArray(int[] arr){
        /*
        arr = [1,2,2,3,4,2]-- find all the subarrays of  array
                             and find the  trictly increasing  triplet subarrays 
                             and return if such triplet is possible ; return  the triplet 
                            Eg [1,2,2] 
                              (non decreasing/increasing subarrays)    
                               [1,2,3]        
                              (strictly increasing  subarrays)  

        */
        //USING MULTIPTR GREEDY
        /*
        [1,2,2,3,4,2]  
             --iterate through array 
                if(arr[i] < firstSmallest){                              --find 1st smallest,2nd smallest based on 1st smallest;3rd smallest based on 1st and 2nd smallest 
                    firstSmallest = arr[i];                                If the arr doesnt contain the triplet;then you would never find the 3rd smallest
                }                                                          Hence if we find 3rd smallest then we find the triplet ; else we dont
                if(arr[i] >firstSmallest && arr[i] <= secondSmallest ){    Eg: [8,9,7,6,5,4] -->fs = 8, ss = 9 but we never find ts as triplet is absetn
                    secondSmallest = arr[i];                                   [5,4,3,2,1] -- fs = 5 but we never find ss as triplet is absetn
                }
                if(arr[i] >firstSmallest && arr[i] > secondSmallest ){
                    thirdSmallest = arr[i];
                    return new int[]{firstSmallest,secondSmallest,thirdSmallest};
                    return true;
                }
                return new int[]{-1,-1,-1};
                return false;
        

        Time:O(n)
        Space:O(1)

        */
        
        int firstSmallest = Integer.MAX_VALUE;
        int secondSmallest =Integer.MAX_VALUE; 
        int thirdSmallest = Integer.MAX_VALUE;
        for(int i=0 ; i <= arr.length-1;i++){
            if(arr[i] < firstSmallest){
                firstSmallest = arr[i];
            }
            if(arr[i] >firstSmallest && arr[i] <= secondSmallest ){
                secondSmallest = arr[i];
            }
            if(arr[i] >firstSmallest && arr[i] > secondSmallest ){
                thirdSmallest = arr[i];
                return new int[]{firstSmallest,secondSmallest,thirdSmallest};
                //return true;
            }
        }
        return new int[]{-1,-1,-1};
        //return false;
        
               
        
    }
    public int    arrayPermutationKaMinJumpKaCount(int[] arr){
        /*
        [2,3,1,1,4]  --Each element in array represents the maximum jump you can do at that step
                       find the min jumps req to reach end of arr and if you cannot reach return -1
     

         
        
        */
        
        //USING ARRAY --  MULTIPOINTERS GREEDY(DECISION AT EACH STEP)  
        /*
        [2,3,1,1,4]
        ||
       p1,p2 --initialise ptr1 and ptr2 to 0
                while(ptr2 <= arr.length-2){                      --move ptr2 till arr.length-1(we dont have to ckheck last element)
                    
                    if(ptr1 > ptr2){return -1;}                        //null check:if ptr1 moves ahead of ptr2 then we cant reach end Eg:[3,2,1,0,4]
                    
                    int maxJump = 0;                                   consider subarray  from ptr1 to ptr2
                    for(int ptr3 = ptr1 ; ptr3 <= ptr2;ptr3++){        find the max jump you can do in that subarray 
                        maxJump = Math.max(maxJump,ptr3+ arr[ptr3]);}
                    ptr1 = ptr2+1;                                     next subarray is from  next element upto the farthest from previous subarray
                    ptr2 = maxJump;                                    no of jumps is the number of subarray
                    noOfJumps++;    
                }
                
                return noOfJumps;       //no of jumps                             
                return noOfJumps != -1  //check whether you can reach end of array
         
        Time:O(n)
        Space:O(1)     
        
        */
        int ptr1  = 0;
        int ptr2 = 0;
        int noOfJumps = 0;
        
        while(ptr2 <= arr.length-2){       
            if(ptr1 > ptr2){return -1;}
            int maxJump = 0;
            for(int ptr3 = ptr1 ; ptr3 <= ptr2;ptr3++){
                maxJump = Math.max(maxJump,ptr3+ arr[ptr3]);
            }
            ptr1 = ptr2+1;
            ptr2 = maxJump;
            noOfJumps++;    
        }
         
        return noOfJumps;
         
        
    }
    public void   arrayPermutationKaMinJumpKaPossible(int[] arr){
        /*
        [2,3,1,1,4]  --Each element in array represents the maximum jump you can do at that step
                       find the min jumps req to reach end of arr and if you cannot reach return -1
                       find whether you can reach the end of the array

         
        
        */
        
        //USING ARRAY --  MULTIPOINTERS GREEDY(DECISION AT EACH STEP)  
        /*
        int jumps =  arrayPermutationKaMinJumpKaCount(arr)\
        return jumps != -1
         
        Time:O(n)
        Space:O(1)      
        
        */
        int jumps =  arrayPermutationKaMinJumpKaCount(arr);
        //return jumps != -1;
         
        
    }
    public int    arrayPermutationKaMaxStockDifferenceKaDiffI(int[] arr){
        /*
        [7,1,5,3,6,4]  --Each element in array represents the price of stock  on ith day
                        you can buy a stock and sell it on future day with only 1 transaction of buying and selling
                       find the max profit you can make and if no profit return 0
                       Eg: [7,1,5,3,6,4] -- buy on day 2(price = 1) and sell on day 5(price = 6) ; profit = 6-1 = 5 
         
        
        */
        
        //USING ARRAY --  MULTIPOINTERS GREEDY(DECISION AT EACH STEP)  
        /*
        7
         \                   6
          \                 / \
           \         5     /   \
            \      /  \   /     4
             \    /    \ /
              \  /      3  
               \/
                1 
                |
                start with index 1
                diff = current element - smallestOnLeft
                maxDiff = max of all positive difference  as profit must be +ve 






        [7,1,5,3,6,4]
           |
           p2 --initialise ptr to 1
                initialise smallestOnLeft to arr[0];
                int maxDiff = Integer.MIN_VALUE; 
                while(ptr <= arr.length-1){                                    --move ptr till arr.length(...)
                    int diff = arr[ptr] - smallestOnLeft;                           diff = current element - smallestOnLeft     
                    if(diff >=0){maxDiff = Math.max(diff, maxDiff); }               maxDiff = max of all positive difference  as profit must be +ve 
                    smallestOnLeft = Math.min(smallestOnLeft, arr[ptr]);            reassign smallest on left
                    ptr++;                                                          move ptr ahead
                } 
                return maxDiff != Integer.MIN_VALUE? maxDiff:0;                 return maxDiff  //null check:if maxDiff is not set means there is no profut so return 0
         
                
        
        */
        int ptr = 1;
        int smallestOnLeft = arr[0];
        int maxDiff = Integer.MIN_VALUE; 
        while(ptr <= arr.length-1){
            int diff = arr[ptr] - smallestOnLeft;
            if(diff >=0){maxDiff = Math.max(diff, maxDiff); }
            smallestOnLeft = Math.min(smallestOnLeft, arr[ptr]);
            
            ptr++;
        }
        
        return maxDiff != Integer.MIN_VALUE? maxDiff:0;
        
    }
    public int    arrayPermutationKaMaxStockDifferenceKaDiffII(int[] arr){
        /*
        [7,1,5,3,6,4]  --Each element in array represents the price of stock  on ith day
                       if you can buy a stock and sell it on the same  day with only multiple transaction of buying and selling
                       find the max profit you can make and if no profit return 0
                       Eg: [7,1,5,3,6,4] -- buy on day 2(price = 1) and sell on day 3(price = 5) profit = 5-1 = 4
                                            buy on day 4(price = 3) and sell on day 5(price = 6) profit = 6-3 = 3
                                                                                                 total profit = 4+3 = 7
                                                                                        
                                                                                                 
         
        
        */
        
        //USING ARRAY --  MULTIPOINTERS GREEDY(DECISION AT EACH STEP)  
        /*
        7
         \                   6
          \                 / \
           \         5     /   \
            \      /  \   /     4
             \    /    \ /
              \  /      3  
               \/
                1 
                |
                start with index 1
                diff = current element - previous element if current element is greater than previous
                total = sum of all diff
                        because the diff between consecutive elements add up to difference between the elements where profit will be max
                        Eg: refer https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solution/ ka soln 3 ka graph
                            diff bw consecutive elements = A + B + C
                            diff bw elements where profit will be max = D
                            A + B + C = D






        [7,1,5,3,6,4]
           |
           p  --initialise ptr to 1
                int totalDiff = 0;
                while(ptr <= arr.length-1){                          --move ptr till arr.length-1
                    int diff = 0;                                         diff = current element - previous element if current element is greater than previous             
                    if(arr[i] >= arr[i-1]){diff = arr[i] - arr[i-1];}     totalDiff = sum of all diff  
                    totalDiff = totalDiff + diff;                         move ptr ahead
                    ptr++;
                }
            
                
                return totalDiff;
                
        
        */
        int totalDiff = 0;
        int ptr = 1;
        while(ptr <= arr.length-1){
            int diff = 0;
            if(arr[ptr] >= arr[ptr-1]){
                diff = arr[ptr] - arr[ptr-1]; 
            }   
            
            totalDiff = totalDiff + diff; 
            ptr++;
        }
      
        
        return totalDiff;

        
    }
    public int    arrayPermutationKaGasStationKaIndex(int[] arr1, int[] arr2) {
        /*
        Question
        [1,2,3,4,5] -->arr1 is the fuel you can fill at ith position and arr2 is the required fuel to travel to i+1 position
        [3,4,5,1,2]   and you are required to make a circular trip back to gas station
                      return the index of station where you can make a circular trip given there is a "unique soln" and if no soln ret -1
                      Eg:[1,2,3,4,5]
                        [3,4,5,1,2]
                        Start at station index 3  and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
                        Travel to station 4. Your tank = 4 - 1 + 5 = 8
                        Travel to station 0. Your tank = 8 - 2 + 1 = 7
                        Travel to station 1. Your tank = 7 - 3 + 2 = 6
                        Travel to station 2. Your tank = 6 - 4 + 3 = 5
                        Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.
                        Therefore, return 3 as the starting index

                    EG:[2,3,4]
                       [3,4,3]
                       ret -1
        */

        //USING ARRAY --  MULTIPOINTERS GREEDY(DECISION AT EACH STEP)  
        /*
                
        [1,2,3,4,5]
        [3,4,5,1,2]
         |
         ptr          --initialise ptr to 0
                        while(ptr <= arr1.length-1){                        --move ptr till arr.length(ptr at arr.length , cb ptr enc till arr.length-1 ,ca ptr enc till arr.length)
                            sumGas  = sumGas +arr1[ptr];                           calculate sum of gas , sum of cost and currentGas  at each point             
                            sumCost = sumCost+ arr2[ptr];                          if currentGas < 0 
                            currentGas += arr1[ptr] - arr2[ptr];                       means currentIndex can never be soln but next index may be a soln so set  startIndex to nextIndex
                            if (currentGas < 0) {                                      reset currentGas to 0 because currentIndex can never be soln but next index might be a soln
                                startIndex = ptr + 1;
                                currentGas = 0;}
                            ptr++;
                        }

                        
                        if (sumGas < sumCost) {                               -- if sum of gas < sum of cost
                            return -1;}                                              there can never be a soln so return  -1
                        else {                                                   else there can be a solm
                            return startIndex;                                        since there is "ONE UNIQUE SOLN" staryIndex must be the only probable son
                        }                                                             the reason startIndex will be a sure shot soln is proof by contradiction(SEE --https://leetcode.com/problems/gas-station/solution/)
                                                                                    
        */
        int sumGas = 0;
        int sumCost = 0;
        int startIndex = 0;
        int tank = 0;
        int ptr = 0;
        while(ptr <= arr1.length-1){
            sumGas += arr1[ptr];
            sumCost += arr2[ptr];
            tank += arr1[ptr] - arr2[ptr];
            if (tank < 0) {
                startIndex = ptr + 1;
                tank = 0;}
            ptr++;
        }
    

        if (sumGas < sumCost) {
            return -1;} 
        else {
            return startIndex;
        }
    }
    public double arrayPermutationFractionalKnapSack(List<Double> wt , List<Double> val, double W){
        /*
      weight[]  30.0,20.0,10.0 ---> W = 50  -- put the weights in a bag(each wt can only be taken 0 or 1 or fraction times) with weight capacity 6  
      value []  120.0,60.0,100.0               return the combination with max profit ka value           
                                               Eg{10,20,20*2/3}= 60+100+120*2/3  =240  240 is max profiit so return 240                                                                           
                                                {10,30,20*1/2} = 60+100+100*1/2 = 210
        */

      //USING ARRAY --  MULTIPOINTERS GREEDY(DECISION AT EACH STEP)  
      /*
      SORT
      [30.0,20.0,10.0]    --[[10.0,60.0],[20.0,100.0],[30.0,120.0]]    --craete arr of  node of wt value 
      [120.0,60.0,100.0]                                                 and sort arr based on wt/val ratio

      //SEARCH
      [[10.0,60.0],[20.0,100.0],[30.0,120.0]]   --  --iterate through arr
                                                        if wt <= W
                                                            remove wt from W
                                                            add value to maxProfit
                                                        else{                                                       
                                                            find the fraction of wt to take 
                                                            remove wt*fraction from W
                                                            add value*fraction to maxProfit 
                                                            break;
                                                            
                                                        }
                                                    }
            
      
      */
        /*
        class Node{
            double wt;
            double val;
            public Node(double wt, double val){
                this.wt  = wt;
                this.val = val;
            }
        }
        class SortByNode implements Comparator<Node>{
            @Override
            public int compare(Node val1,Node val2){
                double diff = (double)(val1.wt/val1.val) - (double)(val2.wt/val2.val);
                if(diff > 0.0)
                    return 1;
                else if(diff < 0.0)
                    return -1;
                else 
                    return 0;
            }
        }
        
        public double arrayPermutationFractionalKnapSack(List<Double> wt , List<Double> val, double Wt)
            List<Node> items = new ArrayList<>();
            for(int i=0 ; i<= wt.size()-1;i++){
                items.add( new Node(wt.get(i),val.get(i)));
            }            
            Collections.sort(items,new SortByNode());
            

            
            double maxProfit = 0.0;
            for(var item:items){
                if(item.wt <= W){
                    W = Wt - item.wt;
                    maxProfit = maxProfit + item.val;
                }
                else{
                    double fractionOfWt = (double)(W/item.wt);
                    Wt = Wt - (double)(item.wt*fractionOfWt);
                    maxProfit = (double)maxProfit + (double)(item.val*fractionOfWt);
                    break;
                    
                }
            }
            
            return value;
        }
        */

        return 0.0;
        
        
        
    }


    //STACK
    /*
    STACK IDENTIFY
    ARRAY  BRUTE FORCE O(n^2) INNER LOOP DEPENDS ON OUTER LOOP ie for(int i=0 ; i<=n;i++){for(j =0 ; j< i ; j++)}-- j depends on i        
     */    
    public int[]   arrayGreatestToLeft(int[] arr){
        /*
        QUESTION
        [3,0,0,2,0,4] 
        [-1,3,0,0,0,0] --  find the  greater element on left if not present put -1
        */
        

        //USE ARRAY(Array Brute force: O(n) so no stack req)
        /*
        [3,0,0,2,0,4]
        |
        ptr --          int[] result = new int[arr.length];
                        int max = Integer.MIN_VALUE;
                        for(int ptr =0; ptr <= arr.length-1; ptr++){             move ptr till arr.length-1         
                            result[ptr] = (max == Integer.MIN_VALUE)?-1:max;     put max till now in result
                            max = Math.max(arr[ptr],max);
                            
                        }

                        return result;
            

        Time : O(n) as we reduce n(length of array ) by 1
        Space: O(1)
        */
        int[] result = new int[arr.length];int index =0;
        int max = Integer.MIN_VALUE;
        for(int ptr =0; ptr <= arr.length-1; ptr++){
            result[index++] = (max == Integer.MIN_VALUE)?-1:max;
            max = Math.max(arr[ptr],max);
            
        }

        return result;

   }
    public int[]   arraySmallestToLeft(int[] arr){
    /*
    QUESTION
     [3,0,0,2,0,4] 
     [-1,3,0,0,0,0] --  find the  smallest element on left and if nit present put -1
    */
    
    //USE ARRAY(Array Brute force: O(n) so no stack req)
    /*
    [3,0,0,2,0,4]
    |
    ptr --  int min = Integer.MAX_VALUE;
            for(int ptr =0; ptr <= arr.length-1; ptr++){               move ptr till arr.length-1
                result[index++] = (min == Integer.MAX_VALUE)?-1:min;   put min till now in result 
                min = Math.max(arr[ptr],min);

                return result;

    Time : O(n) as we reduce n(length of array ) by 1
    Space: O(1)
    */
    
    int[] result = new int[arr.length];int index =0;
    int min = Integer.MAX_VALUE;
    for(int ptr =0; ptr <= arr.length-1; ptr++){
        result[index++] = (min == Integer.MAX_VALUE)?-1:min;
        min = Math.max(arr[ptr],min);
        
    }

    return result;

   }
    public int[]   arrayGreatestToRight(int[] arr){
   /*
    QUESTION
     [3,0,0,2,0,4] 
     [4,4,4,4,4,-1] --  find the  greater element on right if not present put -1
    */
    

    //USE ARRAY(Array Brute force: O(n) so no stack req)
    /*
    [3,0,0,2,0,4]
    |
    ptr --  int max = Integer.MIN_VALUE;
            for(int ptr =arr.length-1; ptr >=0; ptr--){                      move ptr till 0
                result[index--] = (max == Integer.MIN_VALUE)?-1:max;          put max till now in result 
                max = Math.max(arr[ptr],max);
                
            }
    
    Time : O(n) as we reduce n(length of array ) by 1
    Space: O(1)
    */


    int[] result = new int[arr.length];int index =arr.length-1;
    int max = Integer.MIN_VALUE;
    for(int ptr =arr.length-1; ptr >=0; ptr--){
        result[index--] = (max == Integer.MIN_VALUE)?-1:max;
        max = Math.max(arr[ptr],max);
        
    }

    return result;



   }
    public int[]   arraySmallestToRight(int[] arr){
    /*
     QUESTION
      [3,0,0,2,0,4] 
      [0,0,0,0,0,-1] --  find the  smallest element on right if not present put -1
     */
     
 
     //USE ARRAY(Array Brute force: O(n) so no stack req)
     /*
     [3,0,0,2,0,4]
     |
     ptr --     int min = Integer.MAX_VALUE;
                for(int ptr =arr.length-1; ptr >=0; ptr--){                  move ptr till 0
                    result[index--] = (min == Integer.MAX_VALUE)?-1:min;     add min till now in result
                    min = Math.max(arr[ptr],min);
                    
                }

                return result;
            
    
    Time : O(n) as we reduce n(length of array ) by 1
    Space: O(1)
    */


    int[] result = new int[arr.length];int index =arr.length-1;
    int min = Integer.MAX_VALUE;
    for(int ptr =arr.length-1; ptr >=0; ptr--){
        result[index--] = (min == Integer.MAX_VALUE)?-1:min;
        min = Math.max(arr[ptr],min);
        
    }

    return result;
 
 
    }
    public int[]   arrayNearestGreatestToLeft(int[] arr){
        /*
        QUESTION
        [1,3,2,4]
        [-1,-1,3,-1] -- find the nearest greater element on left if not return -1

        */

        //USING STACK(Array Brute force O(n^2) inner loop depends on outer loop ie for(i=0 to arr.leng){for(j = i to arr.length)})
        /*
          [1,3,2,4]   ---         -move ptr till arr.length-1 
           |               3        if stack is empty 
          ptr              1           put -1 in result
                                    if stack is not empty and if top element of stack  > ptr 
                                        put top of stack in result
                                    if stack is not empty and  if top of stack  <= ptr
                                       pop while stack is not empty and  top of stack  <= ptr
                                       if stack is not empty put top element in result
                                       if stack empty put -1 in result
                                    push the element to stack  
                                    
                                    return result
    
    Time : O(n) as we reduce n(length of array ) by 1
    Space: O(n)
    */  


        Stack<Integer> stack = new Stack<>();
        int[] result = new int[arr.length];int index =0;
        for(int ptr  =0 ; ptr <= arr.length-1 ; ptr ++){
            if(stack.isEmpty()){
                result[index++] = -1;
            }
            else if(!stack.isEmpty() && stack.peek() > arr[ptr]  ){
                result[index++]  = stack.peek();
            }
            else if (!stack.isEmpty() &&  stack.peek() <= arr[ptr]){

                while(!stack.isEmpty() &&  arr[ptr] <= stack.peek() ){
                    stack.pop();
                }

                if(!stack.isEmpty()){
                    result[index++] = stack.peek();
                }
                else{
                    result[index++] = -1;
                }
            }

            stack.push(arr[ptr]);



        }

        return result;
    }
    public int[]   arrayNearestSmallestToLeft(int[] arr){
        /*
        QUESTION
        [1,3,2,4]
        [-1,2,-1,-1] -- find the nearest smallest element on right if not return -1

        */

        //USING STACK(Array Brute force O(n^2) inner loop depends on outer loop ie for(i=0 to arr.leng){for(j = i to arr.length)})
        /*
          [1,3,2,4]   ---            -->move ptr till arr.length-1
            |                 3       if stack is empty 
           ptr                1         put -1 in result
                                      if stack is not empty and if the top element of stack <  ptr 
                                         put top of stack in result
                                      if stack is not empty and if top of stack  >= ptr 
                                        pop while stack is not empty and top of stack  >= ptr 
                                        if stack is not empty put top element
                                        if stack empty put -1
                                      push the element to stack  

                                      return result
                                       
        
        Time : O(n) as we reduce n(length of array ) by 1
        Space: O(n)
        */  

        Stack<Integer> stack = new Stack<>();
        int[] result = new int[arr.length];int index =0;

        for(int ptr = 0 ; ptr <= arr.length-1 ; ptr++){

            if(stack.isEmpty()){
                result[index++] = -1;
            }
            else if(!stack.isEmpty() && stack.peek() < arr[ptr] ){
                result[index++]  = stack.peek();
            }
            else if( !stack.isEmpty() && stack.peek() >= arr[ptr] ){
                while(!stack.isEmpty() && stack.peek() >= arr[ptr] ){
                    stack.pop();
                }
                if(!stack.isEmpty()){
                    result[index++]  = stack.peek();
                }
                else{
                    result[index++]  = -1;
                }
                 
            }

            stack.push(arr[ptr]);
        }



        return result;






    }  
    public int[]   arrayNearestGreaterToRight(int[] arr){
        /*
        QUESTION
        [1,3,2,4]
        [3,4,4,-1] -- find the nearest greater element on right if not return -1

        */

        //USING STACK(Array Brute force O(n^2) inner loop depends on outer loop ie for(i=0 to arr.leng){for(j = i to arr.length)})
        /*
          [1,3,2,4]   ---            -->move ptr till 0
                 |            2       if stack is empty 
                ptr           4         put -1 in result 
                                      if stack is not empty and if the top element of stack  > ptr  
                                        put top of stack in result ka backside
                                      if stack is not empty and if top of stack  <= ptr 
                                          pop while stack is not empty and top of stack  <= ptr 
                                          if stack is not empty put top of stack in result  ka backside
                                          if stack empty put -1 in result  ka backside
                                       push the element to stack  
                                       
                                       return result
        Time : O(n) as we reduce n(length of array ) by 1
        Space: O(n)
        */                                 
        int[] result  = new int[arr.length];int index =arr.length-1;
        Stack<Integer> stack = new Stack<>();
        for(int ptr = arr.length-1; ptr >=0 ; ptr --){    
          

            if(stack.isEmpty()){
                result[index--] = -1;
            }

            else if(!stack.isEmpty() && stack.peek() > arr[ptr]  ){
                result[index--] = stack.peek();
            }
            else if(!stack.isEmpty() && stack.peek()<= arr[ptr]  ){
                while(!stack.isEmpty() && stack.peek() <= arr[ptr]   ){
                    stack.pop();
                }

                if(!stack.isEmpty()){
                    result[index--] = stack.peek();
                }
                else{
                    result[index--] = -1;
                }
            }

            stack.push(arr[ptr]);
        }


        return result;

    }
    public int[]   arrayNearestSmallestToRight(int[] arr){
        /*
        QUESTION
        [1,3,2,4]
        [-1,2,-1,-1] -- find the nearest smallest element on right if not return -1

        */

        //USING STACK(Array Brute force O(n^2) inner loop depends on outer loop ie for(i=0 to arr.leng){for(j = i to arr.length)})
        /*
          [1,3,2,4]   ---            -->move ptr till 0
                 |            2       if stack is empty 
                ptr           4         put -1 in result
                                      if stack is not empty and if the top element of stack <  ptr  
                                        put top of stack in result  ka backside
                                      if stack is not empty and if top of stack  >= ptr 
                                           pop while stack is not empty and top of stack  >= ptr 
                                           if stack is not empty put top element in result  ka backside
                                           if stack empty put -1 in result  ka backside
                                       push the element to stack  
        
        Time : O(n) as we reduce n(length of array ) by 1
        Space: O(n)
        */  

        Stack<Integer> stack = new Stack<>();
        int[] result = new int[arr.length]; int index = arr.length-1;

        for(int ptr = arr.length-1 ; ptr >=0 ; ptr--){

            if(stack.isEmpty()){
                result[index--] =-1;
            }
            else if(!stack.isEmpty() && stack.peek() < arr[ptr] ){
                result[index--] = stack.peek();
            }
            else if( !stack.isEmpty() && stack.peek() >= arr[ptr] ){
                while(!stack.isEmpty() && stack.peek() >= arr[ptr] ){
                    stack.pop();
                }
                if(!stack.isEmpty()){
                    result[index--] = stack.peek();
                }
                else{
                    result[index--] = -1;
                }
                 
            }

            stack.push(arr[ptr]);
        }

        return result;






    }
    public int[]   arrayConsecutiveGreatestToLeft(int[] arr){
        /*
        QUESTION
        [100,80,60,70,75,85]
        [-1,1,2,0,2,4] -- find the no of  consecutive greatest element on left

        */

        //USING STACK(Array Brute force O(n^2) inner loop depends on outer loop ie for(i=0 to arr.leng){for(j = i to arr.length)})
        /*
          [100,80,60,70,60,75,85]        -->move till arr.length-1
           |                     60,2       if stack is empty 
          ptr                    80,1          put -1 in result
                                 100,0      if stack is not empty and if top element of stack[0]  < ptr  (find the nearest smallest on left after that there will be consecutive greatest)
                                                put top of stack[1] in result
                                            if stack is not empty and  if top of stack[0] >= ptr 
                                               pop while stack is not empty and  top of stack[0] >= ptr   
                                               if stack is not empty put top of stack[1] in result
                                               if stack empty put -1 in result
                                            push the element and index to stack   

                                

            [-1,-1,-1,2,-1,4,5]                 result is the index of nearest smallest to left 
                                                  nearestSmallestOnLeft is at  result[i];currentindex is at i
                                                  noOfElement  = i - result[i] -1;
                                                  result[i] =  noOfElement

        
       
       
        Time : O(n) as we reduce n(length of array ) by 1
        Space: O(n)
        */  



        Stack<Integer[]> stack = new Stack<>();
        int[] result = new int[arr.length];int index =0;
        for(int ptr=0 ; ptr <= arr.length-1 ; ptr++){

            if(stack.isEmpty()){
                result[index++] = -1;
            }
            else if(!stack.isEmpty() && stack.peek()[0] < arr[ptr]){
                result[index++] =  stack.peek()[1];
            }
            else if(!stack.isEmpty() && stack.peek()[0] >= arr[ptr]){
                while(!stack.isEmpty() && stack.peek()[0] >= arr[ptr]){
                    stack.pop();
                }

                if(!stack.isEmpty()){
                    result[index++] = stack.peek()[1];
                }
                else{
                    result[index++] = -1;
                }  
            }


            stack.push(new Integer[]{arr[ptr], ptr});
        }

        for(int i=0 ; i <= result.length-1;i++){
            int noOfElemet = i - result[i]-1;
            result[i] = noOfElemet;
        }

        return result;






    }
    public int[]   arrayConsecutiveSmallestToLeft(int[] arr){
        /*
        QUESTION
        [100,80,60,70,75,85]
        [0,0,0,1,2,4] -- find the no of  consecutive smallest element on left

        */

        //USING STACK(Array Brute force O(n^2) inner loop depends on outer loop ie for(i=0 to arr.leng){for(j = i to arr.length)})
        /*
          [100,80,60,70,75,85]          -->start from the left so that the left  side of ptr will be in stack alays 
           |                    60,2       if stack is empty 
          ptr                   80,1            put -1 in result
                                100,0      if stack is not empty and if top element of stack[0]  > ptr  (find the nearest greatest on left after that there will be consecutive smallest)
                                                put top of stack[1] in result
                                            if stack is not empty and  if top of stack[0] <= ptr 
                                               pop while stack is not empty and  top of stack[0] <= ptr   
                                               if stack is not empty put top element[1]
                                               if stack empty put -1
                                            push the element and index to stack   

        [-1,0,1,1,3,1,0]                       result is the index of nearest greatest to left 
                                                  nearestGreatestOnLeft is at  result[i];currentindex is at i
                                                  noOfElement  = i - result[i] -1;
                                                  result[i] =  noOfElement

                                            
                                                   
                                        

        
       


       
        Time : O(n) as we reduce n(length of array ) by 1
        Space: O(n)
        */  



        Stack<Integer[]> stack = new Stack<>();
        int[] result = new int[arr.length];int index =0;
        for(int ptr=0 ; ptr < arr.length ; ptr++){

            if(stack.isEmpty()){
                result[index++] = -1;
            }
            else if(!stack.isEmpty() && stack.peek()[0] > arr[ptr]){
                result[index++]  = stack.peek()[1];
            }
            else if(!stack.isEmpty() && stack.peek()[0] <= arr[ptr]){
                while(!stack.isEmpty() && stack.peek()[0] <= arr[ptr]){
                    stack.pop();
                }

                if(!stack.isEmpty()){
                    result[index++]  = stack.peek()[1];
                }
                else{
                    result[index++]  = -1;
                }  
            }


            stack.push(new Integer[]{arr[ptr], ptr});
        }

        for(int i=0 ; i <= result.length-1;i++){
            int noOfElemet = i - result[i]-1;
            result[i] = noOfElemet;
        }

        return result;





    }
    public int[]   arrayConsecutiveGreatestToRight(int[] arr){

        /*
        QUESTION
        [100,80,60,70,60,75,85] 
         [0, 0, 4, 0, 2, 1, 0]] -- find the number of  consecutive greater element on right 
        
 

        */
        //USING STACK(Array Brute force O(n^2) inner loop depends on outer loop ie for(i=0 to arr.leng){for(j = i to arr.length)})
        /*
        [100,80,60,70,60,75,85]    -    ->move till 0  
                            |     75,5     if stack is empty 
                            ptr   85,6         put -1 in result
                                           if stack is not empty and if the top element of stack[0] <  ptr   (find the nearest smallest on right after that there will be consecutive greatest)
                                               put top of stack[1] in result in result  ka backside
                                           if stack is not empty and if top of stack[0]  >= ptr 
                                               pop while stack is not empty and top of stack[0]  >= ptr 
                                               if stack is not empty put top element[1] in result in result  ka backside
                                               if stack empty put -1 in  result  ka backside
                                            push the element to stack  
                                       
                            
         [1,2,-1,4,-1,-1,-1]               result is the index of nearest smallest to right
                                                if(result[i] != -1){ 
                                                    means nearest smallest element at right is at index result[i] , current index is i
                                                    noOfElements = result[i] - i -1;
                                                }
                                                else{
                                                    means there is no smallest element on right and all elements are greater ,current index is i
                                                    noOfGreatestElementOnRight = arr.length - i - 1;
                                                }
                                                result[i] = noOfGreatestElementOnRight;
                                                
                                            }
                                            return result;


                                                         


        Time : O(n) as we reduce n(length of array ) by 1
        Space: O(n)
        */  

        Stack<Integer[]> stack = new Stack<>();
        int[] result = new int[arr.length];int index = arr.length-1;

        for(int ptr = arr.length-1 ; ptr >=0 ; ptr--){

            if(stack.isEmpty()){
                result[index--] = -1;
            }
            else if(!stack.isEmpty() && stack.peek()[0] < arr[ptr] ){
                result[index--]  = stack.peek()[1];
            }
            else if( !stack.isEmpty() && stack.peek()[0] >= arr[ptr] ){
                while(!stack.isEmpty() && stack.peek()[0] >= arr[ptr] ){
                    stack.pop();
                }
                if(!stack.isEmpty()){
                    result[index--]  = stack.peek()[1];
                }
                else{
                    result[index--]  = -1;
                }
                 
            }

            stack.push(new Integer[]{arr[ptr], ptr});
        }


        for(int i=0 ; i <= result.length-1; i++){
            int noOfElements = 0;
            if(result[i] != -1){ 
                noOfElements = result[i] - i-1;
            }
            else{
                noOfElements = arr.length - i - 1;
            }
            result[i] = noOfElements;
            
        }
        return result;







    }
    public int[]   arrayConsecutivemallestToRight(int[] arr){
        /*
        QUESTION
        [100,80,60,70,60,75,85] 
        [6, 4, 0, 1, 0, 0, 0]] -- find the number of  consecutive smallest  element on right 
        
        */


        //USING STACK(Array Brute force O(n^2) inner loop depends on outer loop ie for(i=0 to arr.leng){for(j = i to arr.length)})
        /*
        [100,80,60,70,60,75,85]    -    ->start from the right so that the right side of ptr will be in stack alays 
                            |     75,5     if stack is empty then put -1
                            ptr   85,6          put -1 at back of result
                                           if stack is not empty and if the top element of stack[0] >  ptr  (find the nearest greatest on right after that there will be consecutive smallest)
                                                put top of stack[1] at back of result
                                           if stack is not empty and if top of stack[0]  <= ptr 
                                               pop while stack is not empty and top of stack[0]  <= ptr 
                                                if stack is not empty put top element[1] at back of result
                                                if stack empty put -1 at back of result
                                           push the element to stack  

        [-1, 6, 3, 5, 5, 6, -1]            result is the index of nearest greatest  to right          
                                           if result[i] != -1
                                             means nearest greatest to right is at index result[i] , current index is i
                                             noOfElements = result[i] - i -1
                                           else if result[i] == -1
                                              means no greatest to right all elements are smaller , current index is i
                                              noOfElements = arr.length - i -1
                                        


       
       
        Time : O(n) as we reduce n(length of array ) by 1
        Space: O(n)
        */  

        Stack<Integer[]> stack = new Stack<>();
        int[] result = new int[arr.length];int index = arr.length-1;

        for(int ptr = arr.length-1 ; ptr >=0 ; ptr--){

            if(stack.isEmpty()){
                result[index--] = -1;
            }
            else if(!stack.isEmpty() && stack.peek()[0] > arr[ptr] ){
                result[index--] = stack.peek()[1];
            }
            else if( !stack.isEmpty() && stack.peek()[0] <= arr[ptr] ){
                while(!stack.isEmpty() && stack.peek()[0] <= arr[ptr] ){
                    stack.pop();
                }
                if(!stack.isEmpty()){
                    result[index--] = stack.peek()[1];
                }
                else{
                    result[index--] = -1;
                }
                 
            }

            stack.push(new Integer[]{arr[ptr], ptr});
        }



        for(int i=0 ; i <= result.length-1; i++){
            int noOfElements = 0;
            if(result[i] != -1){ 
                noOfElements = result[i] - i-1;
            }
            else{
                noOfElements = arr.length - i - 1;
            }
            result[i] = noOfElements;
            
        }
        return result;








    }
    public int     arrayHistogramMaxArea(int[] arr){
         /*
        QUESTION
        [6,2,5,4,5,1,5]         -- find the maximum area of a rectangle that can be formed 
                                    Eg for 6 -- we cant move left or right so w = 1; ht - 6
        |6               6             for 2 --we can move 1 left 4 right so w = 6 ; h =2
        |__    5     5  __             for 5 -- we cant move left or right so w = 1; ht = 5
        |  |   __  4 __|  |            for 5 -- we cant move left by 1 and  right by 1 so w =3; ht = 5
        |  |  |  |__|  |  |
        |  | 2|  |  |  |  |        NOTE: arrayHistogramMaxArea() and arrayContainerMaxArea() are different because
        |  |__|  |  |  |  |               in histogram we can move only as long as adjacent ht is less or equal 
        |  |  |  |  |  |  |               in container we can move till the very end
        |  |  |  |  |  |  |
        -------------------
         1   1  1  1  1  1

        
        */

        
        //USING STACK(Array Brute force O(n^2) inner loop depends on outer loop ie for(i=0 to arr.leng){for(j = i to arr.length)})
        /*
        [6,2,5,4,5,1,5] -- --   height = arr
                                width  = consecutivearrayGreatestToLeft(arr) + arrayconsecutiveGreatestToRight(arr) + 1(width of bar itself)
                                area = width * height
        
        Time : O(n) as we reduce n(length of array ) by 1
        Space: O(n)
        */

        int[] height = arr;
         
        int[] arrayConsecutiveGreatestToLetf = arrayConsecutiveGreatestToLeft(arr);
        int[] arrayConsecutiveGreatestToRight = arrayConsecutiveGreatestToRight(arr);
        int[] width = new int[arr.length];
        for(int i=0 ; i <= width.length-1;i++){
            width[i] = arrayConsecutiveGreatestToLetf[i] + arrayConsecutiveGreatestToRight[i] +1;
        }
        
        int maxArea = Integer.MIN_VALUE;
        for(int i=0 ; i <= width.length-1;i++){
            int area = width[i]*height[i];
            maxArea = Math.max(area,maxArea);
        }
        return maxArea;
       

    } 
    public int     arrayContainerMaxArea(int[] arr){
        /*
        QUESTION
         [1,8,6,2,5,4,8,3,7]        -->find the maximum area of a water  that can be contained in a container
                                        EG : Bw 8 and 7 wt = 7 ; ht = 7                                 
         |    |              |           
         |    |--- ----------|---- |     
         |    |  |           |     |      
         |    |  |     |     |     |
         |    |  |     |  |  |     |
         |    |  |     |  |  |  |  |
         |    |  |  |  |  |  |  |  |
         | |  |  |  |  |  |  |  |  |
          ------------------------------------
         */
 
         //USING STAKC --> Time:O(n) , Space:O(n)
         /*
         No stack soln
          */

 
         //USING ARRAY MULTIPTR(ARRAY REQUIRES MULTIPTR)--> Time:O(n) , Space:O(1)
         /*
         [1,8,6,2,5,4,8,3,7]
          |                |
          ptr1             ptr2 -- initialise ptr1 and ptr2
                                    while (ptr1 <= ptr2) {      move ptr1 ptr2 till ptr2 < ptr1(ptr1 ptr2 at ptr2 < ptr1 ; cb moving ptr enc till ptr1 == ptr2 ; ca moving pr enc till ptr2 < ptr1 )
                                            
                                        int width  = ptr2 - ptr1;
                                        int height = Math.min(arr[ptr1], arr[ptr2]);
                                        int area = width*height;
                                        maxarea = Math.max(area,maxarea);

                                        if (arr[ptr1] <= arr[ptr2])
                                            move ptr1 ahead
                                        else if(arr[ptr2] <= arr[ptr1])
                                            move ptr2 behind
                                    }

         
        Time : O(n) as we reduce n(length of array ) by 1
        Space: O(n)
        */
        /*
        int maxarea = 0;
        int ptr1 = 0;
        int ptr2 = arr.length - 1;
        
        while (ptr1 <= ptr2) {
            int width  = ptr2 - ptr1;
            int height = Math.min(arr[ptr1], arr[ptr2]);
            int area = width*height;
            maxarea = Math.max(area,maxarea);

            if (arr[ptr1] <= arr[ptr2])
                ptr1++;
            else if(arr[ptr2] <= arr[ptr1])
                ptr2--;
        
        }
        return maxarea;
        */
        return 0;
    }
    public int     arrayContainerTotalArea(int[] arr){

        /*
        QUESTION
        [3,0,0,2,0,4]         -- find the total water that can be stored in crevices
                       4         Eg 3 can store ht= 0 on top
         3             __           0 can store ht=  3 on top
         __       2   |  |          0 can store ht=  0 on top 
        |  |     __   |  |          2 can store ht=  1 on top
        |  |0  0|  | 0|  |          4 can store ht=  0 on top
        |  |____|  |__|  |           
        */

        //USE STACKArray Brute force O(n^2) inner loop depends on outer loop ie for(i=0 to arr.leng){for(j = i to arr.length)}) -->Time:O(n) , Space:O(n)
        /*
        [3,0,0,2,0,4] --> height = min(arrayGreatestToLeft,arrayGreatestToRight) - arr[i] //In arrayGreatestToLeft add line  result[0] = arr[0] before returning result because in leftmost index you want that element  itself and not -1
                          width = 1                                                       //In arrayGreatestToRight add line    result[result.length-1] = arr[arr.length-1] because  at the rightmost index you want that element and not -1
                          area = height*width                                             //Add condition height[i] = (ht < 0)? 0:ht because if ht comes -ve total area will be reduced
                                                                                          //EG [7,4,0,9]
        Time : O(n) as we reduce n(length of array ) by 1                                 //arrayGreatestToLeft= [7,7,7,7]
        Space: O(n)                                                                       //arrayGreatestToRight = [9,9,9,9]
        */                                                                               //height = [0,3,7,0 not -2]
    
        /*
        int[] arrayGreatestToLeft = arrayGreatestToLeft(arr);
        int[] arrayGreatestToRight = arrayGreatestToRight(arr);
        int[] height = new int[arr.length];
        for(int i=0; i <= height.length-1;i++){
            int ht = Math.min(arrayGreatestToLeft[i],arrayGreatestToRight[i]) - arr[i]; 
            height[i] = (ht < 0)? 0:ht;
        }


        int[] width = new int[arr.length];
        for(int i=0; i <= width.length-1;i++){
            width[i] = 1;
        }
    

        int totalArea = 0;
        for(int i=0; i <= height.length-1;i++){
            int area = height[i]*width[i];
            totalArea = totalArea+ area;
        }

        return totalArea;
        */

        //USING ARRAY MULTIPTR(ARRAY REQUIRES MULTIPTR) -->Time:O(n) Space:O(1)
        /*
        [3,0,0,2,0,4] 
         |         |
         ptr1    ptr2  -- initilise ptr1 to 0 ptr2 to arr.length-1
                          while(ptr1 < ptr2){                          --move ptr1 ptr2 till ptr1 == ptr2(ptr1 ptr2 at ptr1 == ptr2 , bc enc till ptr1 < ptr2 , ca en till ptr1 = ptr2)
                            if(arr[ptr1] == arr[ptr2]){                     if ptr1 == ptr2
                                maxLeft = Math.max(arr[ptr1], maxLeft);        find max height on left  
                                if(arr[ptr1]<= maxLeft ){                      if currentHight <= maxHeightOnLeft
                                    int height = maxLeft - arr[ptr1];           ht = maxHeightOnLeft - currentHight
                                    int width= 1;                               wt = 1
                                    int area = width*height;                    area = ht*wt
                                    totalArea = totalArea + area;}
                                ptr1++;                                        move ptr1 ahead OR
                                //ptr2--; }                                    move ptr2 behind(then use logic for maxRight instead of maxLeft)
                            
                            else if(arr[ptr1] < arr[ptr2]){                    if ptr1 < ptr2
                                maxLeft = Math.max(arr[ptr1], maxLeft);           find max height on left  
                                if(arr[ptr1]<= maxLeft ){                         if currentHight <= maxHeightOnLeft
                                    int height = maxLeft - arr[ptr1];                ht = maxHeightOnLeft - currentHight
                                    int width= 1;                                    wt = 1
                                    int area = width*height;                         area = ht*wt
                                    totalArea = totalArea + area;}
                                ptr1++; }                                         move ptr1 ahead     
                            
                            else if(arr[ptr1] > arr[ptr2]){                    if ptr1 > ptr2           
                                maxRight = Math.max(arr[ptr2], maxRight);            find max height on right
                                if(arr[ptr2]<= maxRight ){                           if currentHeight <= maxHeightONRight
                                    int height = maxRight - arr[ptr2];                  ht = maxHeightONRight-currentHight
                                    int width= 1;                                       wt = 1
                                    int area = width*height;                            area = ht*wt
                                    totalArea = totalArea + area;}
                                ptr2--;                                             move ptr2 behind
                            }
                        }

                        return totalArea;

        
         
         
        */
        
        /*
        int ptr1 = 0;
        int ptr2 = arr.length-1;
        int maxLeft = Integer.MIN_VALUE;
        int maxRight = Integer.MIN_VALUE;
        int totalArea = 0;
        while(ptr1 < ptr2){
            
            if(arr[ptr1] == arr[ptr2]){
                maxLeft = Math.max(arr[ptr1], maxLeft);
                
                if(arr[ptr1]<= maxLeft ){
                    int height = maxLeft - arr[ptr1];
                    int width= 1;
                    int area = width*height;
                    totalArea = totalArea + area;
                }
                
                
                
                ptr1++;
                //ptr2--;
            }
            if(arr[ptr1] < arr[ptr2]){
                maxLeft = Math.max(arr[ptr1], maxLeft);
                
                if(arr[ptr1]<= maxLeft ){
                    int height = maxLeft - arr[ptr1];
                    int width= 1;
                    int area = width*height;
                    totalArea = totalArea + area;
                }
                
                
                ptr1++;
            }
            else if(arr[ptr1] > arr[ptr2]){
                maxRight = Math.max(arr[ptr2], maxRight);
                
                if(arr[ptr2]<= maxRight ){
                    int height = maxRight - arr[ptr2];
                    int width= 1;
                    int area = width*height;
                    totalArea = totalArea + area;
                }
                
                
                ptr2--;
            }
            
                
                
            
            
        }
        
        return totalArea;
        */


        return 0;
    
        

       }
    public int[]   arrayDaysToWaitForNextGreatestTemp(int[] arr){
        /*
        temp = [73,74,75,71,69,72,76,73] -- temp[i] goves temp on ith day
                                            return result array which gives no of days to wait for warmer temp
        
        */


        //USING STACK
        /*
        Same as arrayNearestGreaterToRight() but stack will hold int[element,index]
        and instead of element add index of nearest greatest to result

        [1,3,2,4]   ---  -->move ptr till 0
              |         2    if stack is empty 
              ptr       4         put -1 in result 
                            if stack is not empty and if the top element of stack ka 0 > ptr  
                               put top of stack ka 1 in result ka backside
                            if stack is not empty and if top of stack ka 0 <= ptr 
                                pop while stack is not empty and top of stack ka 0 <= ptr 
                                if stack is not empty put top of stack ka 1 in result  ka backside
                                if stack empty put -1 in result  ka backside
                            push [element,index] to stack  
                            
                            iterate over result
                              if res[i] != -1
                                res[i] = res[i] - i
                             else
                                res[i] = 0

                            return result
        Time : O(n) as we reduce n(length of array ) by 1
        Space: O(n)   
        */

        int[] result  = new int[arr.length];int index =arr.length-1;
        Stack<int[]> stack = new Stack<>();
        for(int ptr = arr.length-1; ptr >=0 ; ptr --){    
            if(stack.isEmpty()){
                result[index--] = -1;
            }
            else if(!stack.isEmpty() && stack.peek()[0] > arr[ptr]  ){
                result[index--] = stack.peek()[1];
            }
            else if(!stack.isEmpty() && stack.peek()[0]<= arr[ptr]  ){
                while(!stack.isEmpty() && stack.peek()[0] <= arr[ptr]   ){
                    stack.pop();
                }
                if(!stack.isEmpty()){
                    result[index--] = stack.peek()[1];
                }
                else{
                    result[index--] = -1;
                }
            }

            stack.push(new int[]{arr[ptr],ptr});
        }
        
        for(int i=0 ; i <= result.length-1;i++){
            if(result[i] != -1){
                result[i] = result[i] - i;
            }
            else{
                result[i] = 0;
            }
        }

        return result;

    }
    public int     stringEvaluetePostFixExpression(String s){

        /*
        Question
        Infix expression                            :Operator bw operands with bracket and operation precedence is used
                                                     Eg: ((3*1) + 2)-9

        Prefix Operation(Polish notation)           :Operator before operand without bracket
                                                    Eg: "*+69-31" = (6+9)*(3-1) --operator jumps to right 

        PostFix Operation(Rreverse Polish notation) :Operator after operand without bracket
                                                     Eg: "231*+9-" = (2 + (3*1)) - 9 -- oprtatot jumps to left
   
        */

        //USING STACK
        /*
         "231*+9-"  
          |          
          ptr   --iterate over string
                    if not operator
                        push to stack
                    else if operator
                        if(stack.isEmpty()){return -1}  //null check:stack is empty then return -1
                        op1 = stack.pop() and convert character to int
                        op2 = stack.pop() and convert character to int
                        stack.push(op2 +,-,*,/ op1);
                    
                   return stack.peek();
                
        Time:O(n)
        Space:O(1)
                     
        
        
        */
        
        Stack<Integer> stack  = new Stack<>();
        
        int ptr = 0;
        while(ptr <= s.length()-1){
            //if(!isOperator(s.charAt(ptr))){
                stack.push(Integer.parseInt("" + s.charAt(ptr) ));
            //}
            //else if(isOperator(s.charAt(ptr))){
                
                if(stack.isEmpty()){return -1;}
                
                int operand1 = Integer.parseInt(""+stack.pop());
                int operand2 = Integer.parseInt(""+stack.pop());

                if(s.charAt(ptr) == '+'){
                    stack.push(operand2 + operand1);
                }
                else if(s.charAt(ptr) == '-'){
                    stack.push(operand2 -operand1);
                }
                else if(s.charAt(ptr) == '*'){
                    stack.push(operand2*operand1);
                }
                else if(s.charAt(ptr) == '/'){
                    stack.push(operand2/operand1);
                }
                

            //}
            
            
            
            ptr++;
        }
        
        return stack.peek();

        //isOperaror()
        /*
        public static boolean isOperator(char ch){
            return ch == '+' || ch == '-' || ch == '*' || ch == '/';
        }
        
        */
        

        
    }
    public int     stringEvaluetePreFixExpression(String s){
        /*
        Question
        Infix expression                            :Operator bw operands and bracket and operation precedence is used
                                                     Eg: ((3*1) + 2)-9

        Prefix Operation(Polish notation)           :Operator before operand and no bracket 
                                                    Eg: "*+69-31" = (6+9)*(3-1) --operator jumps to right 

        PostFix Operation(Rreverse Polish notation) :Operator after operand and no bracket 
                                                     Eg: "231*+9-" = (2 + (3*1)) - 9 -- oprtatot jumps to left
   
        */

        //USING STACK
        /*
         "*+69-31" 
                |          
                ptr --iterate over string in reverse order
                    if not operator
                        push to stack
                    else if operator
                        if(stack.isEmpty()){return -1}  //null check:stack is empty then return -1
                        op1 = stack.pop() and convert character to int
                        op2 = stack.pop() and convert character to int
                        stack.push(op1 +,-,*,/ op2);
                    
                   return stack.peek();
                
        Time:O(n)
        Space:O(1)
                     
        
        
        */
        
        Stack<Integer> stack  = new Stack<>();
        
        int ptr = s.length()-1;
        while(ptr >= 0){
            //if(!isOperator(s.charAt(ptr))){
                stack.push(Integer.parseInt("" + s.charAt(ptr) ));
            //}
            //else if(isOperator(s.charAt(ptr))){
                
                if(stack.isEmpty()){return -1;}
                
                int operand1 = Integer.parseInt(""+stack.pop());
                int operand2 = Integer.parseInt(""+stack.pop());

                if(s.charAt(ptr) == '+'){
                    stack.push(operand1 + operand2);
                }
                else if(s.charAt(ptr) == '-'){
                    stack.push(operand1 -operand2);
                }
                else if(s.charAt(ptr) == '*'){
                    stack.push(operand1*operand2);
                }
                else if(s.charAt(ptr) == '/'){
                    stack.push(operand1/operand2);
                }
                

            //}
            
            
            
            ptr--;
        }
        
        return stack.peek();

        //isOperaror()
        /*
        public static boolean isOperator(char ch){
            return ch == '+' || ch == '-' || ch == '*' || ch == '/';
        }
        
        */
        

        
    }
    public int     stringEvaluateArithmeticExpression(String s) {
        /*
        "22-3* 2" --Evaluate arithmetic expression based on BODMAS rule
                    and expression will have spaces 
        */

        //USING STACK
        /*
        "22-3*2 "  -- currentNumber = 0
                     previousOperator = '+' 
                     for (int i = 0; i <= s.length()-1; i++) {                   --iterate over string
                        if(s.charAt(i) == ' ' && i!= s.length()-1){                    if ch is whitespace and not the last index(reason for 2nd condition explained in EG)               
                            continue;                                                     continue
                        }
                        if (Character.isDigit(s.charAt(i))) {                         if ch is digit
                            currentNumberString = currentNumberString + s.charAt(i);    currentNumber = add character using helper string
                            currentNumber = Integer.parseInt(currentNumberString);      previousOperator = same
                            previousOperator = previousOperator                   
                        } 
                        if (isOperator(s.charAt(i)) || i== s.length()-1 ) {          if ch is operator || i is at last index(reason for 2nd condition explained in EG)               
                            if (previousOperator == '+')                               if prevOperator = '+'
                                stack.push(currentNumber);                              push +currentNumber to stack
                            else if (previousOperator == '-')                          if prevOperator = '-'
                                stack.push(-currentNumber);                              push -currentNumber to stack
                            else if (previousOperator == '*')                          if prevOperator = '*'
                                stack.push(stack.pop() * currentNumber);                   pop from stack , multiply and push to stack
                            else if (previousOperator == '/')                          if prevOperator = '/'
                                stack.push(stack.pop() / currentNumber);                  pop from stack , divide and push to stack

                            currentNumber = 0;currentNumberString = "";                currentNumber = 0 and also set the helper string
                            previousOperator =  s.charAt(i);                           prevOperator = current ch
                                                                              
                            }
                        } 
                        int result = 0;                                                             
                        while (!stack.isEmpty()) {                                --while stack is not empty
                            result += stack.pop();                                    pop from stack and add to result
                        }                                                            ss only + - digits will be left in stack
                        return result;               
                                                                                    EG
                                                                                    " 22*2+7-8 "

                                                                                    cn = 0
                                                                                    po ='+'

                                                                                    i=0
                                                                                    it is space
                                                                                    continue

                                                                                    i=1
                                                                                    it is digit
                                                                                    cn = 2
                                                                                    po = '+'

                                                                                    i=2
                                                                                    it is digit
                                                                                    cn = 22
                                                                                    po = '+'

                                                                                    i=3
                                                                                    it is * operator 
                                                                                    prevop is + so push 22 to stack
                                                                                    cn = 0
                                                                                    po = '*'

                                                                                    i=4
                                                                                    it is digit
                                                                                    cn=2
                                                                                    po = '*'

                                                                                    i=5
                                                                                    it is + operator
                                                                                    prevop is * so pop 22 from stack multiply with 2 and push 44 to stack
                                                                                    cn = 0
                                                                                    po = '+'

                                                                                    i=6
                                                                                    it is digit
                                                                                    cn = 7
                                                                                    po = '+'

                                                                                    i=7
                                                                                    it is - operator
                                                                                    prevop is + so push 7 to stack
                                                                                    cn = 0
                                                                                    po = '-'

                                                                                    i=8
                                                                                    it is digit
                                                                                    prevop is - so push -8 to stack
                                                                                    cn = 0
                                                                                    po = '-'
                                                                                    
                                                                                    stacck has -8 + 7 sp iterate and add

                                                                                    REASON FOR "i!= s.length()-1"  ;  "i== s.length()-1" :
                                                                                    Consider "3/2 " 
                                                                                    At  last index cn=2;po='/';stack has 3 and you havent evaluetad the / sign
                                                                                    So in 1st if you should not continue because we still have to evaluate / sign
                                                                                    So in 3rd if you should enter because you have to evaluate the / sign

        Time:O(n)
        Space:O(n)
        */
        /*
        public int stringEvaluateASrithmeticExpression(String s) 
            if (s == null || s.isEmpty()) return 0;
            
            Stack<Integer> stack = new Stack<Integer>();
            int currentNumber = 0;
            String currentNumberString = "";
            char previousOperator = '+';
            
            for (int i = 0; i <= s.length()-1; i++) {
                if(s.charAt(i) == ' ' && i!= s.length()-1){
                    continue;
                }
                if (Character.isDigit(s.charAt(i))) {
                    currentNumberString = currentNumberString + s.charAt(i);
                    currentNumber = Integer.parseInt(currentNumberString);
                }
                if (isOperator(s.charAt(i)) || i== s.length()-1 ) {
                    if (previousOperator == '-') {
                        stack.push(-currentNumber);
                    }
                    else if (previousOperator == '+') {
                        stack.push(currentNumber);
                    }
                    else if (previousOperator == '*') {
                        stack.push(stack.pop() * currentNumber);
                    }
                    else if (previousOperator == '/') {
                        stack.push(stack.pop() / currentNumber);
                    }
                    previousOperator =  s.charAt(i);
                    currentNumber = 0;
                    currentNumberString = "";
                }
            }  
            int result = 0;
            while (!stack.isEmpty()) {
                result += stack.pop();
            }
            return result;
        }

        public boolean isOperator(char c){
            return c == '+'|| c== '-' || c== '*' || c== '/';
        }
        */

        //USING ARRAY MULTIPTR
        /*
        "22-3*2 " -- instead of using a stack create a variable previousNumber
                     instead of pushing to stack update prev number, instead of popping from stack use prevNumber
                     instead of adding all stack elements in end add prevNumber in result every time  and also take care to add before reassigning previousNuber
        
        Time:O(n)
        Space:O(1)
        */

        /*
        public int stringEvaluateASrithmeticExpression(String s) 
            if (s == null || s.isEmpty()) return 0;
            
            Stack<Integer> stack = new Stack<Integer>();
            int currentNumber = 0;
            String currentNumberString = "";
            char previousOperator = '+';

            int previousNumber =0;
            int result = 0;
            
            for (int i = 0; i <= s.length()-1; i++) {
                if(s.charAt(i) == ' ' && i!= s.length()-1){
                    continue;
                }
                if (Character.isDigit(s.charAt(i))) {
                    currentNumberString = currentNumberString + s.charAt(i);
                    currentNumber = Integer.parseInt(currentNumberString);
                }
                if (isOperator(s.charAt(i)) || i== s.length()-1 ) {
                    if (previousOperator == '-') {
                        result = result + previousNumber;               --instead of adding in end add prevNumber to res before reassigning prevNumber
                        previousNumber = -currentNumber;                --instead of pushing update prev nuber
                    }
                    else if (previousOperator == '+') {
                        result = result + previousNumber;
                        previousNumber = -currentNumber;
                    }
                    else if (previousOperator == '*') {
                        previousNumber = previousNumber*currentNumber;
                    }
                    else if (previousOperator == '/') {
                        previousNumber = previousNumber*currentNumber;
                    }
                    previousOperator =  s.charAt(i);
                    currentNumber = 0;
                    currentNumberString = "";
                }
            }  
            result = result + previousNumber; 
            return result;
        }

        public boolean isOperator(char c){
            return c == '+'|| c== '-' || c== '*' || c== '/';
        }
        
        */
        return 0;
    }
    public void    stringValidParanthesis(String s) {
        /*
        Question
        {(1+2)-3} -- string has paranthesis((,{,[)) 
                        check if the paranthesis are valid
        
       */
        //USING STACK
        /*
        "{1+(3-2)}"------>iterate over string  
                             if ch is Lefbracket
                                push ch  to Stack                                        
                            if ch is RighBracket
                              if stack.isEmpty return false                  //null check:for empty stack
                              pop from stack if doesnt match return false
                            
                            if stack is empty in the end  then true else false
        Time : O(n) as we reduce n(length of str ) by 1
        Space: O(n)
        */

        /*
        Stack<Character> stack = new Stack<Character>();
        for (char ch : s.toCharArray()) {
            if (isLeftBracket(ch)) {
                stack.push(ch);}

            if (isRightBracket(ch)) {
                if (stack.isEmpty()) {return false;}     

                var top = stack.pop();
                if (isBracketUnmatch(top, ch)) {
                    return false;
                }
            }
        }
        
        return stack.isEmpty();

        
        public boolean  isLeftBracket(char item) {
            return item == '(' || item == '{' || item == '[' || item == '<';
        }
        public boolean  isRightBracket(char item) {
            return item == ')' || item == '}' || item == ']' || item == '>';
        }
        public boolean  isBracketUnmatch(char openbracket, char closebracket) {
            return closebracket == ')' && openbracket != '('
                    || closebracket == ']' && openbracket != '['
                    || closebracket == '}' && openbracket != '{'
                    || closebracket == '>' && openbracket != '<';
        }
    
        
        
        */


    }
    public void    stringValidParanthesWithRedundant(String s) {

        /*
        ((a+b)) -- string has  paranthesis along with redundant brackets(only '(' )
                   check if valid expression(no redundant) or not 
        */

        //USING STACK
        /*
        ((a+b)) -- iterate the string
                   if not rightBracket
                     push to stack
                   if rightBracket
                      if stack is empty{retrn false;}   //null check: null check for empty stack
                      pop top element from stack
                      while(stakck is not empty and stack peek  is not left braket){
                          if stack peek is operator
                            operatorEncountered = true
                          pop from stack 
                      }

                      if operatorEncountered == true
                        do nothing
                      if operatorEncountered == false
                         return false because there is no operator bw left and rightbracket
                    
                   return true    //if asked for valid or not:return stringValidParanthesWithRedundant(String s)
                                 //if asked for redundant or not: return stringValidParanthesWithRedundant(s) == true?false:true;




        
        */

        /*
        Stack<Character> stack = new Stack<>();
        for(int i=0 ; i <= s.length()-1;i++){
            if(!isRightBracket(s.charAt(i)) ){  
                stack.push(s.charAt(i));}
            else if(isRightBracket(s.charAt(i))){
                boolean operatorEncountered = false;  
                if(stack.isEmpty()){return false;}
                char top = stack.pop();

                while(!stack.isEmpty() && !isLeftBracket(stack.peek() ){
                    if(isOperator(stack.peek())){
                        operatorEncountered = true; }

                    stack.pop();
                }

                if(operatorEncountered){
                    //do nothing 
                }
                if(!operatorEncountered){
                    return false;
                }
            }
        }

        return true;                //if asked for valid or not:return stringValidParanthesWithRedundant(String s)
                                    //if asked for redundant or not: return stringValidParanthesWithRedundant(s) == true?false:true;

        }




        public boolean isLeftBracket(char ch){
            return ch == '(' 
        }
        public boolean isRightBracket(char ch){
            return ch == ')'
        }
        public boolean isOperator(char ch){
            return ch == '+' || ch == '-'|| ch == '*' || ch == '/'
        }

        */
    }
    public int     stringSubstringValidParanthesisLongestShortest(String s) {
        /*
        ")()()()" -- find all substring of string 
                     with valid paranthesis(only '(' ) and return the count , longest and shortest
            
        */
        
        
        //USING STACK
        /*
         )()())          -->iterate over string  
        [0,1,1,1,1,0]     if ch is Lefbracket
                                push index  to Stack                                        
                            if ch is RighBracket
                              if  !stack.isEmpty 
                                  pop from stack  
                                  arr[i] =   1  which will populate array for closing(i) and its corresponding opening(top) bracket with 1
                                  arr[top] = 1

        [0,1,1,1,1,0]   -->  find subarray with continuous 1 ka longest, shortest 


        Time : O(n) as we reduce n(length of str ) by 1
        Space: O(n)
        */

        
        Stack<Integer> stack = new Stack<>();
        int[] arr = new int[s.length()];
        for(int i=0 ; i <= s.length()-1;i++){
            if(s.charAt(i) == '('){
                stack.push(i);
            }
            else if(s.charAt(i) == ')'){
                if(!stack.isEmpty()){
                    var top = stack.pop();
                    arr[i] = 1;
                    arr[top] = 1;
                }
            }
        }
        

        //return arraySubArrayKaContinuousOneKaLongestLength(arr);// fn in recursion array--multiptr
        return 0;
 
    }
    public String  stringReversee(String s){
        /*
        s = "abc" -- reverse the string 
         */

         //USING STACK
        /*
        "abc"   ['a','b','c']   ---iterate through string and ass to stack
         |                         iterate through stack and add to string
         ptr   
              
        
        */
        Stack<Character> stack = new Stack<>();
        int ptr = 0;
        while(ptr <= s.length()-1){
            stack.push(s.charAt(ptr));
            ptr++;
        }
        
        StringBuffer sb = new StringBuffer();
        while(!stack.isEmpty()){
            sb.append(stack.pop());
            
        }
        return sb.toString();
    }
    public void    queueReverse1stKElements(Queue<Integer> queue,int k){
        /*
        [1,2,3,4,5] k=3 -- reverse the 1st k elements of queue
                          EG:[1,2,3,4,5] k=3 -- [3,2,1,4,5]
         
        */
        
         //USING STACK
         /*
         [1,2,3,4,5] --  [4,5]   --iterate 1 to k and remove element from queue and add to stack 
                         [3,2,1] 

                         [4,5,3,2,1]  --iterate stack pop element and add to queue
                         []

                         [3,2,1,4,5]  --iterate 1 to queue.size()-k and remove element from queue and add element to queue
                         []

         
         */
        Stack<Integer> stack = new Stack<>();
        for(int i=1; i<= k;i++){
            stack.push(queue.remove());
        }
        
        while(!stack.isEmpty()){
            queue.add(stack.pop());
        }
        
        for(int i=1 ; i <= queue.size()-k;i++){
            queue.add(queue.remove());
        }
        
 
        
        
    }
    



    //QUEUE
    /*
    STACK IDENTIFY
    ARRAY  BRUTE FORCE O(n^2) INNER LOOP DEPENDS ON OUTER LOOP ie for(int i=0 ; i<=n;i++){for(j =0 ; j< i ; j++)}-- j depends on i        
     */    
    public String stringFirstUniqueCharacterReplaceAtEveryPosition(String s){

        /*
        Question
        abbabcdda -- replace every charater with 1st unique(non repeating) character until then
                     if not present replce by # 
                     Eg:"ababdcdda" -- "aab#ddccc"
        */

        //USING QUEUE(Array Brute force O(n^2) inner loop depends on outer loop) AND HASHMPAP()ARRAY REUIRES STORING)
        /*
        abbabcdda -- iterte through string
                      add character as key and freq as value to map
                      push ch to queue
                      pop while queue is not empty and top of queue ka frequency  >=2
                      if queue is empty then firstNonRepeatingChar = '#'   //null check: if queue is empty
                      else firstNonRepeatingChar = top of queue

                      res = res = firstgarater

        Time:O(n^2) -- Queue qives O(n^2) DLL gives O(n) but hard to implement
        Space:O(1)
        */
        String res = "";
        Queue<Character> queue = new ArrayDeque<>();
        Map<Character,Integer> map = new HashMap<>();
        for(int i=0 ; i <= s.length()-1 ; i++){
 
        
            if(!map.containsKey(s.charAt(i))){
                map.put(s.charAt(i),1);
            }
            else{
                map.put(s.charAt(i) , map.get(s.charAt(i)) +1 );
                
            }
            
           queue.add(s.charAt(i));
            while(!queue.isEmpty() && map.get(queue.peek()) >=2){
                queue.remove();
            }
            char firstNonRepeatingChar = ' ';
            if(queue.isEmpty()){firstNonRepeatingChar = '#';}
            else{firstNonRepeatingChar = queue.peek();}
            res = res + firstNonRepeatingChar; 

        }
        
        return res;
    }

    

    //HEAPS
    /*
    IDENTIFYING pq
    Array requires sorting is + K  maxheap  if you want min at bottom and max at top  is asked; 
                                   minheap if you want max at bottom and min at top  
                                   |
                                   |
                                  Sorting we can do min in nlogn not less than that  but we use heap of size k and convert it to nlogk
                                  Eg k smallest -- sorting n elements = O(nlogn) ; finding the element = O(1)--> O(nlogn + 1) = O(nlogn)
                                               -- for each  element  insert  in heap of size k  = O(log k) and then removing from heap of size k = O(logk) --> O(n * (logk + logk) = O(nlogk)




    */
    public int   arraykthSmallestElementt(int[] arr , int k){
        //USING MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)  -->Time:O(nlogn + n), Soace:O(1)
        /*
        Look in ARRAY --  MULTIPOINTERS SORT SEARCH  
         */


        //USING BINARY MAX HEAP(Array requires sorting  + K is given  ) ->Time:O(nlogk ), Soace:O(n)
        /*
        [7,10,4,3,20,15]  ---[10,20,15,7,4,3]  -- add  the elements to maxheap in desc order(so that max element at front can be popped)  and if size > k pop that element 
                              X  X  X              return top element  which will be kth smallest   
                            
        Time : O(n logk)   as we reduce n(length of arr) by half and sort upto k
        Space: O(k) as heap takes extra space
        */
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((Integer a, Integer b) ->{return b-a;});

        for(int i=0 ; i <arr.length ; i++){
            maxHeap.add(arr[i]);

            if(maxHeap.size() > k){
                maxHeap.remove();
            }

        }

        return maxHeap.peek();
        


    }
    public int   arraykthLargestElementt(int[] arr , int k){
        
        //USING MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)  -->Time:O(nlogn + n), Soace:O(1)
        /*
        Look in ARRAY --  MULTIPOINTERS SORT SEARCH  
        */

        //USING BINARY MIN HEAP(Array requires sorting  + K is given ) ->Time:O(nlogk ), Soace:O(n)
        /*
        [7,10,4,3,20,15]  --- [3,4,7,10,15,20]  -- add  the elements to min heap in asc order(so that min element at front can be popped) and  if size > k  pop the element 
                               X X X                return top element  in maxheap which will be kth largets  
   
        Time : O(n logk)   as we reduce n(length of arr) by half and sort upto k
        Space: O(n) as heap takes extra space

        */
        PriorityQueue<Integer> minHeap = new PriorityQueue<>((Integer a, Integer b) ->{return a-b;});

        for(int i=0 ; i <=arr.length-1 ; i++){
            minHeap.add(arr[i]);

            if(minHeap.size() > k){
                minHeap.remove();
            }

        }

        return minHeap.peek();


    }
    public int[] arrayKsmallestElementt(int[] arr , int k){

        //USING MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)  -->Time:O(nlogn + n), Soace:O(1)
        /*
        Look in ARRAY --  MULTIPOINTERS SORT SEARCH  
         */

        

       //USING BINARY MAX HEAP(Array requires sorting  + K is given) ->Time:O(nlogk ), Soace:O(n)
        /*
        [7,10,4,3,20,15]  ---[10,20,15,7,4,3]  -- add  the elements to maxheap in desc order(so that max element at front can be popped)  and if size > k pop that element 
                        X  X  X                   return all element  which will be kth smallest   


        Time : O(n logk)   as we reduce n(length of arr) by half and sort upto k
        Space: O(k) as heap takes extra space
        */
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((Integer a, Integer b) ->{return b-a;});

        for(int i=0 ; i <arr.length ; i++){
            maxHeap.add(arr[i]);

            if(maxHeap.size() > k){
                maxHeap.remove();
            }

        }

        int[] kSmallestarr = new int[maxHeap.size()];
        int index =0;
        for(int i = 0 ; i <= maxHeap.size()-1 ; i++){
            kSmallestarr[index++] = maxHeap.remove();
        }

        return kSmallestarr;
    }
    public int[] arraykLargestElementt(int[] arr , int k){
        
        //USING MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)  -->Time:O(nlogn + n), Soace:O(1)
        /*
        Look in ARRAY --  MULTIPOINTERS SORT SEARCH  
        */

        //USING BINARY MIN HEAP(Array requires sorting)->Time:O(nlogk ), Soace:O(n)
        /*
        [7,10,4,3,20,15]  --- [3,4,7,10,15,20]  -- add  the elements to min heap in asc order(so that min element at front can be popped) and  if size > k  pop the element 
                               X X X                return all element  in maxheap which will be kth largetst


        Time : O(n logk)   as we reduce n(length of arr) by half and sort upto k
        Space: O(k) as heap takes extra space

        */
        PriorityQueue<Integer> minHeap = new PriorityQueue<>((Integer a, Integer b) ->{return a-b;});

        for(int i=0 ; i <arr.length ; i++){
            minHeap.add(arr[i]);

            if(minHeap.size() > k){
                minHeap.remove();
            }

        }


        int[] kSmallestarr = new int[minHeap.size()];
        int index =0;
        for(int i = 0 ; i <= minHeap.size()-1 ; i++){
            kSmallestarr[index++] = minHeap.remove();
        }
        return kSmallestarr;
        



        


    }
    public int   arrayK1K2smallestElementsSumm(int[] arr , int k1 , int k2){
         /*
        QUESTION
        [1,2,3,4,5,6]  -- find the sum of elements between k1 and k2 smallest number exclluding k1 and k2th smallest elements
                          ie if k1 = 2 ; k2 = 5  then 2nd smallest = 2 and 5th smallest = 5 so sum of elements between 2nd and 5th smallest = 3+4 
                          
        */
         //USING MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)  -->Time:O(nlogn + n), Soace:O(1)
        /*
        Look in ARRAY --  MULTIPOINTERS SORT SEARCH  
        */

        //USING MINHEAP(Array requires sorting  + K is given ) ->Time:O(nlogk ), Soace:O(n)
        /*

        [7,10,4,3,20,15]  --- [6,5,4,3,2,1]  -- add  the elements to max heap in des order(so that max element at front can be popped) and  if size > k2  pop the element 
        k1=2,k2 = 5            X                 the elemnt at top will be k2th smallest elent  

                              [5, 4, 3 ,2,  1] --pop the k2th smallest element(as you dont want to include k2th smallest in sum)
                             k2=5      k2=2      pop k2-k2-1(-1 as you dont want to include k1th smallest in sum ) and add them to sum



        Time : O(n logk)   as we reduce n(length of arr) by half and sort upto k
        Space: O(k) as heap takes extra space

        */
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((Integer a, Integer b) ->{return a-b;});
        
        for(int i=0 ; i <=arr.length-1;i++ ){
            
            maxHeap.add(arr[i]);
            
            if(maxHeap.size() > k2){
                maxHeap.remove();
            }
        
            
        }
        
        maxHeap.remove();

        int sum = 0;
        for(int i = 1 ; i <=(k2-k1)-1 ; i++){
            sum = sum + maxHeap.remove();
        }
        
        return sum;
    


        


    }
    public int[] arrayKTopfrequentElementss(int[] arr, int k){ 
        
        //USING MULTIPOINTERS SORT SEARCH + HASHMAP(ARRAY REQUIRES SORTING + ARRAY REQUIRES STORING ELEMENTS))  -->Time:O(nlogn + n), Soace:O(n)
        /*
        Look in ARRAY --  MULTIPOINTERS SORT SEARCH  
         */


            
        
        //USING HASHMAP AND MINHEAP(Array requires sorting  + K is given  ; and we req max elements at bottom and min at top) ->Time:O(nlogk ), Soace:O(n)
        /*
        [1,1,1,2,2,2,2,3,4,4] --->{1:3,  -->[[1,3],[2,4],[3,1],[4,2]]    -->populate hashmap with key as element and value as fequency
                                   2:4,      X                             add arr [value,key] to minHeap in asc order based on  value and if value is same sort in  desc order based on  key(minValue at top is popped and  and if same value  then max key at top can be popped) if size > k  pop the element     
                                   3:1,                                    return all  remaining heap ka arr ka 1st element  which will be k most frequent  element  
                                   4:2}     
        Time : O(n logk)   as we reduce n(length of arr) by half and sort upto k
        Space: O(k) as heap takes extra space
        */

        Map<Integer , Integer> hashmap = new HashMap<>();
        int count = 1;
        for (var i = 0; i < arr.length; i++) {
            if (!hashmap.containsKey(arr[i])) {
                count = 1;
            } else {
                count = hashmap.get(arr[i]) + 1;
            }
            hashmap.put(arr[i], count);
        }

    
        PriorityQueue<int[]> minHeap = new PriorityQueue<>(
            (int[] a , int[] b) -> { return (a[0] != b[0]) ? (a[0] - b[0]) : (b[1] - a[1]);}    
           ); 
     
     

        for(var i : hashmap.entrySet()){
            var key = i.getKey();
            var value = i.getValue();
            minHeap.add(new int[]{value,key} );
            if(minHeap.size() > k){
                minHeap.remove();
            }

        }


        int[] result = new int[k];int index = 0;     
        while(!minHeap.isEmpty()){
          result[index++] = minHeap.remove()[1];

        }

        return result;




    }
    public int[][] arraykClosestElementsToOriginn(int[][] arr , int k){

        //USING MULTIPOINTERS SORT SEARCH + HASHMAP(ARRAY REQUIRES SORTING + ARRAY REQUIRES STORING ELEMENTS)  -->Time:O(nlogn + n), Soace:O(n)
        /*
        Look in ARRAY --  MULTIPOINTERS SORT SEARCH  
        */

        //USING  MAXHEAP(Array requires sorting  + K is given) ->Time:O(nlogk ), Soace:O(n)
        /*
        [[1,3] --->{0:10, -->[100,2],[10,0],[8,1],[1,3]  --> populate hashmap with key as index of element and value as distance
         [2,2]      1:8,      X                              add arr [value,key] to maxheap in desc order based on  value and if value is same sort in  desc order based on  key(max value at top is popped and  and if same value then max key at top can be popped) if size > k  pop the element    
         [5,8]      2:100,                                   return all  remaining heap ka arr ka 1st element  which will be k closest pair ka index
         [0,1]      3:1}                    
        }                                                   NOTE:  Insted of double distance = Math.sqrt((arr[i][0]*arr[i][0] + arr[i][1]*arr[i][1]));
                                                                    You can use  int distance =arr[i][0]*arr[i][0] + arr[i][1]*arr[i][1];
                                                                    as we are just comparing the distances
                                                    
        Time : O(n logk)   as we reduce n(length of arr) by half and sort upto k
        Space: O(n) as heap takes extra space
        */

        Map<Integer ,Integer> hashMap = new HashMap<>();
        int cnt = 0 ;
        for(int i = 0 ; i < arr.length ; i++){
            int distance =arr[i][0]*arr[i][0] + arr[i][1]*arr[i][1];
            hashMap.put(i , distance);
        }

        PriorityQueue<int[]> maxHeap = new PriorityQueue<>(
            (int[] a , int[] b) -> { return (a[0] != b[0]) ? (b[0] - a[0]) : (b[1] - a[1]);}    
           ); 

        for(var i : hashMap.entrySet()){
            var index = i.getKey();
            var distance = i.getValue();
            maxHeap.add(new int[]{distance,index});

            if(maxHeap.size() > k){
               maxHeap.remove();
            }
        }

        int[][] result = new int[k][2];int index =0;
        while(!maxHeap.isEmpty()){

            result[index++] = arr[maxHeap.remove()[1]];
        }

        return result;




    }
    public int[] arraykClosestElementsToPointt(int[] arr ,int k , int x){
        /*
        [5,6,7,8,8,9] -- find k element closest x 
                       closest element has smallest difference and if difference bw 2 elements 
                       is same take the smaller element
                       Eg: 3 elements closest to 7 are 7,8,8          


        */
  
        //USING MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)  -->Time:O(nlogn + n), Soace:O(1)
        /*
        Look in ARRAY --  MULTIPOINTERS SORT SEARCH  
         */

        //USING MAXHEAP(Array requires sorting  + K is given ) ->Time:O(nlogk ), Soace:O(n)
        /*
        [5,6,7,8,9] --[[2,5],[2,9],[1,8],[1,6],[0,7]]   --add arr [diff,value] to maxheap in descending order based on  diff and if diff is same des order based  value(maxdiff at top can bepopped and  if same maxdiff then maxelement at top can be popped) if size > k  pop the element  
                        X    X                            return heap ka arr ka value which will be k closest element  

    

        Time : O(n logk)   as we reduce n(length of arr) by half and sort upto k
        Space: O(k) as heap takes extra space
        */
        PriorityQueue<int[]> maxHeap = new PriorityQueue<>( 
            (int[] a , int[] b) -> { return (a[0] != b[0]) ? b[0] - a[0] :b[1] - a[1];}    
        ); 
        for(int i=0;i<= arr.length-1 ;i++){
            int diff = Math.abs(arr[i]-x);
            int value = arr[i];
            maxHeap.add(new int[]{diff,value});

            if(maxHeap.size() > k){
                    maxHeap.remove();
            }                
        }

    
        int[] result = new int[k]; int index = 0;
        while(!maxHeap.isEmpty()){
            result[index++] = maxHeap.remove()[1];            
        }

        return result;
    
        
    }
    public int[] arrayKNearlySortedSortt(int[] arr , int k){
        /*
        QUESTION 
        6,5,3,2,8,10,9 -- for each index the correct element can be in i - k to i-1 an i+1 to i+k inclusive 
                          ie for index 0 the correct element can be from 0 to 3
                          for index 1 the correct element can be  0 or 2 to 4
                          for index 4 correct element can be  1 or 3 to 5 to 7
        */                

        //USING MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)  -->Time:O(nlogn + n), Soace:O(1)
        /*
        Look in ARRAY --  MULTIPOINTERS SORT SEARCH  
        */


        //USING BINARY MINHEAP(Array requires sorting  + K is given  ; and we req max elements at bottom and min at top) ->Time:O(nlogk ), Soace:O(n)
        /*
        [6,5,3,2,8,10,9] -->[2,3,5,6,8,9,10] --add  the elements to min heap in asc order(min element at top can be popped) and if size > k  pop the element so that minhep size of k is mantained 
                            x  x x x           poped element is the smallest in range of k so add in array  
                                                  add the remaining elements of minheap in arr


        Time : O(n logk)   as we reduce n(length of arr) by half and sort upto k
        Space: O(k) as heap takes extra space     
        */

        PriorityQueue<Integer> minHeap = new PriorityQueue<>(
            (Integer a, Integer b) ->{return a-b;}
        );
        int[] sortedArray = new int[arr.length];
        int index = 0;
        for(int i=0 ; i <arr.length ; i++){
            minHeap.add(arr[i]);
            if(minHeap.size() > k){
                sortedArray[index] =  minHeap.remove();
                index++;
            }
        }

        while(!minHeap.isEmpty()){
            sortedArray[index] =  minHeap.remove();
            index++;

        }

        
        return sortedArray;




    }
    public int[] arrayfrequencySortt(int[] arr){
        /*
        Question
        [1,2,2,2,3,3,4,4,4] --  sort the array in increasing order based on the frequency of the values. 
                                If multiple values have the same frequency, sort them in ascending order.
        */
        
        //USING MULTIPOINTERS SORT SEARCH + HASHMAP(ARRAY REQUIRES SORTING+ARRAY REQUIRES STORING ELEMENTS)  -->Time:O(nlogn + n), Soace:O(n)
        /*
        Look in ARRAY --  MULTIPOINTERS SORT SEARCH  
        */

        //USING  MAXHEAP AND HASHMAP (Array requires sorting + K is given  ; and we req min elements at bottom and max at top) ->Time:O(nlogk ), Soace:O(n)
        /*
        [1,1,1,2,2,2,2,3,4,4] --->{1:3,  --> [[3,1],[2,4],[3,1],[4,2]]    -->populate hashmap with key as element and value as fequency
                                   2:4,                                      add arr [value,key] to maxheap in desc order based on  value and if value is same sort in  asc order based on  key(max value at top   and if same value then min key at top ) if size > k  pop the element       
                                   3:1,                                      return all  remaining heap ka arr ka [1] arr ke [0] times  which willmost freq elemenyts 
                                   4:2}      

        Time : O(n logk)   as we reduce n(length of arr) by half and sort upto k
        Space: O(n) as heap takes extra space
        */
        Map<Integer , Integer> hashmap = new HashMap<>();
        int count = 1;
        for (var i = 0; i < arr.length; i++) {
            if (!hashmap.containsKey(arr[i])) {
                count = 1;
            } else {
                count = hashmap.get(arr[i]) + 1;
            }
            hashmap.put(arr[i], count);
        }

        PriorityQueue<int[]> maxHeap = new PriorityQueue<>(
            (int[] a , int[] b) -> { 
                return (a[0] != b[0]) ? b[0] - a[0] :b[1] - a[1];}    
           ); 

      

        for(var i : hashmap.entrySet()){
            var key = i.getKey();
            var value = i.getValue();

            maxHeap.add(new int[]{value,key});
            
       
        }

        int[] result = new int[arr.length];int index = 0;
        while(!maxHeap.isEmpty()){
            var frequency = maxHeap.remove()[0];
            var element = maxHeap.remove()[1];
            for(int i=1 ; i <=frequency ; i ++ ){
                result[index++] = element;
            }
        }

        return result;


   
    }
    public int   arrayContinuousSumEqualsMinCost_RopesJoiningg(int[] arr){

       /*
    Question
    arr = [1,2,3,4,5] -- these are the sizes of rope and the cost of joining them = addition of size of ropes
                         Join the ropes in such a way that you get min cost
                         RESULT: So the min cost is when ypu join 2 ropes with min length at any given time
                         EG 1   2   3   4   5   Total cost = 3 + 6 + 15 = 24
                            \   /  /    /   /
                              3   /    /    /
                               \ /    /    /
                                6    /    /
                                \   /    /
                                  10     /
                                  \     /
                                     15


                            1   2   3   4   5  Total cost = 3 + 6 + 9 = 18
                            \   /  /    \   /  
                              3   /       9 
                               \ /        /
                                 6       /
                                  \     /
                                     15
                                 */ 


      //USING MULTIPOINTERS SORT SEARCH + HASHMAP(ARRAY REQUIRES SORTING)  -->Time:O(nlogn + n), Soace:O(n)
      /*
       Look in ARRAY --  MULTIPOINTERS SORT SEARCH  
      */

      //USNNG MINHEAP(Array requires sorting + K is given  ; and we req max elements at bottom and min at top)->Time:O(nlogk ), Soace:O(n)
      /*
      [1,2,3,4,5]  --  [1,2,3,4,5] --add  the elements to min heap in asc order (so that min element will be at top)
                        | |         whie heap size >=2 pop top 2 elements and add their sum to heap and in end return sum of cost 
                         3
                          

        Time : O(n*nlogk)   as we reduce n(length of arr) by half and sort upto k;do this for entire array
        Space: O(k) as heap takes extra space
        */
      PriorityQueue<Integer> minHeap = new PriorityQueue<>();   
      for(int i = 0 ; i < arr.length ; i++){
          minHeap.add(arr[i]);
      }

      int sum = 0;
      while(minHeap.size() >= 2){
          var first = minHeap.remove();
          var second = minHeap.remove();
          minHeap.add(first + second);
          sum = sum + first + second;
      }

      return sum;






    }

   


 
            
    //HASHMAPS , HASHSETS
    /*
    HASHMAPS , HASHSETS IDENTIFY
    ARRAY REQUIES STORING OF ELEMENTS 
   */
    public char  stringFirstRepeatedCharacter(String s) {
        //USING HASHMAPS(ARRAY REQUIES STORING OF ELEMENTS )
        /*
        "hello"-->['h','e','l','l''o'] --->{'h':1,'e':1,'l':2,'o':1}  add char as key and charCount as value  to hashmaps,
                                                                    iterate over array and if hashmap key has val !=1 return that char
        Time : O(n) as we reduce n(length of str ) by 1
        Space: O(n)
        */


        Map<Character, Integer> map = new HashMap<>();
        char[] arr = s.toCharArray();

        int count = 0;
        for (var i : arr) {
            if (map.containsKey(i)) {
                count++;
            } else {
                count = 1;
            }
            map.put(i, count);
        }


        for (var i : arr) {
            if (map.get(i) != 1) {
                return i;
            }
        }

        return Character.MIN_VALUE;
    }
    public char  stringFirstUniqueCharacter(String s) {
        //USING HASHMAPS(ARRAY REQUIES STORING OF ELEMENTS )
        /*
        "hello"-->iterate str add to map
                 iterate str and if count ==1 return index or characrer
                 return -1 or Character.MIN_VALUE


        Time : O(n) as we reduce n(length of str ) by 1
        Space: O(n)
        */

        Map<Character,Integer> map = new HashMap<>();
        for(int i=0 ; i<= s.length()-1;i++){
            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0) + 1);
        }
        
         for(int i=0 ; i<= s.length()-1;i++){
             if(map.get(s.charAt(i)) == 1){
                 //return i;
                 return s.charAt(i);
             }
         }
        
        //return -1;
        return Character.MIN_VALUE; 
       


    }
    public char  stringMaxRepeatedCharacter(String s) {
        //USING HASHMPAS(ARRAY REQUIES STORING OF ELEMENTS )
        /*
        "hello"-->['h','e','l','l''o'] -->{h:1,e:1,l:2,o:1}  add char as key and charCount as value  to hashmaps,
                                                            return key  with max value
                                                                    iterate over array and if hashmap key has val !=1 return that char
        Time : O(n) as we reduce n(length of str ) by 1
        Space: O(n)
        */
        char[] arr = s.toCharArray();
        Map<Character, Integer> map = new HashMap<>();
        int count = 0;
        for (var ch : arr) {
            if (map.containsKey(ch)) {
                count++;
            } else {
                count = 1;
            }
            map.put(ch, count);
        }

        char maxKey = 0;
        int maxVal = 0;
        for (var i : map.entrySet()) {
            if (i.getValue() >= maxVal) {
                maxVal = i.getValue();
                maxKey = i.getKey();
            }
        }

        //return maxKey;

        //USING ARRAY
        /*
        "hello"-->['h','e','l','l''o'] -->[                ] --> add char at index  and charcount as value of index
                                            0   1......256       return index  with max value
        */

        char[] arrr = s.toCharArray();
        int[] asciiarray = new int[256];//ASCII_CHARACTER_SIZE = 256

        int index = 0;
        int value = 0;
        for (var ch : arrr) {
            index = (char) ch;
            if (asciiarray[index] == 0) {
                value = 1;
            } else {
                value = value + 1;
            }
            asciiarray[index] = value;
        }

        int maxindex = 0;
        int maxValue = 0;
        for (var i = 0; i < asciiarray.length; i++) {
            if (asciiarray[i] >= maxValue) {
                maxValue = asciiarray[i];
                maxindex = i;
            }
        }
        return (char) maxindex;
    }
    public int   stringnUniqueAndRepeatedCharacterCount(String s) {
        //USING HASHMPAS(ARRAY REQUIES STORING OF ELEMENTS )
        /*
        "hello"-->['h','e','l','l''o'] -->{h:1,e:1,l:2,o:1}  add char as key and charCount as value  to hashmaps,
                                                            iterate over hashmap and if val=1 inc unique , val>1 inc reoeated
                                                                    iterate over array and if hashmap key has val !=1 return that char
        Time : O(n) as we reduce n(length of str ) by 1
        Space: O(n)
        */
        char[] arr = s.toCharArray();
        Map<Character, Integer> map = new HashMap<>();
        int count = 0;
        for (var ch : arr) {
            if (map.containsKey(ch)) {
                count++;
            } else {
                count = 1;
            }
            map.put(ch, count);
        }

        int noOfUniqueCharacters = 0;
        int noOfRepeatedCharacter = 0;
        for (var i : map.entrySet()) {
            if (i.getValue() == 1) {
                noOfUniqueCharacters++;
            } else if (i.getValue() > 1) {
                noOfRepeatedCharacter++;
            }
        }

        return noOfUniqueCharacters;

    }
    public String stringFirstUniqueCharacterReplaceAtEveryPositionn(String s){

        /*
        Question
        abbabcdda -- replace every charater with 1st non repeating character until then
                     if not present replce by # 
                     Eg:"ababdcdda" -- "aab#ddccc"
        */

        //USING QUEUE(Array Brute force O(n^2) inner loop depends on outer loop) AND HASHMPAP()ARRAY REUIRES STORING)
        /*
        abbabcdda -- iterte through string
                      add character as key and freq as value to map
                      push ch to queue
                      pop while queue is not empty and top of queue ka frequency  >=2
                      if queue is empty then firstNonRepeatingChar = '#'   //null check: if queue is empty
                      else firstNonRepeatingChar = top of queue

                      res = res = firstgarater

        Time:O(n^2) -- Queue qives O(n^2) DLL gives O(n) but hard to implement
        Space:O(1)
        */
        String res = "";
        Queue<Character> queue = new ArrayDeque<>();
        Map<Character,Integer> map = new HashMap<>();
        for(int i=0 ; i <= s.length()-1 ; i++){
 
        
            if(!map.containsKey(s.charAt(i))){
                map.put(s.charAt(i),1);
            }
            else{
                map.put(s.charAt(i) , map.get(s.charAt(i)) +1 );
                
            }
            
           queue.add(s.charAt(i));
            while(!queue.isEmpty() && map.get(queue.peek()) >=2){
                queue.remove();
            }
            char firstNonRepeatingChar = ' ';
            if(queue.isEmpty()){firstNonRepeatingChar = '#';}
            else{firstNonRepeatingChar = queue.peek();}
            res = res + firstNonRepeatingChar; 

        }
        
        return res;
    }
    public void  arraypair2TargetSummI(int[] arr, int target) {
        /*
        [1,2,5,3] target = 7 --> given an arr find pairs of 2 whose sum is target
                                 return pairs,pairs ke index , pairs ke count
                                 
                                 Note:
                                 [1,1,5,2]
                                 Pairs        :Taken  in only 1 direction and can be duplicate ie (1,5) is same as (5,1) they are not seperate pairs
                                               (1,1) (1,5) (1,2) (1,5) (1,2) (5,2)
                                 Unique pairs: Taken in 1 direction and must be unique
                                                (1,1) (1,5) (1,2)  (5,2)
                                        
                                
        */
        
        //USING MULTIPTR SORT + SEARCH(ARRAY REQUIRES SORTING)-->Time:O(nlogn + n),space:O(n)
        //                                                        Array duplicate     :Array cannot have duplicate for non unique pairs, array can have duplicate for unique pairs
        //                                                        Pair of value,index :Pair of value can be found, pair of index cant be found  
        /*
        LOOK IN  MULTIPTR SORT + SEARCH(
        */


        //USING HASHMAP(ARRAY REQUIRES STORING)    -->Time:O(nlogn + n),space:O(n)
        //                                             Array duplicate     :Array can have duplicate 
        //                                             Pair of value,index :Pair of value can be found, pair of index can be found  
        /*
        //PAIRS
        [1,1,5,5]  ---->{1:2  -- iterate through arr
        target = 6       5:2        diff = target - arr[i]            
                        }           if(mapOfValue .contains(diff))     
                                      pairOFValue ko add karo  [diff , arr[i]] diffKaCount times(add diff 1st then arr[i] because you encounter in backward direction-->explanation in ALGORITHM/frequency())               
                                      pairOFIndex ko add karo [mapp.get(diff),i] just once because index  index is never updated once declared so fo index of 2 same ellements so we can find only 1 pair (add diff ka index 1st then element ka index becaue ou encounter in backward direction-->explanation in ALGORITHM/frequency())
                                      noOfPairs ko add karo diff ka counr 
                                    add diff as key and freq as value to mapOfValue
                                    add ele as key and index as value to mapOfIndex
                                

        //UNIQUE PAIRS  
        String  uniquekeyForPairs = generateUniqueKeyForPairs(new int[]{diff, arr[i]})  --ele1#ele2#ele3#(sort) --Look in JAVA/OBJECTS/UNIQUE
        if(!visited.contains(uniqueKeyForPairs)){    --before adding check if unique key not present in set
            add pairs,add index,count pairs+1        --add only 1 pair 1 index and 1 count
            visited.add(uniquekeyForPairs)           --after adding pairs add unique key to set 


        

        Time : O(n)                             
        Space:O(n)
        */
        /*
        //PAIRS
        Map<Integer, Integer> mapOfValue = new HashMap<>();
        Map<Integer, Integer> mapOfIndex = new HashMap<>();
        ArrayList<int[]> pairOFValue = new ArrayList<>();
        ArrayList<int[]> pairOFIndex = new ArrayList<>();
        int noOfPairs = 0;
        for (int i= 0 ; i <= arr.length-1;i++) {
            int difference = target - arr[i];
            if (mapOfValue.containsKey(difference)) {
                int cnt = mapOfValue.get(difference);
                for(int c = 1 ; c <= cnt;c++){pairOFValue.add(new int[]{difference,arr[i]}); } 
                pairOFIndex.add(new int[]{mapOfIndex.get(difference),i});                                                            
                noOfPairs = noOfPairs + cnt;                                                  
                                      
                
            }


            if(!mapOfValue.containsKey(arr[i])){
                mapOfValue.put(arr[i],1);
            }
            else{
                mapOfValue.put(arr[i],map.get(arr[i])+1);
            }

            if(!mapOfIndex.containsKey(arr[i])){
                mapOfIndex.put(arr[i], i);

            }

        }
        
        return noOfPairs;

        //UNIQUE PAIRS
        Map<Integer, Integer> mapOfValue = new HashMap<>();
        Map<Integer, Integer> mapOfIndex = new HashMap<>();
        Set<String> set = new HashSet<>();
        ArrayList<int[]> pairOFValue = new ArrayList<>();
        ArrayList<int[]> pairOFIndex = new ArrayList<>();
        int noOfPairs = 0;
        for (int i= 0 ; i <= arr.length-1;i++) {
            int difference = target - arr[i];
            if (mapOfValue.containsKey(difference)) {
                String uniquekeyForPairs = generateUniqueKeyForPairs(new int[]{diff, arr[i]}
                if(!visited.contains(uniquekeyForPairs)){     
                    int cnt = map.get(difference);
                    pairOFValue.add(new int[]{difference,arr[i]});                 
                    pairOFIndex.add(new int[]{mapp.get(difference),i});                                  
                    noOfPairs = noOfPairs + 1;                                 

                    visited.add(uniquekeyForPairs)
                }
    
            }

            if(!mapOfValue.containsKey(arr[i])){
                mapOfValue.put(arr[i],1);
            }
            else{
                mapOfValue.put(arr[i],mapOfValue.get(arr[i])+1);
            }

            if(!mapOfIndex.containsKey(arr[i])){
                mapOfIndex.put(arr[i], i);

            }

        }
        
        return noOfPairs;


        public String generateUniqueKeyForPairs(int[] arr){   
            Arrays.sort(arr);
    
            StringBuffer sb = new StringBuffer("");
            for(int i: arr){
                sb.append(i);
                sb.append("#");
            }
            
            return sb.toString();     
        }

        */

        


    }
    public void  arraypair2TargetSummII(int[] arr, int target) {
        /*
        [1,2,5,3] target = 7 --> given an arr find pairs of 2 whose sum is less than target
                                  return pairs,pairs ke index , pairs ke count

        */
        

        
        //USING MULTIPTR SORT + SEARCH(ARRAY REQUIRES SORTING)-->Time:O(nlogn + n),space:O(n)
        //                                                        Array duplicate     :Array can have duplicate for non unique pairs, array can have duplicate for unique pairs
        //                                                        Pair of value,index :Pair of value can be found, pair of index cant be found  
        /*
         Look in multipointer sort + search


        */

        

        //USING HASHMAP(ARRAY REQUIRES STORING)      -->Time:O(nlogn + n),space:O(n)
        //                                              Array duplicate     :Array can have duplicate
        //                                              Pair of value,index :Pair of value can be found, pair of index can be found  
        /*
        we cant use hashmap as we need sorted array to find all the pairs of [ptr1,ptr2] ;[ptr1,ptr2-1];...[ptr1,ptr1+1]
        */ 



    }
    public void  arraypair3TargetSummI(int[] arr, int target) {
        /*
        [1,2,5,3] target = 7 --> given an arr find pairs of 3 whose sum is target
                                  return pairs,pairs ke index , pairs ke count
                                        
        */
        
        //USING MULTIPTR SORT + SEARCH(ARRAY REQUIRES SORTING)-->Time:O(nlogn + n),space:O(n)
        //                                                        Array duplicate     :Array canot have duplicate for non unique pairs, array can have duplicate for unique pairs
        //                                                        Pair of value,index :Pair of value can be found, pair of index cant be found  
        /*
        LOOK IN  MULTIPTR SORT + SEARCH(
        */


        //USING   HASHMAP(ARRAY REQUIES STORING OF ELEMENTS ) -->Time:O(n^2),space:O(n)
        //                                                       Array duplicate     :Array can have duplicate 
        //                                                       Pair of value,index :Pair of value can be found, pair of index can be found  
        /*
        //PAIR
        [1,1,5,5]  ---->while(ptr1 <= arr.length-3)
        |  |                arraypair2TargetSummI() for ptr1+1 to arr.length-1
      ptr1 ptr2
        Time : O(n)                             
        Space:O(n)

        //UNIQUE PAIR
        [1,1,5,5]  ---->while(ptr1 <= arr.length-3)
        |  |               if (ptr1 == 0 || arr[ptr1] != arr[ptr1 - 1] ) {  
      ptr1 ptr2                  arraypair2TargetSummI() unique  for ptr1+1 to arr.length-1 }
                                 
        Time : O(n)                             
        Space:O(n)




        */
       /*
        //PAIRS
        Map<Integer, Integer> mapOfValue = new HashMap<>();
        Map<Integer, Integer> mapOfIndex = new HashMap<>();
        Set<Integer> visited = new HashSet<>();
        ArrayList<int[]> pairOFValue = new ArrayList<>();
        ArrayList<int[]> pairOFIndex = new ArrayList<>();
        int noOfPairs = 0;


        int ptr1 = 0; 
        while(ptr1 <= arr.length-3)){{ 
            for (int ptr2= ptr1+1 ; ptr2 <= arr.length-1;ptr2++) {
                int difference = target - (arr[ptr1]+ arr[ptr2]);
                if (mapOfValue.containsKey(difference)) {
                    int cnt = mapOfValue.get(difference);
                    for(int c = 1 ; c <= cnt;c++) {pairOFValue.add(new int[]{arr[ptr1],difference,arr[ptr2]});  }
                    pairOFIndex.add(new int[]{ptr1,mapOfIndex.get(difference),ptr2});
                    noOfPairs = noOfPairs + cnt;    
                }
                if(!mapOfValue.containsKey(arr[i])){
                    mapOfValue.put(arr[i],1);
                }
                else{
                    mapOfValue.put(arr[i],mapOfValue.get(arr[i])+1);
                }
                if(!mapOfIndex.containsKey(arr[i]){
                        mapOfIndex.put(arr[i],i);
                }
    
            }
         ptr1++;

        }
       
        return noOfPairs;

        //UNIQUE PAIR
        Map<Integer, Integer mapOfValue = new HashMap<>();
        Map<Integer, Integer> mapOfIndex = new HashMap<>();
        Set<String> visited = new HashSet<>();
        ArrayList<int[]> pairOFValue = new ArrayList<>();
        ArrayList<int[]> pairOFIndex = new ArrayList<>();
        int noOfPairs = 0;


        int ptr1 = 0; 
        while(ptr1 <= arr.length-3)){
            if (ptr1 == 0 || arr[ptr1] != arr[ptr1 - 1] ) { 
                for (int ptr2= ptr1+1 ; ptr2 <= arr.length-1;ptr2++) {
                    int difference = target - (arr[ptr1]+ arr[ptr2]);
                    if (mapOfValue.containsKey(difference)) {
                        String uniqueKeyForPairs = generateUniqueKey(new int[]{arr[i],difference,arr[ptr1]}); 
                        if(!visited.contains(uniqueKeyForPairs)){
                            int cnt = mapOfValue.get(difference);
                            pairOFValue.add(new int[]{arr[ptr1],difference,arr[ptr2]});  }
                            pairOFIndex.add(new int[]{ptr1,mapOfIndex.get(difference),ptr2});
                            noOfPairs = noOfPairs + 1;
                            
                            visited.add(uniqueKeyForPairs);
                        }
                            
                    }
                    if(!mapOfValue.containsKey(arr[i])){
                        mapOfValue.put(arr[i],1);
                    }
                    else{
                        mapOfValue.put(arr[i],mapOfValue.get(arr[i])+1);
                    }
                    if(!mapOfIndex.containsKey(arr[i]){
                            mapOfIndex.put(arr[i],i);
                    }
        
                }
            }   

        ptr1++;

        }
       
        return noOfPairs;

        public String generateUniqueKeyForPairs(int[] arr){
            Arrays.sort(arr);
            
            StringBuffer sb = new StringBuffer("");
            for(int i: arr){
                sb.append(i);
                sb.append("#");
            }
            
            return sb.toString(); 
        }




        */


    }
    public void  arraypair3TargetSummII(int[] arr, int target) {
        /*
        [1,2,5,3] target = 7 --> given an arr find pairs of 3 whose sum is less than target
                                  return pairs,pairs ke index , pairs ke count
                                        
        */
        
         //USING MULTIPTR SORT + SEARCH(ARRAY REQUIRES SORTING)-->Time:O(nlogn + n^2),space:O(n)
        //                                                        Array duplicate     :Array can have duplicate for non unique pairs, array can have duplicate for unique pairs
        //                                                        Pair of value,index :Pair of value can be found, pair of index cant be found  
        /*
        LOOK IN  MULTIPTR SORT + SEARCH(
        */


         //USING HASHSETS(ARRAY REQUIES STORING OF ELEMENTS ) -->Time:O(n^2),space:O(n)
        //                                                     Array duplicate     :Array can have duplicate 
        //                                                     Pair of value,index :Pair of value can be found, pair of index can be found
        /*
         we cant use hashmap as we need sorted array to find all the pairs of [ptr1,ptr2] ;[ptr1,ptr2-1];...[ptr1,ptr1+1]



        */
        /*
        we cant use hashmap as we need sorted array to find all the pairs of [ptr1,ptr2] ;[ptr1,ptr2-1];...[ptr1,ptr1+1]


        */


    }
    public void  arrayPairKTargetSummI(int[] arr, int target, int start, int k) {
        /*
        [1,2,5,3] target = 7 --> given an arr find pairs of k integeres whose sum is target
                                  return pairs,pairs ke index , pairs ke count
                                        

        */
        
        //USING MULTIPTR SORT + SEARCH(ARRAY REQUIRES SORTING) -->Time:O(n^k) Spaxe:O(1)
        //                                                        Array duplicate     :Array cannot have duplicate for non unique pairs, array can have duplicate for unique pairs
        //                                                        Pair of value,index :Pair of value can be found, pair of index cant be found  

        /*
          Look in multiptr sort + search

        */
        
        //USING HASHMAPS                                       -->Time:O(n^k) Spaxe:O(n)
        //                                                       Array duplicate:array can have duplicates4   
        //                                                       Pair of value,index :Pair of value can be found, pair of index can be found
        /*
        Same as multiptr sort + search bas array2Sum() fn hashmp wala lena 
        */
   
    }
    public void  arraypair2TargetDifferenceeI(int[] arr, int target) {
        /*
        [1,2,5,3] target = 7 --> given an arr find pairs of 2 whose  abs diff is target(abs diff beause pair can be taken in both dirs ie if pair is (a,b) then if a-b == target or b-a is target )
                                 return pairs,pairs ke index , pairs ke count
                                        
                                
        */
        
        //USING MULTIPTR SORT + SEARCH(ARRAY REQUIRES SORTING)-->Time:O(nlogn + n),space:O(n)
        //                                                        Array duplicate     :Array cannot have duplicate for non unique pairs, array can have duplicate for unique pairs
        //                                                        Pair of value,index :Pair of value can be found, pair of index cant be found  
        /*
        LOOK IN  MULTIPTR SORT + SEARCH(
        */


        //USING   HASHMAP(ARRAY REQUIES STORING OF ELEMENTS ) -->Time:O(n),space:O(n)
        //                                                       Array duplicate     :Array can have duplicate
        //                                                       Pair of value,index :Pair of value can be found, pair of index can be found  
        /*
        //PAIRS
        [1,1,5,5]  ---->{1:2  -- iterate through arr
        target = 6       5:2        diff1 =  arr[i] - target   -- consider [2,6,4] target = 2  and you ar at 4 then arr[i] - t will match pair (2,4) and arr[i,target] will match pair (6,4)  
                                    diff2 = arr[i] + target                                    
                                    if(map .contains(diff1))     
                                      pairOFValue ko add karo  [diff , arr[i]] diff1KaCount times(add diff 1st then arr[i] because you encounter in backward direction-->explanation in ALGORITHM/frequency())               
                                      pairOFIndex ko add karo [mapp.get(diff),i] just once because index  index is never updated once declared so fo index of 2 same ellements so we can find only 1 pair (add diff ka index 1st then element ka index becaue ou encounter in backward direction-->explanation in ALGORITHM/frequency())
                                      noOfPairs ko add karo diff ka count
                                    if(map.contains(diff2))
                                        do the same 
                                    add diff as key and freq as value to mapOfValue
                                    add ele as key and index as value to mapOfIndex


        //UNIQUE PAIRS
        String  uniquekeyForPairs = generateUniqueKeyForPairs(new int[]{diff1, arr[i]})  --ele1#ele2#ele3#(sort) --Look in JAVA/OBJECTS/UNIQUE
        if(!visited.contains(uniqueKeyForPairs)){    --before adding check if unique key not present in set
            add pairs,add index,count pairs+1        --add only 1 pair 1 index and 1 count
            visited.add(uniquekeyForPairs)           --after adding pairs add unique key to set 
                                

        Time : O(n)                             
        Space:O(n)
        */

        /*
        //PAIRS
        Map<Integer, Integer> mapOfValue = new HashMap<>();
        Map<Integer, Integer> mapOfIndex = new HashMap<>();
        ArrayList<int[]> pairOFValue = new ArrayList<>();
        ArrayList<int[]> pairOFIndex = new ArrayList<>();
        int noOfPairs = 0;
        for (int i= 0 ; i <= arr.length-1;i++) {
            int difference1 = arr[i] - target;
            int difference2 = arr[i] + target;
            if (mapOfValue.containsKey(difference1)) {
                int cnt = mapOfValue.get(difference1);
                for(int c = 1 ; c <= cnt;c++){pairOFValue.add(new int[]{difference1,arr[i]});   }
                pairOFIndex.add(new int[]{mapOfIndex.get(difference1),i});
                noOfPairs = noOfPairs + cnt;
            }
            if (mapOfValue.containsKey(difference2)) {
                int cnt = mapOfValue.get(difference2);
                for(int c = 1 ; c <= cnt;c++){pairOFValue.add(new int[]{difference2,arr[i]});   }
                pairOFIndex.add(new int[]{mapOfIndex.get(difference2),i});
                noOfPairs = noOfPairs + cnt;
            }



            if(!mapOfValue.containsKey(arr[i])){
                mapOfValue.put(arr[i],1);
            }
            else{
                mapOfValue.put(arr[i],mapOfValue.get(arr[i])+1);
            }

            if(!mapOfIndex.containsKey(arr[i])){
                mapOfIndex.put(arr[i], i);

            }

        }
        
        return noOfPairs;

        //UNIQUE PAIRS
        Map<Integer, Integer> mapOfValue = new HashMap<>();
        Map<Integer, Integer> mapOfIndex = new HashMap<>();
        ArrayList<int[]> pairOFValue = new ArrayList<>();
        ArrayList<int[]> pairOFIndex = new ArrayList<>();
        Set<String> visited = new HashSet<>();
        int noOfPairs = 0;
        for (int i= 0 ; i <= arr.length-1;i++) {
            int difference1 = arr[i] - target;
            int difference2 = arr[i] + target;
            if (mapOfValue.containsKey(difference1)) {
                int cnt = mapOfValue.get(difference1)
                String uniquekeyForPairs = generateUniqueKeyForPairs(new int[]{difference1,arr[i]});
                if(!visited.contains(uniquekeyForPairs)){
                    pairOFValue.add(new int[]{difference1,arr[i]});   
                    pairOFIndex.add(new int[]{mapOfIndex.get(difference1),i});
                    noOfPairs = noOfPairs + 1;

                    visited.add(uniquekeyForPairs);
                }
            }
            if (mapOfValue.containsKey(difference2)) {
                int cnt = mapOfValue.get(difference2);
                String uniquekeyForPairs = generateUniqueKeyForPairs(new int[]{difference2,arr[i]});
                if(!visited.contains(uniquekeyForPairs)){
                    pairOFValue.add(new int[]{difference1,arr[i]});   
                    pairOFIndex.add(new int[]{mapOfIndex.get(difference1),i});
                    noOfPairs = noOfPairs + 1;

                    visited.add(uniquekeyForPairs);
                }
            }



            if(!mapOfValue.containsKey(arr[i])){
                mapOfValue.put(arr[i],1);
            }
            else{
                mapOfValue.put(arr[i],mapOfValue.get(arr[i])+1);
            }

            if(!mapOfIndex.containsKey(arr[i])){
                mapOfIndex.put(arr[i], i);

            }

        }
        
        return noOfPairs

        public String generateUniqueKeyForPairs(int[] arr){
            int max = Math.max(arr[0], arr[1]);
            int min = Math.min(arr[0],arr[1]);
            
            String s = String.valueOf(min) + "#" + String.valueOf(max) + "#";
            
            return s;
        }


        */


    }
    public int[] arrayElementsAppearingMoreThanNbyKTimess(int[] arr,int n,int k){
        /*
        Question
        [3,2,3]  n = 3 , k = 3 -- find all the elements that appear more than n/k times
        
        */
        
        //USING MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)  --> Time : O(n logn) ;Space: O(1)
        /*
        LOOK IN MULTIPOINTERS SORT SEARCH
                    
        */

        //USING HASHMAP    -->Time:O(n),space:O(n)
        /*
         [3,2,3]  -->{2:1  -->iterate over arr and store element as key and count as val
                      3:2     iterate over hashmap and for value > (int)n/k store key in result
                       }
        Time:O(n)
        Space:O(n)
        */
        int[] result = new int[arr.length];int index = 0;
        Map<Integer,Integer> map = new HashMap<>();
        for(int i = 0; i <= arr.length-1;i++){
            if(!map.containsKey(arr[i])){
                map.put(arr[i],1);
                
            }
            else{
                map.put(arr[i], map.get(arr[i])+ 1);
            }
            
        }

        for(var i : map.entrySet()){
            if(i.getValue() > (int)(n/k)){
                result[index++] = i.getKey();
            }
        }
        
        return Arrays.copyOfRange(result,0,index);
        
        
        
        
      
        
        
    }
    public void  arrayContainsDuplicatee(int[] arr){
        /*
        [1,2,2,3,4] -- return true if array contains duplicate
                      if all unique return false

        */

        //USING MULTIPOINTERS SORT AND SEARCH (ARRAY REQUIRES SORTING) --Time:O(nlogn + n)  Space:O(1)
        /*
        Look in array multiptr sort search
        */

        //USING HASHMAP(ARRAY REQUIRES STORING) -->Time:O( n)  Space:O(1)
        /*
        [1,2,2,3,4]-- {1:1  --populate hashmap with element as key and freq of element as value
                       2:2,   while populating if count >=2 return true
                       3:1}   return false
        
        Time:O( n)          
        Space:O(1)
        */
        Map<Integer, Integer> map = new HashMap<>();
        int ptr = 0;
        while(ptr <= arr.length-1){
            
            if(!map.containsKey(arr[ptr])){
                map.put(arr[ptr],1);
            }
            else{
                map.put(arr[ptr], map.get(arr[ptr]) + 1);
                if(map.get(arr[ptr]) >= 2){
                    //return true;
                }
            }

            ptr++;
        }
        
        //return false;
    
    }
    public int[] arrayRemoveDuplicatee(int[] arr){
        /*
        [0,1,2,2,3,0,4,2] -- in a  array remove duplicates in place so all  unique will be on left  in sorted manner
                            return array where remaining values doesnt matter-->return [0,1,2,3,4,_,_,_] 
                            return array with remaining elements 0           -->return [0,1,2,3,4,0,0,0] 
                            return array with only values                    -->return [0,1,2,3,4]
                            return count                                     -->return 5
        */

        //USING MULTIPOINTERS SORT SEARCH (ARRAY REQUIRES SORTING) -->Time:O(nlogn + n),Space:O(1)
        /*
        LOOK IN  ARRAY --  MULTIPOINTERS SORT SEARCH  
        */
        

        //USING HASHSET(ARRAY REQUIRES STORING AND ARRAY RETURN KA ORDER DOESNT MATTER ) ->Time:O(n + nlogn),Space:O(n)
        /*
        [0,1,2,2,3,0,4,2] -->{0,1,2,4,3} -- put elements in hashset
                                            iterate over hashset and put elements in array
                                            sort array from 0 to index exclusive as you want sorted elements on left  and hashmap doesnt guarantee order                                                         
            
                                            return arr;                                                         --return arr as it is 
                                            for(int i = ptr3 ; i <= arr.length-1;i++ ){arr[i]=0;} return arr;    require elements till ptr3-1; so ptr3 to arr.length fill 0 and return arr
                                            return Arrays.copyOfRange(arr,0,ptr3);                               require elements till ptr3-1;so return 0 to ptr3 exclusive
                                            return ptr3                                                          require elements till ptr3-1; so return ptr1 we need count of element not index so    
        Time:O(n+logn)
        Space:O(1) 

        */
        Set<Integer> hashSet = new HashSet<>();
        
        for(int i=0 ; i <= arr.length-1;i++){
            hashSet.add(arr[i]);
        }
        
        int index =0;
        for(int i: hashSet){
            arr[index++] = i;
        }
        Arrays.sort(arr);

        return arr;
        //for(int i = ptr3 ; i <= arr.length-1;i++ ){arr[i]=0;} return arr;
        //return Arrays.copyOfRange(arr,0, ptr3);
        //return ptr3;
            
                
    }
    public int[] arrayRemoveDuplicateeII(int[] arr){
        /*
        [1,2,2,3,3,3,4,5,5]  -- remove duplicates in place so that it has at most 2 duplicates and all  elements will be on left in sorted manner and  elements after that doesnt matter
                                Eg: return array where remaining values doesnt matter                    return [1,2,3,3,4,5,5,_,_] retun 5
                                    return array with remaining elements 0                               return [0,1,2,3,4,0,0,0] 
                                    return array with only values                                         return [0,1,2,3,4]
                                    return count of elements                                             return 5
                                
                                
                                
                                
     

        */

        //USING MULTIPOINTERS SORT SEARCH (ARRAY REQUIRES SORTING) -->Time:O(nlogn + n),Space:O(1)
        /*
        LOOK IN ARRAY - MULTIPTR SORT SEARCH
        

        */




        //USING HASHMAP(ARRAY REQUIRES STORING AND ARRAY RETURN KA ORDER DOESNT MATTER ) ->Time:O(n + nlogn),Space:O(n)  
        /*
      [1,2,2,3,3,3,4,5,5] -->{1:1  -->populate hshmap with key as element and value a frequeny f element
                              2:2     iterate hashmap 
                              3:3       if value = 1
                              4:1         add key to arr 
                              5:1}      if value = 2
                                          add key to array twice
                                       sort array as you need sorted values on left as hashmap doesnt guarantee order   

                                          
                                        return arr;                                                         --return arr as it is 
                                        for(int i = index ; i <= arr.length-1;i++ ){arr[i]=0;} return arr;   require elements till index-1; so ptr3 to arr.length fill 0 and return arr
                                        return Arrays.copyOfRange(arr,0,index);                               require elements till index-1;so return 0 to index exclusive
                                        return index                                                          require elements till index-1; so return index we need count of element not index so    
        Time : O(n)    

        */                                 
        
                  
        Map<Integer,Integer> map = new HashMap<>();
        for(int i =0 ; i <= arr.length-1;i++){
            if(!map.containsKey(arr[i])){
                map.put(arr[i],1);
            }
            else{
                map.put(arr[i] , map.get(arr[i])+1);
            }

        }

        int index =0;
        for(var element:map.entrySet()){
            if(element.getValue() == 1){
                arr[index++] = element.getKey();
            }
            if(element.getValue() >= 2){
                arr[index++] = element.getKey();
                arr[index++] = element.getKey();
            }
        }
        Arrays.sort(arr,0,index);
        
        return arr;
        //for(int i = ptr3 ; i <= arr.length-1;i++ ){arr[i]=0;} return arr;
        //return Arrays.copyOfRange(arr,0, ptr3);
        //return ptr3;
            
        }
    public void  arrayMissingDuplicatee0ToN(int[] arr){
        /*
        QUESTION
            [0,2,2,3,4,5,6] --array has element in unsorted manner
                            array must have elements 0 to N=arr.length
                            return the missing and duplicate numbers
                            Eg: [0,2,2,3,4,4,6]  
                                missing  = [1,5,7]
                                duplicate = [2,4]
        */
    

        
        //USING MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)  -->Time:O(nlogn + n), Soace:O(1)
        //                                                             Multiple    :Array can have  multiple missing duplicates ; we can find multiple  missing,duplicates   
        //                                                             Manipulation :Array is changed
        /*
        LOOK IN ARRAY-MULTIPTR SORT SEARCH
        */
    
        //USING MULTIPOINTER SWAPSORT SEARCH(ARRAY REQUIRES SORTING)   -->Time:O(n) , Space O(1)
        //                                                                  Multiple    :Array can have  multiple missing duplicates ; we can find multiple  missing,duplicates   
        //                                                                 Manipulation:Array is changed 
        /*
        LOOK IN ARRAY-MULTIPTR SORT SEARCH
        */
    
        //USING HASHMAP(ARRAY REQUIRES STORING ELEMENTS)   -->Time:O(n);Space = O(n)
        //                                                    Multiple      :Array can have multiple missing and multiple duplicate ;we can find multiple missing and duplicates                  
        //                                                    Manipulation  :Array is unchanged
        /*
        [0,2,2,3,4,4,6]  --{0:1,  --> populate hashmap with element as key and count as value
                            2:2,      iterate  numbers 0 to arr.length  
                            3:1,        if !map.containskey(i) put i in  missingList ; 
                            4:2,        else  if map.get(i) >=2 put i in duplicateList
                            6:1]}        |
            Time:O(n)                    using map as condition as well as updating map inside condition   
            Space O(n)             
        */
    
        Map<Integer,Integer> map = new HashMap<>();
        for(int i =0; i <= arr.length-1; i++){
            if(!map.containsKey(arr[i])){
                map.put(arr[i], 1);
            }
            else{
                map.put(arr[i], map.get(arr[i])+1);
            }
        
    
    
        }
    
    
        List<Integer> missingList = new ArrayList<>();
        List<Integer> duplicateList = new ArrayList<>();
    
        for(int i = 1 ; i <= arr.length; i++){
            if(!map.containsKey(i)){
                missingList.add(i);

            }
            if(map.containsKey(i)){
                if(map.get(i) >=2){
                    duplicateList.add(i);}
            }  
        }
    

        


                
        //USING  MATHS   EQUATION(ARRAY ELEMENTS HAVE PATTERN)          -->Time:O(n) , Space O(1)
        //                                                                  Multiple      :Array can have multiple missing duplicate  ; we can find 1 missing and no duplicate so array must ave only 1 missing and no duplicate
        //                                                                   Manipulation  :Array is unchanged
        /*
        LOOK IN MATHS 
        */
        
        //USING  MATHS  BIT MANIPULATION(ARRAY ELEMENTS HAVE PATTERN)    -->Time:O(n) , Space O(1)
        //                                                                   Multiple     rray can have multiple missing duplicate  ; we can find 1 missing and no duplicate so array must ave only 1 missing and no duplicate
        //                                                                   Manipulation  :Array is unchanged
        /*
        LOOK IN MATHS 
        */

    
        }
    public void  arrayMissingDuplicatee1ToN(int[] arr){
        /*
        QUESTION
        [1,2,3,4,4,4,7] --array has element in unsorted manner
                            array must have elements 1 to N=arr.length
                            return the missing and duplicate numbers
                            Eg: [1,2,3,4,4,4,7]  
                                missing  = [5,6]
                                duplicate = [4]
                            EG:[1,2,3,1,5,1,7,2]
                            missing = [4,6,8]
                            duplicate = [1,2]

        */
    
        //USING MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)  -->Time:O(nlogn + n), Soace:O(1)
                                                                    // Multiple    :Array can have  multiple missing duplicates ; we can find multiple  missing,duplicates   
                                                                    // Manipulation :Array is changed
        /*
        LOOK IN ARR -MULTIPTR SORT SEARCH
        
        */
        //USING MULTIPOINTER SWAPSORT SEARCH(ARRAY REQUIRES SORTING)   -->Time:O(n) , Space O(1)
        //                                                                 Multiple    :Array can have  multiple missing duplicates ; we can find multiple  missing,duplicates   
        //                                                                 Manipulation:Array is changed      
        /*
        LOOK IN ARR -MULTIPTR SORT SEARCH
        
        */
        
    

        //USING HASHMAP(ARRAY REQUIRES STORING ELEMENTS)      -->Time:O(n);Space = O(n)
        //                                                       Multiple      :Array can have multiple missing and multiple duplicate ;we can find multiple missing and duplicates                  
        //                                                       Manipulation  :Array is unchanged
        /*
        [1,2,3,4,4,6]  --{1:1,  --> populate hashmap with element as key and count as value
                            2:1,      iterate  numbers 1 to arr.length  
                            3:1,        if !map.containskey(i) put i in  missingList ; 
                            4:2,        else  if map.get(i) >=2 put i in duplicateList
                            6:1]}        |
            Time:O(n)                    using map as condition as well as updating map inside condition   
            Space O(n)             
        */
    
        Map<Integer,Integer> map = new HashMap<>();
        for(int i =0; i <= arr.length-1; i++){
            if(!map.containsKey(arr[i])){
                map.put(arr[i], 1);
            }
            else{
                map.put(arr[i], map.get(arr[i])+1);
            }
        
    
    
        }
    
    
        List<Integer> missingList = new ArrayList<>();
        List<Integer> duplicateList = new ArrayList<>();
    
        for(int i = 1 ; i <= arr.length; i++){
            if(!map.containsKey(i)){
                missingList.add(i);

            }
            if(map.containsKey(i)){
                if(map.get(i) >=2){
                    duplicateList.add(i);}
            }  
        }


            
                
                
        //USING  MATHS EQUATION(ARRAY ELEMENTS HAVE PATTERN)    -->Time:O(n) , Space O(1)
        //                                                          Multiple      :Array can have only multiple missing and multiple duplicate ;but we can find 1 missing and 1 duplicate(so array must have 1 missinga and 1 duplicate only)
        //                                                          Manipulation  :Array is unchanged
        /*
        LOOK IN MATHS
        
        */
        
        //USING  MATHS BIT MANIPULATION(ARRAY ELEMENTS HAVE PATTERN)    -->Time:O(n)  Space O(1) 
        //                                                                  Multiple      :Array can multiple missing duplicate; but we can use this only 1 missing 1 duplicate(so array must have 1 missinga and 1 duplicate only)
        //                                                                  Manipulation  :Array is unchanged
        /*
        LOOK IN MATHS
        */




    
        }
    public void  arrayMissingPositivee1ToNPlus1(int[] arr){
        /*
        QUESTION
        [1,2,3,4,4,4,7] --array has element in unsorted manner
                            array must have elements 1 to N=arr.length[Question asks to find 1st missing +ve we made this conclusion looking at test cases like [1] -->1st missing +ve is 2 , [7,8,9,10] -->1st missing +ve is 1]
                            return the missing positives
                            Eg: [1,2,0]
                                missing positive  = [3,4]
                            EG:[3,4,-1,1]
                                missing positive  = [2,5]
                            EG:[7,8,9,10,11]
                                missingpositive = [1,2,3,4,5,6,7]

        */
        
        //USING MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES SORTING)  -->Time:O(nlogn + n), Soace:O(1)
                                                                    // Multiple    :Array can have  multiple missing posotoves ; we can find multiple  missing positives
                                                                    // Manipulation :Array is changed
        /*
        LOOK IN ARR MULTIPTR - SORT SEARCH
            */
    
                
        //                         __simiar to swap sort , instead of correct index we make corresponding index as -1
        //                        /     
        //USING MULTIPOINTER SWAP SORT(ARRAY REQUIRES SORTING)-->Time:O(n), Soace:O(1)
                                                                // Multiple    :Array can have  multiple missing positives ; we can find only 1st missing +ev 
                                                                    // Manipulation :Array is changed

                                                                                                                            
        /*
        LOOK IN ARR MULTIPTR - SORT SEARCH
            */
    

        //USING HASHMAP(ARRAY REQUIRES STORING ELEMENTS)   -->Time:O(n);Space = O(n)
        //                                                     Multiple      :Array can have multiple missing positives ;we can find multiple missing positives                 
        //                                                     Manipulation  :Array is unchanged
        /*
        [3,4,-1,1]  --{3:1,  --> populate hashmap with element as key and count as value
                        4:1,      iterate  numbers 1 to arr.length +1
                        -1:1,        if !map.containskey(i) put i in  missingList ; 
                        1:2}             
            Time:O(n)                     
            Space O(n)             
        */
    
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0 ; i<=arr.length-1 ; i++){
            if(!map.containsKey(arr[i])){
                map.put(arr[i],1);
            }
            else{
                map.put(arr[i], map.get(arr[i]) +1 );
            }
            
        }
        
        //i = 1 to arr.length+1 from question  //[1] -->2 missing
        List<Integer> missingList = new ArrayList<Integer>();
        for(int i = 1 ; i <= arr.length+1;i++ ){
            if(!map.containsKey(i)){
                missingList.add(i);
            }
        }
        
        //USING  MATHS BIT MANIPULATION(ARRAY ELEMENTS HAVE PATTERN)    -->Time:O(n)  Space O(1) 
        //                                                                  Multiple      :Array can multiple missing duplicate; but we can use this only 1 missing 1 duplicate(so array must have 1 missinga and 1 duplicate only)
        //                                                                  Manipulation  :Array is unchanged
        /*
        Skip
        */

    
    
    }
    public void  arrayNelementsPtimesOtherKtimess(int[] arr){
            /*
            Question
            [2,2,3,2] -- array has elements where  n elements appear p times and N-n elements appear k times, 
                        return element that appears p times
                        EG
                        [2,2,3,2] n=1,p = 1,k = 3         --means 1 element appears 1 time and other elements appear 3 times ; so return 3
                        [2,2,3,2,3,1,1,1] n=1,p = 2,k = 3 --means 1 element appears 2 time and other elements appear 3 times ; so return 3
                        [1,2,1,3,2,5]  n=2,p = 1,k = 2    --means 2 element appears 1 time and other elements appear 2 times ; so return [3,5] 

            
        */
        
        //USING MULTIPTR SORT AND SEARCH(ARRAY REQUIRES SORTING) -->Time:O(logn + n), Soace:O(1)
        //                                                           Multiple    :Array can have  multiple missing duplicates ; we can find multiple  missing,duplicates   
        //                                                           Manipulation :Array is changed
        /*
            LOOK IN ARRAY -MULTIPTR SORT SEARCH
        */
    
            //USING ARRAY SWAPSORT AND SEARCH(ARRAY REQUIRES SORTINH) -->Time:O(n) , Space O(1)
            //                                                           Multiple    :Array can have  multiple missing duplicates ; we can find multiple  missing,duplicates   
            //                                                           Manipulation:Array is changed 
            /*
            LOOK IN ARRAY -MULTIPTR SORT SEARCH
            */
    
    
        //USING  HASHMAP(ARRAY REQUIRES STORING ELEMENTS)       -->Time:O(n)  Space O(n) 
        //                                                        Multiple      :Array can have n=anything,p=anything,k=anything; we can use this only for n=anything,p=anything,k=anything
        //                                                        Manipulation  :Array is unchanged
        /*
        [2,2,3,2]     --{2:3,  --> populate hashmap with element as key and count as value
                            3:1,      iterate  hashmap
                        }          if value <=p add key to pList
            Time:O(n)   where n = length of array
            Space O(n)  
        
        */

        //k=2 ; p = 1 ; n = anything
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0 ; i <= arr.length-1;i++){
            if(! map.containsKey(arr[i]) ){
                map.put(arr[i],1);
            }
            else{
                map.put(arr[i],map.get(arr[i]) + 1);
            }
        }
        
        
        List<Integer> pList = new ArrayList<Integer>();
        for(var i : map.entrySet()){
            if(i.getValue() <= 1){
                pList.add(i.getKey());
            }
            
        }
        
        //return pList;

        //k = 3 ; p = 1 ; n = anything
        //same as above

        //k = 5 ; p=3 ; n = anything
        //same as above and i.getValue() <= 3
        
        
        


        //USING  MATHS BIT MANIPULATION(ARRAY ELEMENTS HAVE PATTERN)     -->Time:O(n)  Space O(1) 
        //                                                                  Multiple      :AArray can have n=anything,p=anything,k=anything; but we can use this only for n=2,p=1,k=2.
        //                                                                  Manipulation  :Array is unchanged
        /*
        LOOK IN MATHS
        */ 
    
        //USING  MATHS BIT MANIPULATION(ARRAY ELEMENTS HAVE PATTERN)     -->Time:O(n)  Space O(1)   
        //                                                                   Multiple      :Array can have n=anything,p=anything,k=anything; but we can use this only for n=1,p=anything,k=anything
        //                                                                   Manipulation  :Array is unchanged  
        /*
        LOOK IN MATHS
        */
    
    }
    public int[] arrayCompare2ArraysForIntersectionn(int[] arr1,int[] arr2){
        /*
        [3,3,1,2,4]  -->[3]   --find the intersection of array(intersection is common without any duplicates) in sorted manner
        [4,5,3,3,6]     
        */

        //USING MULTIPOINTERS SORT SEARCH (ARRAY REQUIRES SORTING) -->Time:O(n1logn1 + n2logn2 + n1 + n2) , Space:O(1)
        /*
       LOOK IN ARRAY ,ULTIPTR SORT AND SEARCH

        */
        
        
        
        //USING HASHMAP -->Time:O(n1+n2 + n1logn1 + n2logn2),Space:O(n) 
        /* 
        [1,3,2,3,4]   --{1:1    --iterate  arr1 and add elements as key and count as value
        [3,4,3,6,5]      2:1      iterate  arr2 
                         3:2        if map contains element        
                         4:1}         add keys to result
                                      remove element from map as same element may come later in arr2 and intersection does not have duplicate
                                    sort result from 0 to index exclusive because hashap doesnt guarantee order
                                    return result 0 to index exclusive
            
        Time:O(n1+n2 + n1logn1 + n2logn2),
        Space:O(n)  
        */
       int[] result = new int[arr1.length + arr2.length];
        Map<Integer,Integer> map = new HashMap<>();
        for(int i =0 ; i <= arr1.length-1;i++){
            if(!map.containsKey(arr1[i])){
                map.put(arr1[i],1);
            }
            else{
                map.put(arr1[i],map.get(arr1[i])+1);
            }
            
        }
        
        int index =0;
        for(int i = 0 ; i <= arr2.length-1;i++){
            if(map.containsKey(arr2[i])){
                result[index] = arr2[i];
                index++;
                map.remove(arr2[i]);
                
            }
        }
        Arrays.sort(result,0,index);
        return Arrays.copyOfRange(result,0,index);


        
        
        
    }
    public int[] arrayCompare2ArraysForCommonn(int[] arr1,int[] arr2){
        /*
        [3,3,1,2,4]  -->[3,3,6]   --find the common of array(common is common with duplicates) in sorted manner
        [4,5,3,3,6]     
        */

        //USING MULTIPOINTERS SORT SEARCH (ARRAY REQUIRES SORTING) -->Time:O(n1logn1 + n2logn2 + n1 + n2) , Space:O(1)
        /*
        Look in multiptr sort search 
        */



        
        //USING HASHMAP -->TTime:O(n1+n2 + n1logn1 + n2logn2),Space:O(n) 
        /*
        [3,3,1,2,4]  -->{3:2  --> iterate arr1 
        [4,5,3,3,6]      1:1         populate map with elements as keys and freq a values
                         2:1      iterate arr2
                         4:1          if map contains element of arr2
                                      add element of arr 2 to map

                                      reduce count of element of arr2 from map
                                      remove elemnt from map if count is 0

                                    sort result from 0 to index exclusive
                                    return result from 0 to index exclusive

        Time:O(n1+n2 + n1logn1 + n2logn2),
        Space:O(n) 
        */

        int[] res = new int[arr1.length]; int index = 0;
        
        Map<Integer, Integer> map = new HashMap<>();
        for(int i =0 ; i <= arr1.length-1 ; i++){
            if(!map.containsKey(arr1[i])){map.put(arr1[i],1);}
            else{map.put(arr1[i],map.get(arr1[i]) + 1);}
        }
        
        
        for(int i=0 ; i <= arr2.length-1;i++){
            if(map.containsKey(arr2[i])){
                res[index++] = arr2[i];
                
                map.put(arr2[i] , map.get(arr2[i]) - 1);
                if(map.get(arr2[i]) == 0){map.remove(arr2[i]);}
            }
            
        }
        
        Arrays.sort(res, 0, index);
        return Arrays.copyOfRange(res,0,index);
        
    }
    public int[] arrayCompare2ArraysForUnionn(int[] arr1,int[] arr2){
        /*
        [3,3,1,2,4]  -->[1,2,3,4,5,6]   --find the union of array(union is merging without any duplicates) in sorted manner
        [4,5,3,3,6]     
        */

        //USING MULTIPOINTERS SORT SEARCH (ARRAY REQUIRES SORTING) -->Time:O(n1logn1 + n2logn2 + n1 + n2) , Space:O(1)
       /*
       LOOK IN ARRAY ,ULTIPTR SORT AND SEARCH

        */

        //USING HASHMAP(ARRAY REQUIRES STORING  ) ->Time:O(n1+n2 + n1logn1 + n2logn2),Space:O(n)  
        /*
       [1,3,2,3,4]   --{1:1    --iterate  arr1 and add elements as key and count as value
       [3,4,3,6,5]      2:1      iterate  arr1 and add elements as key and count as value
                        3:4      iterate over map        
                        4:2        add ekeys to result
                        5:1      sort result from 0 to index exclusive because hashap doesnt guarantee order
                        6:1}     return result from 0 to index exclusive
        Time:O(n1+n2 + n1logn1 + n2logn2),
        Space:O(n)  
        */     
        int[] result = new int[arr1.length+arr2.length];
        Map<Integer,Integer> map = new HashMap<>();
        for(int i = 0 ; i <= arr1.length;i++ ){
            if(!map.containsKey(arr1[i])){
                map.put(arr1[i],1);
            }
            else{
                map.put(arr1[i],map.get(arr1[i]) +1);
            }
        }
       
         for(int i = 0 ; i <= arr1.length;i++) {
            if(!map.containsKey(arr2[i])){
                map.put(arr2[i],1);
            }
            else{
                map.put(arr2[i],map.get(arr2[i]) +1);
            }            
        }
       
       int index =0;
        for(var elements:map.entrySet()){
            result[index] = elements.getKey();
            index++;
            
        }
        Arrays.sort(result,0,index);
        
        
        return Arrays.copyOfRange(result,0,index);

        

        

        
    }
    public int[] arrayCompare2ArrayForMerginggI(int[] arr1, int[] arr2){
        /*
        [3,3,1,2,4]  -->[1,2,3,3,3,3,4,5,6]   --find the merge of array(merge is merging with duplicates) in sorted manner
        [4,5,3,3,6]                             merge the arrays in result arr
        */

     
        //USING MULTIPOINTERS SORT SEARCH (ARRAY REQUIRES SORTING) -->Time:O(n1logn1 + n2logn2 + n1 + n2) , Space:O(1)
        /*
        Look in array multiptr
        */

   
        
        //USING HASHMAP-->Time:O(n1 + n2 + n1logn1 + n2logn2 ) , Space:O(n)
        /*
        [3,3,1,2,4]  -->{3:3  -- iterate arr1 
        [4,5,3,3,6]      1:1       populate map with elements of arr1 as key and freq as value
                         2:1    iterate arr2
                         }          populate map with elements of arr1 as key and freq as value
                                 iterate map
                                    add key frequency times to res

                                Sort res from 0 to index exclusive
                                return  res from 0 to index exclusive


        Time:O(n1 + n2 + n1logn1 + n2logn2 ) 
        Space:O(n)
        */
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0 ; i <= arr1.length-1 ; i++){
            if(!map.containsKey(arr1[i])){map.put(arr1[i],1);}
            else{map.put(arr1[i], map.get(arr1[i]) + 1);}
        }
        
        for(int i=0 ; i <= arr2.length-1 ; i++){
            if(!map.containsKey(arr2[i])){map.put(arr2[i],1);}
            else{map.put(arr2[i], map.get(arr2[i]) + 1);}
        }
        
     
        
        
         int[] res = new int[arr1.length];int index =0;
        for(var i : map.entrySet()){
            for(int cnt = 1; cnt <= i.getValue() ; cnt++){
                res[index++] = i.getKey();
            }
            
        }
        
        
        Arrays.sort(res,0,index);
        return Arrays.copyOfRange(res,0,index);
    }
    public int[] arrayCompare2ArrayForMerginggII(int[] arr1, int[] arr2){
        /*
        [1,2,3,0,0,0]  -->[1,2,2,3,5,6]   --find the merge of array(merge is merging with duplicates) in sorted manner
        [2,5,6]                              merge the result in arr1; arr1 has m elements of arr1 and n zeros to accomodate n elements of arr2
        */

     
     
        //USING MULTIPOINTERS SORT SEARCH (ARRAY REQUIRES SORTING) -->Time:O(n1logn1 + n2logn2 + n1 + n2) , Space:O(1)
        /*
        Look in array multiptr
        */

   
        
        //USING HASHMAP-->Time:O(n1 + n2 + n1logn1 + n2logn2 ) , Space:O(n)
        /*
        [3,3,1,2,4]  -->{3:3  -- iterate arr1 
        [4,5,3,3,6]      1:1       if i == m break because elements after that are 0 
                         2:1       populate map with elements of arr1 as key and freq as value
                                iterate arr2
                         }          populate map with elements of arr1 as key and freq as value
                                 iterate map
                                    add key frequency times to ar1

                                Sort arr1 from 0 to index exclusive
                                return  arr1 from 0 to index exclusive


        Time:O(n1 + n2 + n1logn1 + n2logn2 ) 
        Space:O(n)
        */
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0 ; i <= arr1.length-1 ; i++){
            if(!map.containsKey(arr1[i])){map.put(arr1[i],1);}
            else{map.put(arr1[i], map.get(arr1[i]) + 1);}
        }
        
        for(int i=0 ; i <= arr2.length-1 ; i++){
            if(!map.containsKey(arr2[i])){map.put(arr2[i],1);}
            else{map.put(arr2[i], map.get(arr2[i]) + 1);}
        }
        
     
        
        
         int index =0;
        for(var i : map.entrySet()){
            for(int cnt = 1; cnt <= i.getValue() ; cnt++){
                arr1[index++] = i.getKey();
            }
            
        }    
        Arrays.sort(arr1,0,index);
        return Arrays.copyOfRange(arr1,0,index);
    }
    public boolean stringCompare2StringForIsomorphicc(String s1, String s2) {
        /*
        Question
        "egg"  -- check if s1 s2 are isomporphic
        "add"     all characters in s1 can be mapped to characters in s2 preserving the order
                  no 2 characters can be mapped to same characters
        
                  EG: "egg", "add"           -- true
                      "egcd"  "adfd"         -- false
                      "bbbaaaba" "aaabbbba"  --false
                      
        */
        
        //USING MULTIPTR SORT SEARCH
        /*
        Not applicable
        */
        
        //USING HASHMAP
        /*
        
        "egcd" 
         "adfd"
         |
         p1,p2 -- initialise map for ptr1 and its mapping to ptr2
                  initilise set for ptr2
                  initialise ptr1 and ptr2 
                  
                  while(ptr1 <= s1.length()-1 && ptr2 <= s2.length()-1){                         --move ptr1 and ptr2 till arr.length(ptr1 ptr2 at arr.length,cb...)
                    if(!map.containsKey(s1.charAt(ptr1)) && !set.contains(s2.charAt(ptr2)) ){       if ptr1 is not assigned and ptr2 is not assigned
                        map.put(s1.charAt(ptr1),s2.charAt(ptr2) );                                         assign ptr1 and its corresponding ptr2
                        set.add(s2.charAt(ptr2));   }                                                      assign ptr2
                    else if(map.containsKey(s1.charAt(ptr1)) && !set.contains(s2.charAt(ptr2)) ){    else if ptr1 is assigned but  ptr2 is not assigned
                        return false;                                                                      return false
                    }                                                                                      Eg "aca" ,"bdm"  -- when ptr at last element : map is {a:b,c:d} ; a is assigned but m is not assigned soso flase 
                    else if(!map.containsKey(s1.charAt(ptr1)) && set.contains(s2.charAt(ptr2))){    else if ptr1 is not assigned and ptr2 is assigned
                        return false;                                                                     return false
                    }                                                                                     Eg: "abbd" "xyyx"  -- when ptr at last element : map is {a:x,b:y} ; d is not assigned but x is already assigned and you cant map diff character to same character hence return false 
                    else if(map.containsKey(s1.charAt(ptr1)) && set.contains(s2.charAt(ptr2))        else if ptr1 is assigned and ptr2 is assigned
                        if(map.get(s1.charAt(ptr1)) != s2.charAt(ptr2)){                                if ptr1 ka corresponding map != ptr2
                            return false;                                                               return false    
                        }                                                                               Eg: "egg" "add" --when ptr at last element : map is {e:a,g:d} ; g and d are both assigned so check corresponding assignment of d
                    }
                    ptr1++;                                                                          move ptr1 and ptr2 ahead
                    ptr2++;
                }

                return true                                                                           return true at end
        
        
        */
        Map<Character, Character> map = new HashMap<>();
        Set<Character> set = new HashSet<>();
        int ptr1 = 0;
        int ptr2 = 0;
        
        while(ptr1 <= s1.length()-1 && ptr2 <= s2.length()-1){
            if(!map.containsKey(s1.charAt(ptr1)) && !set.contains(s2.charAt(ptr2)) ){
                map.put(s1.charAt(ptr1),s2.charAt(ptr2) );
                set.add(s2.charAt(ptr2));
            }
      
          
            else if(map.containsKey(s1.charAt(ptr1)) && !set.contains(s2.charAt(ptr2)) ){
                return false;
            }
                
            else if(!map.containsKey(s1.charAt(ptr1)) && set.contains(s2.charAt(ptr2))){
                return false;
            }
            else if(map.containsKey(s1.charAt(ptr1)) && set.contains(s2.charAt(ptr2))){
                if(map.get(s1.charAt(ptr1)) != s2.charAt(ptr2)){
                    return false;
                }
            }
           
               
            
            ptr1++;
            ptr2++;
        }
        

        return true;
    }
    public boolean stringCompare2StringsForAnagramm(String s1 , String s2){
        /*
        Question
        s1 = "abcde" -- compare s1 and s2
        s2 = "dbace"    and find if s2 is a anagram of s1((anagram means same characters in hjumbled sequence)

                 
        */
        
        //USING -MULTIPOINTERS SORT SEARCH(ARRAY REQUIRES COMPARISION FOR  2 ARRAYS) -->Time: O(nlogn + n); Space:O(1)
        /*
        Look in multiptr sort + search
        */ 
        

        //USING HASHMAP -->Time: O(n); Space:O(n)
        /*
        "abcde" -- iterate through string1 and populate hashmap with characters and key and count as value
        "dbace"    iterate through string 2 
                   if map doesnt contain character return false 
                   else reduce count and if count =0 remove character  from map
                   
                   returm map.size() == 0
        
        Time: O(n)
        Space: O(1)
        
        */
        
        Map<Character, Integer> map = new HashMap<>();
        for(int i=0 ; i <=  s1.length()-1;i++){
            if(!map.containsKey(s1.charAt(i)))
                map.put(s1.charAt(i), 1);
            else
                map.put(s1.charAt(i), map.get(s1.charAt(i))+1);
        }
        
        for(int i=0 ; i <= s2.length()-1;i++){
            if(!map.containsKey(s2.charAt(i))){
                return false;
            }
            else{
                 map.put(s2.charAt(i), map.get(s2.charAt(i))-1);
                 if(map.get(s2.charAt(i)) == 0)
                     map.remove(s2.charAt(i));
            }
        }
        
        
        return map.size() == 0;


        
        
        //USING MATHS BIT MANIPULATION(ARRAY ELEMENTS HAVE PATTERN) -->Time: O(n); Space:O(1)  XXX CANT USE 
        /*
        LOOK IN MATHS
        */
        
    }

    

    

    //MATRIX
    public int[][] matrixSortRow(int[][] arr){
        /*
        [[1,2,3,4,5],-- sort the matrix row wise
        [2,4,5,8,10],
        [3,5,7,9,11],
        [1,3,5,7,9]] 
        */
        
        
        //USING ARRAY --MULTIPTR(ARRAY REQUIRES MULTIPTR)
        /*
        j
        |
      i-[1,2,3,4,5],
        [2,4,5,8,10],
        [3,5,7,9,11],
        [1,3,5,7,9]]  --initialise i to 0 j to 0
                      while(i <= arr.length-1){   -- move i till arr.length(i at arr.length , cb i at arr.length-1 , a i en till arrlength)
                        Arrays.sort(arr[i]);
                        i++;
                    }

                    return arr;
        
        
        Time:O(n*m lon(n*m))
        Spae:O(n)
        */
        int i = 0;
        while(i <= arr.length-1){
            Arrays.sort(arr[i]);
            i++;
        }
        
        return arr;
        
        
    }
    public int[][] matrixSortRowColumn(int[][] arr){

        /*
        Question
        [[1,5,3]          -- sort matrix row and column wise
        [2,8,7]               [1,2,3]
        [4,6,9]]              [4,5,6]
                              [7,8,9]
        */                   
        
        //USING ARRAY -- MULTIPTR(ARRAY REQUIRES MULTIPTR
        /*
         j
         |
     i--[1,5,3]        
        [2,8,7]              
        [4,6,9]] i = 0                                 initialise i to o
                while(i <= arr.length-1){              move i till arr.length(i at arr.length , cb i enc tll arr.length-1 , cai enc tll arr.length)
                    int j=0;                              initialise j to 0   
                    while(j <= arr[0].length-1){          move j till arr[0].length(....)
                        tempArr[index++] = arr[i][j];         arr[i][j] add to tempArr
                        j++; }                                move j ahead
                    i++;}                                 move i ahead
                 
                Arrays.sort(tempArr);                sort temp arr
                
                i = 0;index =0                         initialise i and inde  to o
                while(i <= arr.length-1){              move i till arr.length(i at arr.length , cb i enc tll arr.length-1 , cai enc tll arr.length)
                    int j=0;                              initialise j to 0   
                    while(j <= arr[0].length-1){          move j till arr[0].length(....)
                        arr[i][j] = tempArr[index++];         arr[i][j] ko add to tempArr ka index
                        j++; }                                move j ahead
                    i++;}                                 move i ahead
                 
           



        Time: O(n*m log(n*n)) where n= rows m = column
        Space:O(n*m) 
                              
        */
        
        int[] tempArr = new int[arr.length*arr[0].length];int index =0;
        
        int i = 0;
        while(i <= arr.length-1){
            int j=0;
            while(j <= arr[0].length-1){ 
                tempArr[index++] = arr[i][j];
                j++;
            }
            
            i++;
        }
        
        Arrays.sort(tempArr);
        
        index = 0;
        i = 0;
        while(i <= arr.length-1){
            int j=0;
            while(j <= arr[0].length-1){  
                arr[i][j] = tempArr[index++] ;
                j++;
            }
            i++;
        }
        
        return arr;
        
        
    }
    public int[]   matrixFindElements(int[][] arr , int item){

        /*
        QUESTION
            { {10, 20, 30, 40},  --find element in matrix    
            {15, 25, 35, 45},     
            {27, 29, 37, 48},
            {32, 33, 39, 50}};     
        */


        //USING MULTIPTR(ARRAY REQUIRES MULTIPTR) -->Timr:O(n*m), Space:O(1)
        /*
        [10, 20, 30, 40],  --   iterate over rows 
        [15, 25, 35, 45],          iterate over each element and find matc
        [27, 29, 37, 48],          return index
        [32, 33, 39, 50]]; 
        
        Time:O(n*m)
        Space:O(1)
        */
        /*
        int i = 0;
        while(i <= arr.length-1){
            int j = 0;
            while(j <= arr[i].length-1){
                if(arr[i][j] == item){return new int[]{i,j};}
                j++;
            }
            i++;
        }

        return return new int[]{-1,-1};
        */

        //USING MULTIPOINTERS SORT +  BSI(ARRAY IS SORTED SO BS  ALGORITHM) -- Time:O(n*m log(n*n) + nlogm), Space:O(1) 
        //                                                                     Array has duplicate elements :Will give the 1st element mid finds
        /*      
        SORT
        [[]]                --sort matrix row and column wise

        SEARCH
                                   index = -1
        i--{10, 20, 30, 40},  --   iterate over rows 
           {15, 25, 35, 45},          index = Binary Search on each row array for item
           {27, 29, 37, 48},          if index != -1 then return index
           {32, 33, 39, 50}};         
                                     return index
        
        Time:O(n*m log(n*n) + n*logm) -->SORTING(n*m log(n*n))
        Space:O(1)                      sort row and column wose

                                       SEARCHING(n logm)
                                       search n arrays of size m and on each apply BS
        */
        /*

        matrixSortRowColumnWise(arr);

        int index = -1;
        int i = 0;
        while(i <= arr.length-1){
            index = arraySortedDescendingFindElement(arr[i], item);
            if(index != -1){
                //return new int[]{i,index};
            }
            i++;
        }
        return new int[]{-1,-1};
        */


        //USING MULTIPOINTERS SORT +  BSII(ARRAY IS SORTED SO BS)  -- O(n*m log(n*n) + n + m) 
        //                                                           Array has duplicate elements :Will give the 1st element mid finds
        /* 
        SORT
        [[]]                --sort matrix row and column wise

        SEARCH

                       j        -- i = 0 ; j =arr[0].length  means atart from top right 
                      |            while i <=arr.length -1 && j >=0 
     i--{10, 20, 30, 40},              if arr[i][j] == key
        {15, 25, 35, 45},                  return i,j
        {27, 29, 37, 48},              else if arr[i][j] < key
        {32, 33, 39, 50}};                 means key is greater so move down bu reassigning i ++ 
                                        else if arr[i][j] > key
                                            means key is less so move left by reassigning j--
                                
                                        return -1;   

        Time:O(n*m log(n*n) + n*logm) -->SORTING(n*m log(n*n))
        Space:O(1)                      sort row and column wise
 
                                       SEARCHING(n logm)
                                       worst case we need to traverse to bottom left element  n rows downn and m columns left)
        */

        /*
        matrixSortRowColumnWise(arr);

        int i = 0;
        int j = arr[0].length -1;

        while(i <= arr.length-1 && j >=0 ){
            if(arr[i][j] == item)
                return new int[]{i,j};
            else if(arr[i][j] > item){
                j--;
            }   
            else if(arr[i][j] < item){
                i ++;
            }

        }

        return new int[]{-1,-1};
    */

    return null;






    }
    public int     matrixRowWithMaxOccurenceOf1(int[][] arr , int item){
        /*
        Question
        [[0, 0]   --find the row with max occurence of 1
        [1, 1]      Eg : row 1 
                    

        */
        //USING MULTIPTR(ARRAY REQUIRES MULTIPTR) ----> Time: O(n*m) , Space:O(n*m)
        /*
        [[0,0]   -- iterate matrix
         [1,1]]        count 1's in each row 
                       keep maxCount
                    return maxCount
        Time:O(n*m)
        Space:O(1)
        
        */
        /*
        int i = 0;
        int maxCount = Integer.MIN_VALUE;
        int maxIndex = -1;
        while(i <= arr.length-1){
            int j = 0;
            int count =0;
            while(j <= arr[i].length-1){
                if(arr[i][j] == 1){count++}
                j++;
            }

            if(count >= maxCount){
                maxIndex = i;
            }


            i++;
        }

        return maxIndex;
        
        */

        
        //USING MULTIPOINTERS  BS(ARRAY IS SORTED SO BS  ALGORITHM) --Time:O(n*logm + n*logm) ; Space:O(1)
        /*
        SORT
        [[0,0]   --sort matrix row wise
         [1,1]]

        SERACH
        j
         |
     i--[0, 0]  
        [1, 1]  --iterate over rows
                  index = arraySortedFirstOccurence(arr[i],1)
                  count =  (index == -1) ? 0:arr[0].length-index;
                  if count > maxCount&& count != 0) > and not >= because you want to find 1st occ Eg: if row 1 and row 2 both ha 2 1's then > will conider only row 1 and >= will consider row 2 also  
                      maxIndex = i;                  count != 0 because you don want to update max on 0 occurences of 1 Eg:[0,0][0,0] whithout condition maxIndex will become 0 withCondition maxIndex stays -1
                      maxCount = count;
        
                return maxIndex;

        Time:O(n*logm + n*logm) -->SORTING(n*logm)
        Space:O(1)                 sort n arrays of size m  
                                   SEARCHING
                                   search n arrays of size m and on each apply BS


        */
       /*
         int i=0;
         int maxCount = Integer.MIN_VALUE;
         int maxIndex = -1; 
         while(i <= arr.length-1){
             int index = arraySortedFirstOccurence(arr[i],1);
             int count = (index == -1) ? 0:arr[0].length-index;
             if(count > maxCount  && count != 0 ){ 
                 maxIndex = i;                     
                 maxCount = count;
             }
             i++;
         }
         
         return maxIndex;
        
        */
         
        
        
        //USING HASHMAP(ARRAY REQUIRES STORING) --> Time: O(n*m) , Space:O(n*m)
        /*
         j
         |
     i--[0, 0]  
        [1, 1]  --i = 0   
                  iterate row
                    iterate column
                        add j as key and j ka freq as value to map
                        if map contains 1 
                        if map.get(1) > maxCount > and not >= because you want to find 1st occ Eg: if row 1 and row 2 both ha 2 1's then > will conider only row 1 and >= will consider row 2 also  
                          maxIndex = i
                          maxCount = map.get(1)  
                        clear map
                    return maxIndex
          

        Time: O(n*m)
        Space:O(n*m)
        */
        /*
        int maxCount = Integer.MIN_VALUE;
        int maxIndex = -1;
        Map<Integer,Integer> map = new HashMap<>();
        int i = 0;
        while(i <= arr.length-1){
            int j=0;
            while(j <= arr[0].length-1){
                if(!map.containsKey(arr[i][j])){map.put(arr[i][j],1 );}
                else{map.put(arr[i][j], map.get(arr[i][j]) + 1);}
                j++;
            }

            if(map.containsKey(1)){
                if(map.get(1) > maxCount){
                    maxIndex = i;
                    maxCount = map.get(1);
                }
            }
            map.clear();   
            i++;
        }
        return maxIndex;
        */

        return 0;
    }
    public int[]   matrixCompareRowForIntersection(int[][] arr){
        /*
        [3,3,1,2,4]  -->[3,4,5]   --find the intersection of matrix(intersection is common without any duplicates) in sorted manner
        [4,5,3,3,6] 
        [5,6,7,3,3,4,5,2,]    
        */

        //USING ARRAY - MULTIPOINTERS SORT+SEARCH (ARRAY REQUIRES SORTING) --> Time: O(n*mlogm + n*(m^2) ), Space:O(1)
        /*
        SORT
       [[3,3,1,2,4]      -->sort matrix row wise
        [4,5,3,3,6]          
        [5,6,7,3,3,4,5,2,]     
        ]                     

        SEARCH
          j
          |
     i--[[3,3,1,2,4]      -->find intersetion for 1st and 2nd row
        [4,5,3,3,6]          iterate rows
        [5,6,7,3,3,4,5,2,]      find the intersection of row and result
        ]                     return result

        Time:O(n*mlogm + n*(m^2)) -->SORTING(n*mlogm)
        Space:O(1)                  sort n arrays each array of size m 
                                    
                                    SEARCHING(n*(m^2))
                                    [[1,2,3],[4,5,6],[7,8,9],[10,11,12]]
                                    1st iteration :n                      -->each iteration res size increases  
                                    2nd iteration: n             +n          EG in 3rd iteration n+n is size of res arr and n is size of current arr
                                    3rd iteration: n   +n        +n
                                    4th iteration:(n   +n        +n      + n
                                    Total time    =n*m + n(m-1) + n(m-2) +n(1)
                                                  =n[m + m-1 + .....]
                                                  =n[m*m -(1+2..m)]
                                                  =n[m*m - m(m-1)/2]
                                                  =n[(2m*m - m*m +1)/2 ]
                                                  =m[m*m]

        */
        /*

        matrixSortRow(arr);

        int[] result = arrayCompare2ArraysForIntersection(arr[0],arr[1]);
        int i = 2;
        while(i <= arr.length-1){
            result = arrayCompare2ArraysForIntersection(result,arr[i]);
            i++;
        }

        return result;



        */

      
        //USING ARRAY --MULTIPTR SORT + BINARY SEARCH(ARRAY IS SORTED) --> Time: O(n*mlogm + n*logm ), Space:O(1)
        /*      
        SORT
       [[3,3,1,2,4]      -->sort matrix row wise
        [4,5,3,3,6]          
        [5,6,7,3,3,4,5,2,]     
        ]                     

        SEARCH
         j
         |
     i--[[1,2,3,4,5],  
        [2,4,5,8,10],     
        [3,5,7,9,11],      
        [1,3,5,7,9]] -- iterate over each element in 1st row avoiding duplicates(intersetion doesnt allow duplicates)
                            iterte over each row 
                              int index = Binary search on each row  for  each element in 1st row(IN BS() fn we assume arr to be sorted so in this case add Arrays.sort(arr))
                              int count = indexx == -1?0:1; 
                              foundCount = foundCount + count;  
     
                            if foundCount == arr.length
                                means elemnt in 1st row occurs in every array so add to res

                        return  Arrays.copyOfRange(res,0,index);
        
    
        Time:O(n*mlogm + n*(m^2)) -->SORTING(n*mlogm)
        Space:O(1)                  sort n arrays each array of size m 
                                    
                                    SEARCHING(n*logm)
                                    search n arrays and in each arr of size m use BS
                                    

        */
        /*
        matrixSortRow(arr);

        int[] res = new int[arr[0].length];int index = 0;
        int j=0;
        while(j <= arr[0].length-1){
            int i = 0;
            int foundCount =0;
            while(i <= arr.length-1){

                int indexx = arraySortedAscendingFindElement(arr[i],arr[0][j]);
                 int count = indexx == -1?0:1;
                foundCount = foundCount + count;
                i++;}
            if(foundCount == arr.length){
                res[index++] = arr[0][j];}


            
            int tempi = j;
            while(tempi <= arr.length-1 && arr[0][tempj] == arr[0][j]){
                tempj++;
            }
            j = tempj;
        }
        
        return Arrays.copyOfRange(res,0,index);
        
        
        */
        
        //USING HASHMAP--> --> Time: O(n*mlogm + n*(m^2) ), Space:O(n*m)
        /*
        same as above(sort + search) just use the arrayCompare2ArraysForIntersectionn() which uses hashmap 
        
        Time:O(n*mlogm + n*(m^2)) -->SORTING(n*mlogm)
        Space:O(1)                  sort n arrays each array of size m 
                                    
                                    SEARCHING(n*(m^2))
                                    [[1,2,3],[4,5,6],[7,8,9],[10,11,12]]
                                    1st iteration :n                      -->each iteration res size increases  
                                    2nd iteration: n             +n          EG in 3rd iteration n+n is size of res arr and n is size of current arr
                                    3rd iteration: n   +n        +n
                                    4th iteration:(n   +n        +n      + n
                                    Total time    =n*m + n(m-1) + n(m-2) +n(1)
                                                  =n[m + m-1 + .....]
                                                  =n[m*m -(1+2..m)]
                                                  =n[m*m - m(m-1)/2]
                                                  =n[(2m*m - m*m +1)/2 ]
                                                  =m[m*m]
              
        */
        /*
        same as above(sort + search) just use the arrayCompare2ArraysForIntersectionn() which uses hashmap 
        */

        return null;
    
    
    
    
    
    
    }
    public int[]   matrixCompareRowForCommon(int[][] arr) {
        /*
        [3,3,1,2,4]  -->[3,3]   --find the common of matrix(common is common with any duplicates) in sorted manner
        [4,5,3,3,6] 
        [5,6,7,3,3,4,5,2,]  

        */

     
        //USING MULTIPOINTERS SORT SEARCH (ARRAY REQUIRES SORTING) --> Time: O(n*mlogm + n*(m^2) ), Space:O(1)
        /* 
        SORT
       [[3,3,1,2,4]      -->sort matrix row wise
        [4,5,3,3,6]          
        [5,6,7,3,3,4,5,2,]     
        ]                     

        SEARCH
          j
          |
     i--[[3,3,1,2,4]      -->find common for 1st and 2nd row
        [4,5,3,3,6]          iterate rows
        [5,6,7,3,3,4,5,2,]      find the commn of row and result
        ]                     return result
        

        Time: O(n*mlogm + n*(m^2) )-->explanation in matrixCompareRowForIntersection()
        Space:O(1)

        */
        /*
        matrixSortRow(arr);

        int[] result = arrayCompare2ArraysForCommon(arr[0],arr[1]);
        int i = 2;
        while(i <= arr.length-1){
            result = arrayCompare2ArraysForCommon(result,arr[i]);
            i++;
        }

        return result;
        */

          
        //USING ARRAY --MULTIPTR SORT + BINARY SEARCH(ARRAY IS SORTED) -->Time: O(n*mlogm + n*logm ), Space:O(1)
        /*      
        
        For common we cant use BS with foundCount logic
        Eg:[2,2,2]   -- for frrst 2 fountcount = 3; second 2 fountcount=3; third 2 fountcount=3
           [2,3,4]      so res will have [2,2,2] but 3 2's are not present in all rows so wrong answer
           [2,5,7]

        Time: O(n*mlogm + n*logm )-->explanation in matrixCompareRowForIntersection()
        Space:O(1)

    
        */

        

        //USING HASHMAP--> Time: O(n*mlogm + n*(m^2) ), Space:O(n*m)
        /*
        same as above(sort + search) just use the arrayCompare2ArraysForCommonn() which uses hashmap 

        Time: O(n*mlogm + n*(m^2) )-->explanation in matrixCompareRowForIntersection()
        Space:O(1)

        */
      return null;
    }
    public int[]   matrixCompareRowForUnion(int[][] arr) {
        /*
        [3,3,1,2,4]  -->[3,3]   --find the union of matrix(union is combination without any duplicates) in sorted manner
        [4,5,3,3,6] 
        [5,6,7,3,3,4,5,2,]   

        */

     
        //USING MULTIPOINTERS SORT SEARCH (ARRAY REQUIRES SORTING)--> Time: O(n*mlogm + n*(m^2) ), Space:O(1) 
        /* 
        SORT
       [[3,3,1,2,4]      -->sort matrix row wise
        [4,5,3,3,6]          
        [5,6,7,3,3,4,5,2,]     
        ]        

        SERACH
          j
          |
     i--[[3,3,1,2,4]      -->find union for 1st and 2nd row
        [4,5,3,3,6]          iterate rows
        [5,6,7,3,3,4,5,2,]      find the union of row and result
        ]                     return result
        
   

        Time: O(n*mlogm + n*(m^2) )-->explanation in matrixCompareRowForIntersection()
        Space:O(1)

    

        */

        /*
        matrixSortRow(arr);

        int[] result = arrayCompare2ArraysForUnion(arr[0],arr[1]);
        int i = 2;
        while(i <= arr.length-1){
            result = arrayCompare2ArraysForUnion(result,arr[i]);
            i++;
        }

        return result;
        */


        //USING ARRAY --MULTIPTR SORT + BINARY SEARCH(ARRAY IS SORTED) --> Time: O(n*mlogm + n*logm ), Space:O(1)
        /*      
        
        For union we cant use BS with foundCount logic
        Eg:[2,2,3]   -- for  2 fountcount = 2 which indicates 2 found in all 3 rows but that doesnt help in finding union
           [2,2,4]      
           [2,2,7]
    
        Time: O(n*mlogm + n*logm )-->explanation in matrixCompareRowForIntersection()
        Space:O(1)
        */

        

        //USING HASHMAP--> O(n*mlogm + n*(m^2) ), Space:O(n*m)
        /*
        same as above just use the arrayCompare2ArraysForUnion() which uses hashmap 

        Time: O(n*mlogm + n*(m^2) )-->explanation in matrixCompareRowForIntersection()
        Space:O(1)
        */

        return null;
      
    }
    public int[]   matrixCompareRowForMerging(int[][] arr) {
        /*
        [3,3,1,2,4]  -->[3,3]   --find the merge of matrix(merge is combination with duplicates) in sorted manner
        [4,5,3,3,6] 
        [5,6,7,3,3,4,5,2,]   
     
        */

     
        //USING MULTIPOINTERS SORT SEARCH (ARRAY REQUIRES SORTING) -->Time: O(n*mlogm + n*(m^2) ),Space:O(1)
        /*   
        SORT
       [[3,3,1,2,4]      -->sort matrix row wise
        [4,5,3,3,6]          
        [5,6,7,3,3,4,5,2,]     
        ]   


        SEARCH
          j
          |
     i--[[3,3,1,2,4]      -->find merging for 1st and 2nd row
        [4,5,3,3,6]          iterate rows
        [5,6,7,3,3,4,5,2,]      find the merging of row and result
        ]                     return result
        
   
        Time: O(n*mlogm + n*(m^2) )-->explanation in matrixCompareRowForIntersection()
        Space:O(1)

    

        */
        /*
        matrixSortRow(arr);

        int[] result = arrayCompare2ArrayForMergingI(arr[0],arr[1]);
        int i = 2;
        while(i <= arr.length-1){
            result = arrayCompare2ArrayForMergingI(result,arr[i]);
            i++;
        }

        return result;
        */

        //USING MULTIPTR SORT + BINARY SEARCH(ARRAY IS SORTED) --> Time: O(n*mlogm + n*logm ), Space:O(1)
        /*      
        
        For union we cant use BS with foundCount logic
        Eg:[2,2,3]   -- for  2 fountcount = 2 which indicates 2 found in all 3 rows but that doesnt help in finding merging
           [2,2,4]      
           [2,2,7]

        Time: O(n*mlogm + n*logm )-->explanation in matrixCompareRowForIntersection()
        Space:O(1)
    
        */


        //USING MULTIPTR SORT + HEAP --> Time: O(n*mlogm + n*logm ), Space:O(m)
        /*

        SORT
        [[1,2,4]      --sort matrix row wise
         [3,4,5]         
         [2,3,6]] 

        HEAP
        [[1,2,4]      --  [1,0,0]    -- add 1st elements of rows and their n,m indexes to minheap in asc order based on the element(min element at top can be popped)
         [3,4,5]          [2,2,0]       while !minheap.isEmpty
         [2,3,6]]         [3,1,0]            pop the top arr of minheap 
                                             add popped arr ka element  to res
                                             add popped arr ke element ka next element in that row to minHeap if nextelemnt is in bounds 
                                        return res


        Time: O(n*mlogm + n*m*logm) --> SORTING(n*mlogm)
        Space:O(m)                    sort n arrays of size m
                                       
                                      SERACHING(n*m*logm)
                                      iterate over n*m elements and at max add m elements to maxheap


        */
       /*
        matrixSortRow(arr);

        PriorityQueue<int[]> minHeap = new PriorityQueue<>(
            (int[] a,int[] b) ->{
                if(a[0] != b[0])
                    return a[0] - b[0];
                else
                    return a[1] - b[1];
                }
            );
            
        int ptr = 0;
        while(ptr <= arr.length-1){
            minHeap.add(new int[]{arr[ptr][0],ptr,0});
            ptr++;
        }
        int[] res = new int[arr.length*arr[0].length];int index =0;
        
        
        while(!minHeap.isEmpty()){
            int[] removedArr = minHeap.remove();
            int removedValue = removedArr[0];
            int removedIndex1 = removedArr[1];
            int removedIndex2 = removedArr[2];
            
            res[index++] = removedValue;
            
            int addIndex1 = removedIndex1;
            int addIndex2 = removedIndex2+1;
            if(addIndex2 <= arr[addIndex1].length-1){
                int addValue = arr[addIndex1][addIndex2];
                minHeap.add(new int[]{addValue,addIndex1,addIndex2});
            }
                
                
        }
          return res;
        
        
        */



        //USING HASHMAP--> Time: O(n*mlogm + n*(m^2) ), Space:O(m)
        /*
        same as above just use the arrayCompare2ArrayForMergingg() which uses hashmap 

           
        Time: O(n*mlogm + n*(m^2) )-->explanation in matrixCompareRowForIntersection()
        Space:O(n*m)
        */
      
        return  null;
    }
    public Node    matrixLLCompareRowForMerging(Node[] arr){
        /*
       [1,2,4]  -->1-2-3-4-5-6   --find the merge of matrix containing LL(merge is combination with duplicates) in sorted manner
       [3,4,5] 
       [2,3,6]   
    
       */

    
        //USING MULTIPOINTERS SORT SEARCH (ARRAY REQUIRES SORTING) -->Time: O(n*mlogm + n*(m^2) ),Space:O(1)
        /*   
        SORT 
        [1,2,4]   -->sort matrix by rows ie  iterate over each row and sort linked lists
        [3,4,5] 
        [2,3,6] 

        SERACH
        [1,2,4]  -->  find the merge of 1st and 2nd row
        [3,4,5]       iterate rows
        [2,3,6]          find merge of row and res
                        return res

        Time: O(n*mlogm + n*(m^2) )-->explanation in matrixCompareRowForIntersection()
        Space:O(1)


    

        */
        /*
        int ptr = 0;
        while(ptr <= arr.length-1){
            Node sortedLL = linkedListInsertionSort(list[i]);
            arr[i] = sortedLL;
        }
        
        
        int ptr1 = 0;
        int ptr2 = 1;
        Node res = compare2LLSortedForMerging(arr[ptr1], arr[ptr2]);
        
        ptr1++;
        ptr2++;
        while(ptr2 <= arr.length-1){
            res  = compare2LLSortedForMerging(res,arr[ptr2]);
            ptr2++;
        }
        
        return res;
        */


       //USING MULTIPTR SORT + BINARY SEARCH(ARRAY IS SORTED) --> Time: O(n*mlogm + n*logm ), Space:O(1)
       /*      
       
       For merging we cant use BS with foundCount logic
       Eg:[2,2,3]   -- for  2 fountcount = 2 which indicates 2 found in all 3 rows but that doesnt help in finding merging
          [2,2,4]      
          [2,2,7]

       Time: O(n*mlogm + n*logm )-->explanation in matrixCompareRowForIntersection()
       Space:O(1)
   
       */


       //USING MULTIPTR SORT + HEAP --> Time: O(n*mlogm + n*logm ), Space:O(m)
       /*
       SORT 
       [1,2,4]   -->sort matrix by rows ie  iterate over each row and sort linked lists
       [3,4,5] 
       [2,3,6] 


       SEARCH
        [[1,2,4]      --  [1,0,0]    -- add 1st elements of rows  to minheap in asc order based on the value of 1st elements if it is not null(min element at top can be popped)
        [3,4,5]          [2,2,0]       while !minheap.isEmpty
        [2,3,6]]         [3,1,0]            pop the top LL of minheap 
                                            add popped LL ka element  to res
                                            add popped LL ke element ka next element in that row to minHeap if nextelemnt is  not null 
                                        return res by reassigning head




        Time: O(n*mlogm + n*m*logm) --> SORTING(n*mlogm)
        Space:O(m)                    sort n LL of size m
                                       
                                      SERACHING(n*m*logm)
                                      iterate over n*m elements and at max add m elements to maxheap



       
       */
       /*
       int ptr = 0;
       while(ptr <= arr.length-1){
           Node sortedLL = linkedListInsertionSort(list[i]);
           arr[i] = sortedLL;
       }

       PriorityQueue<ListNode> minHeap = new PriorityQueue<>(
           (ListNode a, ListNode b) ->{return a.val-b.val;}
       );
       

       int ptr = 0;
       while(ptr <= arr.length-1){
           if(arr[ptr] != null)             //extra null check for LL not required for ar
               minHeap.add(arr[ptr]);
           ptr++;
       }
       
    
       ListNode dummyNode = new ListNode(-1);
       ListNode head = dummyNode;
       ListNode ptrr = dummyNode;       
       while(!minHeap.isEmpty()){
           
           ListNode removedLL = minHeap.remove();            
           
           ptrr.next = new ListNode(removed.val);
           ptrr = ptrr.next;
               
           ListNode added = removed.next;    
           if(added != null){
               minHeap.add(added);
           }
           
           
       }
       
       head = head.next;
       dummyNode.next = null;
       return head;
       
       */



   
       return null;
   }  
    public int[][] matrixCompareRowsForMergingOverlappingInterval(int[][] arr){

        /*
        [[1,3],[2,6],[8,10],[15,18]] -- merge the overlapping intervals
                                        where [1,2] and [2,1] so 2 is considered overlapping
                                         Eg [[1,3],[2,6],[8,10],[15,18]] -- [[1,6],[8,10],[15,18]]
        */
        
        
        //USING MULTIPOINTERS SORT SEARCH (ARRAY REQUIRES SORTING)  + STACK(REQUIRE STACK)
        /*
        SORT
        [[1,3],[2,6],[8,10],[15,18]] -- sort based on 0th index  of arrays 
        
        SEARCH
        [[1,3],[2,6],[8,10],[15,18]] 
          |
          ptr                 --initialis ptr to 0
                                push ptr to stack
                                move ptr head
                                while(ptr <= arr.length-1){
                                    if(stack.peek()[1] < arr[ptr][0]){
                                    means they do not overlap
                                        push arr[ptr] to stack  
                                    }
                                    else if(stack.peek()[1] >= arr[ptr][0]){
                                        means they overlap
                                        pop from stack
                                        pust to stack [min of all4, max of all 4]
                                    }
                                    
                                while stack is not empty
                                   pop from stack and add in res in reverse direction
                                   
                                return res
                                    
        Time:O(nlogn + n)   --> SORT(nlogn)
        Space:O(n)              just sort n arrays based on 0th index
                                    
                               SEARCH:
                               Searchig through n arrays
        
        
        */
        
        Arrays.sort(arr, (a,b) ->{return a[0] - b[0];});
        
        Stack<int[]> stack = new Stack<>();
       
        
        int ptr = 0;
        stack.push(arr[ptr]);
        ptr++;
        while(ptr <= arr.length-1){
            if(stack.peek()[1] < arr[ptr][0]){
                stack.push(arr[ptr]);
            }
            else if(stack.peek()[1] >= arr[ptr][0]){
  
                int min = Math.min(
                          Math.min(stack.peek()[0],stack.peek()[1]),
                          Math.min(arr[ptr][0] , arr[ptr][1])
                           );
               int max = Math.max(
                          Math.max(stack.peek()[0],stack.peek()[1]),
                          Math.max(arr[ptr][0] , arr[ptr][1])
                           );
                
                stack.pop();
                stack.push(new int[]{min,max});
                              
                
                
            }
            
            
            ptr++;
        }
        
        int[][] res = new int[stack.size()][2];int index = res.length-1;
        while(!stack.isEmpty()){
            res[index--] = stack.pop();
        }
        
        return res;
        
        
        
        
    }
    public int[][] matrixCompareRowForMergingOverlappingIntervalByInsertion(int[][] arr, int[] insertion) {
        /*
        
        [[1,3],[6,9]];  [2,5] --insert the array and then merge the overlapping intervals
                                where [1,2] and [2,1] so 2 is considered overlapping
                                Eg [[1,3],[6,9]];  [2,5] -- [[1,5],[6,9]]
        */

        //USING ARRAY MULTIPTR (ARRAY REQUIRES MULTIPTR)
        /*
        [[1,3],[6,9]];[2,5]
          |
          ptr               --initialise ptr to 0
                            initialise newStart = insertion[0], newEnd = insertion[1]

                            // ADD ALL ARRAY SMALLER THAN INSERTION
                            while (ptr <= arr.length-1 && arr[ptr][1] < newStart){   --move ptr till arr[ptr][1] < newStart
                                res.add(arr[ptr]);                                         add arr[ptr] to res
                                 ptr++;                                                    move ptr ahead
                            }

                            //MERGE ALL ARRAY WITHIN INSERTION RANGE
                            while(ptr <= arr.length-1 && arr[ptr][0] <= newEnd){    --move ptr till arr[ptr][0] <= newEnd 
                                newStart = Math.min(newStart, arr[ptr][0]);                reassign newStart to min of arr[ptr][0]        
                                newEnd = Math.max(newEnd, arr[ptr][1]);                    reassign newSEnd to max of arr[ptr][1] 
                                ptr++;                                                     move ptr ahead
                            }
                            res.add(new int[]{newStart, newEnd});                     add [newStart,newEnd] to res


                            //ADD ALL ARRAY AFTER INSERTION
                             while (ptr <= arr.length-1){                               --move ptr till arr.lenth
                                res.add(arr[ptr]);                                           add arr[ptr] to res
                                ptr++;                                                       move ptr ahead
                            }

                            return res



        
        Time:O(n)
        Space:O(1)
        */
    
        ArrayList<int[]> res = new ArrayList<int[]>();
        int newStart = insertion[0], newEnd = insertion[1];
        int ptr = 0;

        while (ptr <= arr.length-1 && arr[ptr][1] < newStart){
            res.add(arr[ptr]);
            ptr++;
        }
          


        while(ptr <= arr.length-1 && arr[ptr][0] <= newEnd){
            newStart = Math.min(newStart, arr[ptr][0]);
            newEnd = Math.max(newEnd, arr[ptr][1]);
            ptr++;
        }   
        res.add(new int[]{newStart, newEnd});

        // add all intervals after newInterval  
        while (ptr <= arr.length-1){
            res.add(arr[ptr]);
            ptr++;
            
        }
          

        return res.toArray(new int[0][0]);
  
    }
    public int     matrixComareRowsForNonOverlappingIntervalByMinRemoval(int[][] arr){
        /*
        [[1,2],[2,3],[3,4],[1,3]] -- for matrix give the minimum number of removal required to ake the arrays non overlapping
                                      where [1,2] and [2,1] ; 2 is not considered overlapping
        
        */

        //USING ARRAY MULTIPTR SORT  + SEARCH (ARRAY REQUIRES MULTIPTR)
        /*
        SORT
        [[1,2],[2,3],[3,4],[1,3]] --sort based on 0the lement


        SERACH
        [[1,2],[1,3],[2,3],[3,4]] 
         |
         ptr                      --initialise ptr to 0
                                    initialise start to arr[ptr][0]
                                    initialise end to arr[ptr][1]

                                    increment ptr
                                    while(ptr <= arr.length-1){                         
                                        if(end <= arr[ptr][0] ){                                       
                                            means they do not overlap                  
                                            start = min of all 4 ,end = max of all 4
                                           because you need max range for comparing
                                        }
                                        else if(end> arr[ptr][0] ){                             
                                            means they overlap
                                            if(end < arr[ptr][1] ){  
                                                remove ptr ka interval which ends late  -->remove the one ending later 
                                                so start and end will remain same           Eg  _________       
                                                so increment count                           ________  ______   
                                            }                                              if you remove above one(ending later) then you need only one removal 
                                                                                           if you remove below left then you will also require to remove above one or bottom right; so 2 removals  
                                            else if(end >= arr[ptr][1]){                          
                                                remove our start end ka interval which ends later          
                                                so start and end will become ptr ka interval
                                                so increment cnt 
                                                
                                                
                                            }
                                        }                                     
                                        ptr++;
                                    }
                                    
                                    
                                    return  count;

        Time:O(logn + n)
        Space:O(1)
        */
        Arrays.sort(arr, (a, b) -> {return a[0] - b[0];});
        int count =0;
        
        int ptr = 0;
        int start = arr[0][0];
        int end = arr[0][1];

        ptr++;
        while(ptr <= arr.length-1){
            if(end <= arr[ptr][0] ){
                start = Math.min(arr[ptr][0],start);
                end = Math.max(arr[ptr][1],end);
                
        
            
            }
        
            else if(end> arr[ptr][0] ){
            if(end < arr[ptr][1] ){
                    start = start;
                    end = end;
                    count++;
                }
                else if(end >= arr[ptr][1]){
                    start = arr[ptr][0];
                    end =  arr[ptr][1];
                    count++;
                    
                }
            
            }
            
            ptr++;
        }
        
        
        return  count;
     }
    public boolean matrixCompareRowsForMergingMeetingRoomIntervalI(int[][] arr){
        /*
        
        [[0,30],[5,10],[15,20]] --arr consists of start time and end time of meetings
                                  return whether a person can attend all meetings
        
        */
        
          
        //USING MULTIPOINTERS SORT SEARCH (ARRAY REQUIRES SORTING)
        /*
        //SORT
         [[0,30],[5,10],[15,20]]  -- sort arr in asc order based on start time and if start time is same sort in asc order based on end time
       
       //SEARCH
         [[0,30],[5,10],[15,20]]  --iterate through rows
                                       check consecutive rows
                                       if(arr[ptr1][1] <= arr[ptr2][0]) 
                                            means  end time of ptr1 <= start time of ptr2 so  he can attend meating so do nothing
                                       elseif(arr[ptr1][1] > arr[ptr2][0])
                                           means end time of ptr1 > start time of ptr2 so he cant attend meeting so return false
                                        return true
                                        
        Time:O(nlogn + n)   --> SORT(nlogn)
        Space:O(n)              just sort n arrays based on 0th index
                                    
                               SEARCH:
                               Searchig through n arrays
                                      
       
       
          */
   
        Arrays.sort(arr, (int[] a, int[] b) ->{
            return (a[0] != b[0]) ? (a[0] - b[0]):(a[1]-b[1]);
        }
        );
        int ptr1 = 0;
        int ptr2 = 1;
          while(ptr2<= arr.length-1){
              if(arr[ptr1][1] <= arr[ptr2][0]){}
              else if(arr[ptr1][1] > arr[ptr2][0]){
                return false;    
              }

              ptr1++;
              ptr2++;
          }
          
          return true;
        
       
     
        
        
       
        
        
        
        
    }
    public int     matrixCompareRowsForMergingMeetingRoomIntervalII(int[][] arr){
        /*
        
        [[0,30],[5,10],[15,20]] --arr consists of start time and end time of meetings
                                  return the min no of conf rooms needed for meetings
                                  Eg:[[0,30],[5,10],[15,20]] --2
                                  Eg:[[7,10],[2,4]] --1
        
        
        */
        
        //USING MULTIPOINTERS SORT SEARCH (ARRAY REQUIRES SORTING) + MINHEAP
        /*
        //SORT
       [[0,30],[5,10],[15,20]]  -- sort arr in asc order based on start time and if start time is same sort in asc order based on end time

       //SEARCH
       [[0,30],[5,10],[15,20]]  --[[5,10],[15,20],[0,30]]        
           |                         X                              
           |
          ptr --initialise ptr to 0                                                      
                add arr[ptr] to minheap(add arr[startTime,endTime] to minheap in asc order based on end time and if enTime is same then  order based on startTime(min end time at top and if end time is same min start time at top))
                move ptr ahead
                iterate over rows
                    if(minHeap.peek()[1] <= arr[ptr][0]  ){
                        means conference room with min end time is free for current meeting so you can do current meeting in this conference room
                        remove top meeting from heap
                        add this meeting to heap
                    
                    }
                    else if( minHeap.peek()[1] > arr[ptr][0]  ){
                        means conf room with min end time is also not available so no conference room is available for current meeting so you need new conference room for meeting
                        add current meeting to heap
                    }

                return headp.size() which signifies no of conference room
        
        Time:O(nlogn + nlogn) --> SORT(nlogn)
        Space:O(n)              just sort n arrays based on 0th index
                                    
                               SEARCH(n logn)
                                n for iterating n rows and logn  performing heap fns 
        
                                                                   
        */

        Arrays.sort(arr, (int[] a, int[] b) ->{
            return (a[0] != b[0]) ? (a[0] - b[0]):(a[1]-b[1]);
        }
        );
        //minheap based on end time so that min end time is at top can be popped
        
        PriorityQueue<int[]> minHeap = new PriorityQueue<>((int[] a, int[] b)->{
            return (a[1] != b[1])? a[1] - b[1]: a[0] - b[0];
            }
        );
                    
        int ptr = 0;
        minHeap.add(arr[ptr]);
        ptr++;
        
        while(ptr <= arr.length-1){
            if(minHeap.peek()[1] <= arr[ptr][0]  ){
                minHeap.remove();
                minHeap.add(arr[ptr]);
            }
            else if( minHeap.peek()[1] > arr[ptr][0]  ){
               minHeap.add(arr[ptr]);
            }
            
            
            ptr++;
        }
        
    
                    
        return minHeap.size();
     
        
        
       
        
        
        
        
    }
    public void    matrixCompareRowsForAnagramsGrouping(String[] arr ){
        /*
        ["eat","tea","tan","ate","nat","bat"]-- group anagrams togerther 
                                                Eg:[["bat"],["nat","tan"],["ate","eat","tea"]]

        
        
        */
        
        //USING MULTIPTR SORT + SEARCH + HASHMAP(ARRAY REQUIRES SORTING + STORING) -->Time:O(n*mlogm + n)  Space: O(n*m)    
        /*
        ["are","bat","ear","code","tab","era"] -- {"a#e#r":["are","ear","era"],   --iterate array
                                                   "a#b#t":["bat","tab"],              generate unique key ele1#ele2#ele3#(sort) --Look in JAVA/OBJECTS/UNIQUE
                                                   "e#c#d#o":["code"]                  add the unique as key; actual string to the list as value as all anagram will generate same key
                                                   }                               iterate hashmap
                                                                                      add values to result arr

        Time:O(n*mlogm + n)   --> SORTING(n*mlogm)
        Space: O(n*m)              sort n strings each of size m
                   |               
                   |               SEARCH
                   |               iterate n strings in arr and iterate n keys in hashmap
                   |
                   |-- ------------SPACE:
                                    store n strings each of size m

                                  
        */
        /*
        public List<List<String>> matrixCompareRowsForAnagramsGrouping(String[] arr ){
            Map<String,List<String>> map = new HashMap<>();
            
            for(int i=0;i<= arr.length-1;i++){
                String s = generateUniqueKey(arr[i]);
                if(!map.containsKey(s)){
                    List<String> tempList = new ArrayList<>();
                    tempList.add(arr[i]);
                    map.put(s,tempList);
                }
                else{
                    List<String> tempList = map.get(s);
                    tempList.add(arr[i]);
                    map.put(s,tempList);
                }
            }
        
            List<List<String>> res = new ArrayList<>();
            for(var i:map.entrySet()){
                res.add(i.getValue());
                
            }
        
            return res;
        }
    
    
        public String generateUniqueKey(String s){
            char[] arr = s.toCharArray();
            Arrays.sort(arr);
            StringBuffer sb= new StringBuffer("");
            for(int i=0 ; i<=arr.length-1;i++){
                sb.append(arr[i]);
                sb.append("#");
            }
            
            return sb.toString();
        }
    
    
        */

        //USING MULTIPTR HASHMAP + HASHMAP(ARRAY REQUIRES SORTING + STORING) -->Time:O(n*m)   Space:O(n*m)  
        /*
        ["are","bat","ear","code","tab","era"] -- {"1#0#0#0#1#..":["are","ear","era"],   --iterate array
                                                   "1#1#0#0#0#..":["bat","tab"],           generate unique key ele1#count#ele2#count#(arr) --Look in JAVA/OBJECTS/UNIQUE
                                                   "0#0#0#0#1#..":["code"]                  add the sorted string as key; actual string to | the list as value
                                                   }                                     iterate hashmap                                   |   
                                                                                         add values to result arr                          |
                                                                                                                                           |
                                                                                                                                1.HashMap
                                                                                                                                store ch as key ad count as val to map; iterate map and append key and value to string
                                                                                                                                Problem:
                                                                                                                                "rub" --"r1u1b1" ,"bur" -- "b1u1r1"
                                                                                                                                They generates different key but they must generate same key as they are anagra,s
                                                                                                                                2.Array
                                                                                                                                store char ki freq at index of arr; convert arr to string
                                                                                                                                Problem:
                                                                                                                                "bdddddddddd"--"01010000..","bbbbbbbbbbc"-- "0101000"
                                                                                                                                They generate same key(b ka 1 d ka 10; b ka 10 c ka 1 make them same) but they must generate diff key as they are not anagra,s
                                                                                                                                3.Array + "#"
                                                                                                                                store char ki freq + "#" at index of arr; convert arr to string  
                                                                                                                                Problem solved:Both of the above problems are solved       



        Time:O(n*m)            --> iterating through n strings each of size m
        Space:O(n*m)            -->store n strings each of size mm
 
                                  
        */
        /*
        public List<List<String>> matrixCompareRowsForAnagramsGrouping(String[] arr ){
            Map<String,List<String>> map = new HashMap<>();
            
            for(int i=0;i<= arr.length-1;i++){
                String s = generateUniqueKey(arr[i]);
                if(!map.containsKey(s)){
                    List<String> tempList = new ArrayList<>();
                    tempList.add(arr[i]);
                    map.put(s,tempList);
                }
                else{
                    List<String> tempList = map.get(s);
                    tempList.add(arr[i]);
                    map.put(s,tempList);
                }
            }
        
            List<List<String>> res = new ArrayList<>();
            for(var i:map.entrySet()){
                res.add(i.getValue());
                
            }
        
            return res;
        }
    
    
        public String generateUniqueKey(String s){
            int[] arr = new int[26];
            for(int i=0 ; i<= s.length()-1;i++){
                arr[s.charAt(i) - 'a']++;
            }
            StringBuffer sb = new StringBuffer("");
            for(int i=0 ; i <= arr.length-1;i++){
                sb.append(arr[i]);
                sb.append("#");
            }
            
            return sb.toString();
     
        }
    
    
        */
        
        
        
    }
    public void    matrixPascalTriangle(int n){
        /*
        Question
        [[1],[1,2,1],[1,3,3,3],[1,4,6,1]] -- given n generate a pascal traingle
                                             pascal triangle has 1 on ends and middle elements is sum of upper 2 elements
                                               1
                                              1 2 1
                                             1 3 3 1
                                            1 4 6 4 1

        
        */
        
        
        //USING ARRAY -- MULTIPTR(ARRAY REQUIRES MULTIPTR)
        /*
        [[1],[1,1]] -- initialise list with 1st 2 elements //null check: if n== 1 initialise with 1st element and return
             tp1 tp2 tp3 
              |  |   |
        [[1],[1,1]   []    ]
              |      |
              ptr1   ptr2    --initialise ptr1 to 1 ptr2 to 1
                               move ptr2 till n-1
                                  initialise tmpptr1 to 0 tempptr2 to 1 tempptr3 tp 0
                                  add 1 at temptr3
                                  move tempptr3 ahead
                                  
                                  move tmpptr2 till list.get(ptr1).size() -1
                                      add tempptr1 + tempptr2 to tempptr3
                                      move tempptr1 ahead
                                      move tempptr2 ahead
                                      move tempptr3 ahead
                                    
                                 add 1 to tempptr3
                                 move tempptr3 ahead
                                
                                
                                move ptr1 ahead
                                move ptr2 ahead
                                
            Time:O(1 + 2 + 3 + ..n) = O(n(n+1)/2)  = O(n^2)
            Space:O(1)
            
                                
        
        **NOTE: Although the algorithm is iterative approach to constructing Pascal's triangle can be classified as "dynamic programming" because we construct each row based on the previous row.
        */
       List<List<Integer>>  list = new ArrayList<>();
        
        if(n == 1){
            List<Integer> tempList = new ArrayList<>();
            tempList.add(1);
            list.add(tempList);
            //return list;
        }
        
       
        
        //add 0 , 1 arrays
        List<Integer> temp1 = new ArrayList<>();
        List<Integer> temp2 = new ArrayList<>();
        temp1.add(1);
        temp2.add(1);
        temp2.add(1);
        list.add(temp1);
        list.add(temp2);
        
        
        int ptr1= 1;
        int ptr2 = 2;
        while(ptr2 <= n-1){
            int tempptr1 = 0;
            int tempptr2 = 1;
            int tempptr3 = 0;
            
            List<Integer> tempList = new ArrayList<>();
            tempList.add(1);
            tempptr3++;
            while(tempptr2 <= list.get(ptr1).size()-1){                
                int operand1 = list.get(ptr1).get(tempptr1);
                int operand2 = list.get(ptr1).get(tempptr2);
                tempList.add(tempptr3, operand1 + operand2);
                tempptr1++;
                tempptr2++;
                tempptr3++;
            }
            
            tempList.add(1);
            tempptr3++;
        
            list.add(tempList);
            
            
            ptr1++;
            ptr2++;
        }
        
          //return list;
    }
    public void    matrixTranspose(int[][] arr){
        /*
        1 2 3  --1 4 7-- transpose means row ka column , column ka row
        4 5 6    2 5 8
        7 8 9    3 6 9
        */
        
        //USING ARRAY-- MULTIPTR(ARRAY REQUIRES MULTIPTR)
        /*
        1 2 3  -- 0,0 --> 0,0
        4 5 6     0,1 --> 1,0
        7 8 9     0,2 --> 2,0
        
                  1,0 --> X
                  1,1 -->1,1
                  1,2 -->2,1
                  
                  2,0 -->X
                  2,1 -->X
                  2,2 --> 2,2
                  
                  iterate row 
                     iterate column 
                       if j >= i
                        swap arr[i][j] with arr[j][i]
                  
        Time:O(n*m) where n is no of rows and m is no of columns
        Space:O(1)
        
        */
        
        
        int i  = 0;
        while(i <= arr.length){
            int j = 0;
            while(j <= arr[0].length-1){
                if(j >= i){
                    int temp = arr[i][j];
                    arr[i][j] = arr[j][i];
                    arr[j][i] = temp;

                     
                }
                j++;   
                
            }
            i++;
        }
 
        
    }
    public void    matrixReflect(int[][] arr){
        /*
        1 2 3  -- 3 2 1  -- reflet means reverse across rows
        4 5 6     6 5 4 
        7 8 9     9 8 7
        
        */
        
        //USING ARRAY --MULTIPTR(ARRAY REQUIRES MULTIPTR)
        /*
        1 2 3
        4 5 6
        7 8 9  --iterate row
                   reverse column
                   
         Time:O(n*m) where n is no of rows and m is no of columns
        Space:O(1)
        
        */
        
        int i  = 0;
        while(i <= arr.length-1){
            int left = 0;
            int right = arr[i].length-1;
            while(left <= right){
                int temp = arr[i][left];
                arr[i][left] = arr[i][right];
                arr[i][right] = temp;
                
                left++;
                right--;
            }
            
            
            i++;
        }
        
        
    }
    public void    matrixRotateClockWise(int[][] arr){
        /*
        1 2 3  --7 4 1  -- rotate marix clockwise by 90 degree 
        4 5 6    2 5 8 
        7 8 9    3 6 9
        */
        
        //USING ARRAY --MULTIPTR(ARRAY REQUIRES MULTIPTR)
        /*
        1 2 3  -- transpose()
        4 5 6     reflect()
        7 8 9   
        
        Time:O(n*m) where n is no of rows and m is no of columns
        Space:O(1)
        
        */
        matrixTranspose(arr);
        matrixReflect(arr);

        
    }
    public void    matrixRotateAntiClockWise(int[][] arr){
        /*
        1 2 3  --3 6 9  -- rotate marix anticlockwise by 90 degree 
        4 5 6    2 5 8 
        7 8 9    1 4 7
        */
        
        //USING ARRAY --MULTIPTR(ARRAY REQUIRES MULTIPTR)
        /*
        1 2 3  -- reflect() 
        4 5 6     transpose()
        7 8 9  
        
        Time:O(n*m) where n is no of rows and m is no of columns
        Space:O(1)
        
        */
        matrixReflect(arr);
        matrixTranspose(arr);
      

        
    }
    public int[]   matrixSpiralTraversal(int[][] arr){
        /*
        Question
        [[1,2,3],    -- perform spiral traversal on matrix
        [4,5,6],        [1,2,3,6,9,8,7,4,5]
        [7,8,9]]    
        */


        //USING ARRAY -- MULTIPTR(ARRAY REQUIRES MULTIPTR)
        /*
        [[1,2,3],    
        [4,5,6],        
        [7,8,9]]   --initialise globally topBoundary to 0 , bottomBoundary to arr.length-1 
                    leftBoundary to 0 and rightBoundary to arr[0].length-1 
                    while(topBoundary<=bottomBoundary && leftBoundary<=rightBoundary){ -- move till topBoundary reaches bottomBoundary +1 and leftBoundary reches rightBoundary + 1(....)
                        if(movementCount == 0){                                           if it is 0th movement
                            moveRight(arr);}                                                 move right
                        else if(movementCount == 1){                                      elseif it is 1st movement 
                            moveDown(arr);}                                                 move bottom
                        else if(movementCount == 2){                                      elseif it is 2nd movement 
                            moveLeft(arr);}                                                 move left
                        else if(movementCount == 3){                                      elseif it is 3rd movement 
                            moveUp(arr);}                                                   move up
                        movementCount++;                                                  incremet movement
                        movementCount = movementCount%4;                                  movementCount = movementCount%4 for next round of movements
                    }
                    return res; 

                    //move right
                    int ptr = leftBoundary;                                           --initialise ptr to leftBoundary
                    while(ptr <= rightBoundary){                                        move ptr till rightBoundary+1(ptr at rightBoundary+1 , cb pr enc till rightBoundary , ca ptr en till rightBoundary+1)      
                        res[index++] =  arr[topBoundary][ptr];                               arr[topBoundary][ptr] add to result
                        ptr++; }                                                              move ptr ahead                     
                    topBoundary++;                                                       increment topBoundary for next right movement which will be below the current topBoundary

                    
                    //move left
                    int ptr = rightBoundary;                                         --initialise ptr to rightBoundary
                    while(ptr >= leftBoundary){                                        move ptr till leftBoundary-1(ptr at leftBoundary-1 , cb pr enc till leftBoundary , ca ptr en till leftBoundary-1)      
                        res[index++] =  arr[bottomBoundary][ptr];                             arr[bottomBoundary][ptr] add to result
                        ptr--; }                                                              move ptr behind                     
                    bottomBoundary--;                                                 decrement bottomBoundary for next left movement which will be above the current bottomBoundary
                
                    //move up
                    int ptr = bottomBoundary;                                         --initialise ptr to bottomBoundary
                    while(ptr >= topBoundary){                                          move ptr till topBoundary-1(ptr at topBoundary-1 , cb pr enc till topBoundary , ca ptr en till topBoundary-1)      
                        res[index++] =  arr[leftBoundary][ptr];                             arr[leftBoundary][ptr] add to result
                        ptr--; }                                                            move ptr behind                     
                    leftBoundary++;                                                    increment leftBoundary for next up movement which will be right to  the current leftBoundary
                
                    //move down
                    int ptr = topBoundary;                                         --initialise ptr to topBoundary
                    while(ptr <= bottomBoundary){                                          move ptr till bottomBoundary+1(ptr at bottomBoundary+1 , cb pr enc till bottomBoundary , ca ptr en till bottomBoundary+1)      
                        res[index++] =arr[ptr][rightBoundary]                              arr[ptr][rightBoundary] add to result
                        ptr++; }                                                            move ptr ahead                     
                    rightBoundary--;                                                    decrement rightBoundary for next down movement which will be left to  the current leftBoundary
                
        TIME:O(n*m) 
        SPACE:O(1)  
        
        */
        /*
        int topBoundary ;
        int bottomBoundary;
        int leftBoundary;
        int rightBoundary;
        int[] res;int index;
        public int[] matrixSpiralTraversal(int[][] arr){
            topBoundary = 0;
            bottomBoundary = arr.length-1;
            leftBoundary = 0;
            rightBoundary = arr[0].length-1;
            res = new int[arr.length * arr[0].length];index = 0;
            int movementCount = 0;
            while(topBoundary<=bottomBoundary && leftBoundary<=rightBoundary){
                if(movementCount == 0){
                    moveRight(arr);}
                else if(movementCount == 1){
                    moveDown(arr);}
                else if(movementCount == 2){
                    moveLeft(arr);}
                else if(movementCount == 3){
                    moveUp(arr);}
                movementCount++;
                movementCount = movementCount%4;
            }
            return res;   
        }

        
        public void moveRight(int[][] arr){
            int ptr = leftBoundary;
            while(ptr <= rightBoundary){
                res[index++] =  arr[topBoundary][ptr];
                ptr++;
            }
            topBoundary++;
        }
        public void moveLeft(int[][] arr){
            int ptr = rightBoundary;
            while(ptr >= leftBoundary){
                res[index++] =arr[bottomBoundary][ptr];
                ptr--;
            }
            bottomBoundary--;
        }
        public void moveUp(int[][] arr){
            int ptr = bottomBoundary;
            while(ptr >= topBoundary){
                res[index++] =arr[ptr][leftBoundary];
                ptr--;
            }
            leftBoundary++;
        }
        public void moveDown(int[][] arr){
            int ptr = topBoundary;
            while(ptr <= bottomBoundary){
                res[index++] =arr[ptr][rightBoundary];
                ptr++;
            }
            rightBoundary--;
        }

        
        */

        return null;
            
        
    }
    public int     matrixMaximumArea(int[][] arr){
        /*
        QUESTION
        0,1,1,0 
        ---------
       | 1,1,1,1 |   --> find the maximum area of a rectangle that can be formed in 1's  a matrix
       | 1,1,1,1 |       Eg : Th reatangle shown by dotted width = 4 ; ht = 2 
       |---------| 
         1,1,0,0
       
         */

        //USE STACK(Array Brute force O(n^2) once ypu reach each array ie inner loop depends on outer loop ie for(i=0 to arr.leng){for(j = i to arr.length)})
        /*
         [[0,1,1,0]-->[0,1,1,0]  --> for each row consider a histogram till the top of matrix and find arrayHistogramMaxArea
         [1,1,1,1] -->[1,2,2,1]       find max of all histogram's
         [1,1,1,1] -->[2,3,3,2]       
         [1,1,0,0]]-->[3,3,0,0]

        Time : O(n^m) where n^2(rows*column ) 
        Space: O(n)
        */
        int[] histogramArray = new int[arr[0].length];
        
        int i = 0;
        int maxArea = Integer.MIN_VALUE;
        while(i <= arr.length -1){
            int j = 0;
            while(j <= arr[0].length-1){
                if(arr[i][j] == 1){
                     histogramArray[j] = histogramArray[j] + arr[i][j];
                }
                else{
                       histogramArray[j]  = 0;
                }
                j++;
            }
            int maxAreaOfRow = arrayHistogramMaxArea(histogramArray);
            maxArea = Math.max(maxAreaOfRow,maxArea);
            
            i++;
        }

        return maxArea;




    }
    public void    matrixZeroFill(int[][] arr){
        /*
        0 1 2 0 --0 0 0 0  -- if an element is 0 then fill att its corresponsing row and column to 0
        3 4 5 2   0 4 5 0 
        1 3 1 5   0 3 1 5
        
        */
  
        //USING MULTIPTR + HASHMAP -->     Time:O(m*n),  Space:O(m+n)
        /*
        0 1 2 0 -- iterate matrix
        3 4 5 2       if arr[i][j] == 0
        1 3 1 5          add i to row set
                         add j to col set
  
                  iterate row set
                    iterate column
                      arr[i][j] = 0
  
                  iterate column set
                    iterate rows
                      arr[i][j] = 0
        Time:O(m*n)
        Space:O(m+n)
        */
        /*
        Set<Integer> row = new HashSet<>();
        Set<Integer> col = new HashSet<>();
        
        for(int i=0 ; i <= arr.length-1;i++){
            for(int j=0 ; j <= arr[0].length-1;j++){
                if(arr[i][j] == 0){
                    row.add(i);
                    col.add(j);
                }
            }
        }
        
        for(int i: row){
            for(int j=0 ; j <= arr[0].length-1;j++){
                arr[i][j] = 0;
            }
        }
        for(int j:col){
            for(int i=0; i <= arr.length-1;i++){
                arr[i][j] =0;
            }
        }
        */
  
        //USING MULTIPTR + STORING STATE -->    Time:O(m*n),     Space:O(1)
         /*
        0 1 2 0 -- use row 0 and column 0 as flags 
        3 4 5 2    iterate matrix   
        1 3 1 5      if(arr[i][j] == 0)
                       if i = 0 rowZeroSet = true   -->row0 and col0 are used to store flags; so we want to check if row0 and col0 themselves have to be set to 0 has to be stored in a variable
                       if i = 0 colZeroSet = true
  
                       set us row ka 0th element to 0 
                       set us column ka 0th element to 0
                       
                   iterate matrix
                     if i == 0 || j== 0         -->row0 and col0 are used to store flags; so you dont want to set them now 
                        continue 
  
                  if(rowZeroSet)               --> check if row0 is itself required to be set to 0
                    iterate column 
                       arr[0][column] = 0
                  if(rowZeroSet)              --> check if col0 is itself required to be set to 0
                    iterate row 
                       arr[row][0] = 0
  
                         
        Time:O(m*n)
        Space:O(1)
        */
        /*
        boolean rowZeroSet = false;
        boolean colZeroSet = false;
  
        for (int i=0;i<=arr.length-1;i++){
            for (int j=0;j<= arr[0].length-1;j++){
                if (arr[i][j] == 0){
                    if (i==0) rowZeroSet = true;
                    if (j==0) colZeroSet = true;
                    
                    arr[i][0] = 0;
                    arr[0][j] = 0;
                }
            }
        }
        
  
        for (int i=0;i<= arr.length-1;i++){
            for (int j=0;j<= arr[0].length-1 ;j++){
                if(i == 0 || j == 0){
                    continue;
                }
                if (arr[i][0] == 0 || arr[0][j] == 0)
                    arr[i][j] = 0;
            }
        }
        
  
        if (rowZeroSet){
            for (int j=0;j<= arr[0].length-1;j++){
                arr[0][j] = 0;
            }
        }
        
  
        if (colZeroSet){
              for (int i=0;i<= arr.length-1;i++){
                arr[i][0] = 0;
            }
        }
          
  
  
        */
  
       
        
        
    }
    public void    matrixAliveDeadSimultaneousFill(int[][] arr){
        /*
        [[1,1], --for the matrix  every cell is alove(1) or dead(0) must change according to game rules
        [1,0]]    and must happen simultaneously ie You cannot update some cells first and then use their updated values to update other cells.
                  Hence it will not use DFS, BFS etc
                  Game Rules
                  Any live cell with fewer than two live neighbors dies as if caused by under-population.
                  Any live cell with two or three live neighbors lives on to the next generation.
                  Any live cell with more than three live neighbors dies, as if by over-population.
                  Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.
                                
                  
        
        
        
        */

        //USING MULTIPTR + MATRIX-->Time:O(m*n) , Space:O(m*n)
        /*
        [[1,1],      --iterate arr
         [1,0]]           calculate surrounding 1's on each cell by moing in all 8 directions
                          set the arr2[i][j] based on game condition

                       iterate arr2
                          set arr = arr2

                        

        Time:O(8*n*m) -- as you traverse every node inmatrix and for every node check 8 neighbours
        Space:O(n*m) 00 for extra matrix
        */
        /*
        public void matrixAliveDeadSimultaneousFill(int[][] arr){
            int[][] arr2 = new int[arr.length][arr[0].length-1];
            for(int i=0 ; i <= arr.length-1;i++){
                for(int j=0 ; j <= arr[0].length-1;j++){
                    int noOfOnes = matrixCellnumberOfNeighBouringOnes(arr,i,j);

                    if(arr[i][j] == 0){
                        if(noOfOnes == 3){arr2[i][j] = 1;}
                    }
                    else if(arr[i][j] == 1){
                        if(noOfOnes < 2){arr2[i][j] = 0;}
                        if(noOfOnes == 2|| noOfOnes == 3){arr2[i][j] = 1;}
                        if(noOfOnes > 3){arr2[i][j] = 0;}
                    }
                }
        }
    } 
    
    public int matrixCellnumberOfNeighBouringOnes(int[][] arr, int m , int n){
        
        int noOfNeighBouringOnes = 0;
        if(m+1 <= arr.length-1 && arr[m+1][n] == 1){
            noOfNeighBouringOnes++;
        }
        if(m-1 >= 0 && arr[m-1][n] == 1){
            noOfNeighBouringOnes++;
        }
        if(n+1 <= arr[0].length-1 && arr[m][n+1] == 1){
            noOfNeighBouringOnes++;
        }
        if(n-1 >= 0 && arr[m][n-1] == 1){
            noOfNeighBouringOnes++;
        }
        if(m-1 >= 0 && n-1 >= 0 && arr[m-1][n-1] == 1){
            noOfNeighBouringOnes++;
        }
        if(m-1 >= 0 && n+1 <= arr[0].length-1 && arr[m-1][n+1] == 1){
            noOfNeighBouringOnes++;
        }
        if(m+1 <= arr.length-1 && n-1 >=0  && arr[m+1][n-1] == 1){
            noOfNeighBouringOnes++;
        }
        if(m+1 <= arr.length-1 && n+1  <= arr[0].length-1   && arr[m+1][n+1] == 1){
            noOfNeighBouringOnes++;
        }
        
        return noOfNeighBouringOnes;
        
        
    }
    
        
        
        */
      

        //USING MULTIPTR + STORING STATE->Time:O(m*n) , Space:O(m*n)
        /*
         [[1,1],      --iterate arr
         [1,0]]           calculate surrounding 1's on each cell by moing in all 8 directions
                          set the arr[i][j] based on game condition
                           0 -->1 store it as 2; 1-->0 store as 3 
                          so wherever you check for 0 also check for 2 because 2 means now it is 0 convert to 1 in future
                          so wherever you check for 1 also check for 3 because 2 means now it is 0 convert to 1 in future)

                          iterate arr
                            wherever there is 2 assign 1 because it means it was 0 which must be converted to 1
                            wherever there is 3 assign 0 because it means it was 1 which must be converted to 0

        Time:O(n*m)
        Space:O(1)           

        
        */
        /*
        public void matrixAliveDeadSimultaneousFill([][] arr){
            for(int i=0 ; i <= arr.length-1;i++){
                for(int j=0 ; j <= arr[0].length-1;j++){
                    int noOfOnes = matrixCellnumberOfNeighBouringOnes(arr,i,j);
                    if(arr[i][j] == 0|| arr[i][j] == 2){
                        if(noOfOnes == 3){arr[i][j] = 2;}
                    }
                    else if(arr[i][j] == 1 || arr[i][j] == 3){
                        if(noOfOnes < 2){arr[i][j] = 3;}
                        if(noOfOnes == 2|| noOfOnes == 3){arr[i][j] = 1;}
                        if(noOfOnes > 3){arr[i][j] = 3;}
                    }
                }
            }
            
            for(int i=0 ; i <= arr.length-1;i++){
                for(int j=0 ; j <= arr[0].length-1;j++){
                    if(arr[i][j] == 2){
                        arr[i][j] = 1;
                    }        
                    else if( arr[i][j] == 3){
                        arr[i][j] = 0;
                    }
                    
                }
            }

    
        
    } 
    public int matrixCellnumberOfNeighBouringOnes(int[][] arr, int m , int n){
        
        int noOfNeighBouringOnes = 0;
        if(m+1 <= arr.length-1 && (arr[m+1][n] == 1 || arr[m+1][n] == 3)){
            noOfNeighBouringOnes++;
        }
        if(m-1 >= 0 && (arr[m-1][n] == 1 || arr[m-1][n] == 3)){
            noOfNeighBouringOnes++;
        }
        if(n+1 <= arr[0].length-1 && (arr[m][n+1] == 1|| arr[m][n+1] == 3)){
            noOfNeighBouringOnes++;
        }
        if(n-1 >= 0 && (arr[m][n-1] == 1|| arr[m][n-1] == 3)){
            noOfNeighBouringOnes++;
        }
        if(m-1 >= 0 && n-1 >= 0 && (arr[m-1][n-1] == 1|| arr[m-1][n-1]  == 3)){
            noOfNeighBouringOnes++;
        }
        if(m-1 >= 0 && n+1 <= arr[0].length-1 && (arr[m-1][n+1] == 1|| arr[m-1][n+1] == 3)){
            noOfNeighBouringOnes++;
        }
        if(m+1 <= arr.length-1 && n-1 >=0  && (arr[m+1][n-1] == 1|| arr[m+1][n-1] == 3)){
            noOfNeighBouringOnes++;
        }
        if(m+1 <= arr.length-1 && n+1  <= arr[0].length-1   && (arr[m+1][n+1] == 1|| arr[m+1][n+1] == 3)){
            noOfNeighBouringOnes++;
        }
        
        return noOfNeighBouringOnes;
        
        
    }
    
   
        
        
        */
    
        
    } 
    public String  matrixTikTakToe(int[][] arr, int size){
        /*
        [[0,0],[2,0],[1,1],[2,1],[2,2]] --arr consiste of pos where players mark their 'X' and 'O' alternatively
        size = 3                          ie player1 marks 'X' at 0,0 player2 marks at 'O' at 2,0 ans do on
                                          size is the size of sizeXsize tik tak board
                                          return "A"  if player1 wins "B" if player2 wins, "Draw" is no one wins "Pending" if game is not complete
                                         
        */

        /*
        [[0,0],[2,0],..] 
                        int[] cols = new int[size];                -- cols will hold count on each  column of the matrix
                        int[] rows = new int[size];                   rows will hold count on each rows of the matrix
                        int diagonal = 0;                             diagonal holds count on the diagonal of the matrix(matrix has only 1 diagonal)
                        int antiDiagonal = 0;                         antiDiagonal holds count on the antiDiagonal of the matrix(matrix has only 1 antiDiagonal)
                        
                        
                        for(int i=0 ; i <= arr.length-1;i++){       --iterate array
                            int m = arr[i][0];                           find m,n indexes
                            int n =  arr[i][1];                              
                            if(i%2 == 0){                                if it is player1
                                cols[m]++;                                  increment mth column ka count
                                rows[n]++;                                  increment nth row ka count  
                                if(m == n){diagonal++;}                     if it is diagonal , increment diagonal
                                if(m == (size-n-1)){antiDiagonal++;}        if it is antiDiagonal,increment antidiagonal
                            }
                            else{                                        if it is player2
                                cols[m]--;                                  decrement mth column ka count
                                rows[n]--;                                  decrement nth row ka row ka count
                                if(m == n){diagonal--;}                     if diagonal decrement diagonal 
                                if(m == (size-n-1)){antiDiagonal--;}        if antidiagonal decrement diagonal 
                            }
                            

                            if(Math.abs(cols[m]) == size                 if mth column is filled
                            ||Math.abs(rows[n]) == size                    ||nth column is filled
                            ||Math.abs(diagonal) == size                   ||diagonal is filled
                            ||Math.abs(antiDiagonal) == size){             ||antidiagonal is filled
                                return i%2 == 0 ? "A":"B";                     then current player(based on i) is the winner
                            }
                        }
                        if(arr.length == size*size){                     if arr contains moves equal to fill all board cells and we dont have a winner
                              return "Draw"                                      means game is draw
                        else if(arr.length < size*size)){                else if arr doesnt contains moves required to fill board cells
                            return "Pending"                                       means game is pending
                        }

        Time:O(m) where m is the length of arr of moves
        Space:O(n + n) where n is the size of the board


 
        */
        int[] cols = new int[size];
        int[] rows = new int[size];
        int diagonal = 0;
        int antiDiagonal = 0;
        
        
        for(int i=0 ; i <= arr.length-1;i++){
             int m = arr[i][0];  
             int n =  arr[i][1]; 
            if(i%2 == 0){
                cols[m]++;
                rows[n]++;
                if(m == n){diagonal++;}
                if(m + n == 2){antiDiagonal++;}
            }
            else{
                cols[m]--;
                rows[n]--;
                if(m == n){diagonal--;}
                if(m + n == 2){antiDiagonal--;}
            }
            
            if(
                Math.abs(cols[m]) == size
               ||Math.abs(rows[n]) == size
               ||Math.abs(diagonal) == size
               ||Math.abs(antiDiagonal) == size
              ){
                return i%2 == 0 ? "A":"B";
            }
        }
        
        if(arr.length == size*size){
            return "Draw";
        }
        else if(arr.length < size*size){
            return "Pending";
        }
        
        return "";
        
    }
    public void    matrixTikTakToeDesign(int[][] arr, int size){
        /*
        class TicTacToe {
            public TicTacToe(int n) {}   --initialises tik tok board of size n*n
            public int move(int col,int row,int player) -- for player=1 or player =2 this fn initialises board at row,column
                                                           and returns 1 if P1 wins , 2 if player 2 wins , 0 if no one wins

        }
        */

        /*

        class TicTacToe {
            int[] cols;                              -- cols will hold count on each  column of the matrix
            int[] rows;                                 rows will hold count on each rows of the matrix
            int diagonal;                               diagonal holds count on the diagonal of the matrix(matrix has only 1 diagonal)
            int antiDiagonal;                           antiDiagonal holds count on the antiDiagonal of the matrix(matrix has only 1 antiDiagonal)
            public TicTacToe(int n) {
                cols = new int[n];
                rows = new int[n];
                diagonal =0;
                antiDiagonal = 0;
            }
            
            public int move(int col, int row, int player) {
                int m = col;                           --find m,n indexes
                int n = row; 
                if(player == 1){                                if it is player1
                    cols[m]++;                                  increment mth column ka count
                    rows[n]++;                                  increment nth row ka count  
                    if(m == n){diagonal++;}                     if it is diagonal , increment diagonal
                    if(m + n == 2){antiDiagonal++;}             if it is antiDiagonal,increment antidiagonal
                }
                else if(player == 2){                           if it is player2
                    cols[m]--;                                  decrement mth column ka count
                    rows[n]--;                                  decrement nth row ka row ka count
                    if(m == n){diagonal--;}                     if diagonal decrement diagonal 
                    if(m + n == 2){antiDiagonal--;}             if antidiagonal decrement diagonal 
                }
    
                int size = rows.length; //OR cols.length
                if(Math.abs(cols[m]) == size                   if mth column is filled
                ||Math.abs(rows[n]) == size                    ||nth column is filled
                ||Math.abs(diagonal) == size                   ||diagonal is filled
                ||Math.abs(antiDiagonal) == size){             ||antidiagonal is filled
                    return player;                             then current player is the winner
                }
                        
                return 0;                                     --return 0 of no winner
                
            }
            
        
            

        }


        Time:O(1)   for both the fns   
        Space:O(n + n) where n is the size of the board
 
        */

    }
    public boolean matrixIsValidSudoku(char[][] arr){
        /*
        Question
        [["5","3",".",".","7",".",".",".","."]   -- given an matrix 
        ,["6",".",".","1","9","5",".",".","."]      return if it is a sudoku 
        ,[".","9","8",".",".",".",".","6","."]      1. rows have numbers 1 to 9 without repetition
        ,["8",".",".",".","6",".",".",".","3"]      2. column have digits 1 to 9 without repitition
        ,["4",".",".","8",".","3",".",".","1"]      3. 3x3 bokes  have digits 1 to 9 without repitition
        ,["7",".",".",".","2",".",".",".","6"]      Validate only filled cells
        ,[".","6",".",".",".",".","2","8","."]
        ,[".",".",".","4","1","9",".",".","5"]
        ,[".",".",".",".","8",".",".","7","9"]]
                */
        
        /*
        [[0,0],[2,0],..] 
         |
                List<HashSet<Character>> rows = new ArrayList<>();  --rows will hold set for each row
                List<HashSet<Character>> cols = new ArrayList<>();    cols will hold set for each column
                List<HashSet<Character>> boxes = new ArrayList<>();    boxes will hold set for each 3X3 box
                for (int i = 0; i <= arr.length-1; i++) {
                    rows.add(i,new HashSet<Character>());
                    cols.add(i,new HashSet<Character>());
                    boxes.add(i,new HashSet<Character>());
                    
                }
                

                for (int i = 0; i <= arr.length-1; i++) {                  --iterate array 
                    for (int j = 0; j <= arr[0].length-1; j++) {               if val is not digit  continue
                        char val = arr[i][j]                                   if row[i] contains val || col[j] contaons val || boxes[idx] contaons val return false
                        if(!Character.isDigit(val)){continue;}                 add val to row[i] , col[j]., box[idx]            
                                                                               IDX:
                        int idx = (i / 3) * 3 + j / 3;                         box0 box1 box2      -->i/3   will give you box  row 
                        if (rows.get(i).contains(val)                          box3 box4 box5         i*3*3 will give you box row ka 1st box number as each row above it has 3 boxes 
                            ||cols.get(j).contains(val)                        box6 box7 box8         j/3   will give you box column
                            ||boxes.get(idx).contains(val)){                                          Eg: i = 6 ; j = 8
                                                                                                          i/3 =2   -->box row = 2
                            return false;                                                                 i/3*3 =6 -->box row = 2 ka 1st box is box6
                        }                                                                                 j/3 = 2  -->box column = 2
                        rows.get(i).add(val);                                                            i/3*3 + j/3 -->box8
                        cols.get(j).add(val);
                        boxes.get(idx).add(val);
                }
                return true;                                             --return true
        

        Time:O(8*n*m) -- as you traverse every node inmatrix and for every node check 8 neighbours
        Space:O(3*n*m) --> for  rows, cols, boxes 
        
        */

        List<HashSet<Character>> rows = new ArrayList<>(); 
        List<HashSet<Character>> cols = new ArrayList<>(); 
        List<HashSet<Character>> boxes = new ArrayList<>(); 
        for (int i = 0; i <= arr.length-1; i++) {
            rows.add(i,new HashSet<Character>());
            cols.add(i,new HashSet<Character>());
            boxes.add(i,new HashSet<Character>());
            
        }

        for (int i = 0; i <= arr.length-1; i++) {
            for (int j = 0; j <= arr[0].length-1; j++) {
                char val = arr[i][j];

                if(!Character.isDigit(val)){
                    continue;
                }
                
                int idx = (i / 3) * 3 + j / 3;
                if (rows.get(i).contains(val) || cols.get(j).contains(val)|| boxes.get(idx).contains(val)) {
                    return false;
                }
                rows.get(i).add(val);
                cols.get(j).add(val);
                boxes.get(idx).add(val);
    
            }
        }
        return true;
    }
    
    

}


 
